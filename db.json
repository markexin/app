{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","path":"fancybox/jquery.fancybox.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","path":"js/jquery-3.4.1.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","path":"fancybox/jquery.fancybox.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","path":"css/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/maupassant/source/css/copycode.css","path":"css/copycode.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/copyright.css","path":"css/copyright.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/dark.css","path":"css/dark.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/donate.css","path":"css/donate.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/search.css","path":"css/search.css","modified":0,"renderable":1},{"_id":"themes/maupassant/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/alipay.svg","path":"img/alipay.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/bitcoin.svg","path":"img/bitcoin.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/github.svg","path":"img/github.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/like.svg","path":"img/like.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/paypal.svg","path":"img/paypal.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/img/wechat.svg","path":"img/wechat.svg","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","path":"js/codeblock-resizer.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/copycode.js","path":"js/copycode.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/copyright.js","path":"js/copyright.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/donate.js","path":"js/donate.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/love.js","path":"js/love.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/fancybox.js","path":"js/fancybox.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/share.js","path":"js/share.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/smartresize.js","path":"js/smartresize.js","modified":0,"renderable":1},{"_id":"themes/maupassant/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1640656346866},{"_id":"node_modules/hexo-theme-landscape/package.json","hash":"9a94875cbf4c27fbe2e63da0496242addc6d2876","modified":1640330706018},{"_id":"node_modules/hexo-theme-landscape/README.md","hash":"d2772ece6d4422ccdaa0359c3e07588834044052","modified":1640330706028},{"_id":"node_modules/hexo-theme-landscape/languages/en.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1640330706492},{"_id":"node_modules/hexo-theme-landscape/_config.yml","hash":"b608c1f1322760dce9805285a602a95832730a2e","modified":1640330706492},{"_id":"node_modules/hexo-theme-landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1640330705883},{"_id":"node_modules/hexo-theme-landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1640330706492},{"_id":"node_modules/hexo-theme-landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1640330706492},{"_id":"node_modules/hexo-theme-landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1640330706492},{"_id":"node_modules/hexo-theme-landscape/languages/it.yml","hash":"89b7d91306b2c1a0f3ac023b657bf974f798a1e8","modified":1640330706492},{"_id":"node_modules/hexo-theme-landscape/languages/hu.yml","hash":"284d557130bf54a74e7dcef9d42096130e4d9550","modified":1640330706492},{"_id":"node_modules/hexo-theme-landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1640330706492},{"_id":"node_modules/hexo-theme-landscape/languages/mn.yml","hash":"2e7523951072a9403ead3840ad823edd1084c116","modified":1640330706493},{"_id":"node_modules/hexo-theme-landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1640330706492},{"_id":"node_modules/hexo-theme-landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1640330706492},{"_id":"node_modules/hexo-theme-landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1640330706492},{"_id":"node_modules/hexo-theme-landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1640330706492},{"_id":"node_modules/hexo-theme-landscape/languages/tr.yml","hash":"a1cdbfa17682d7a971de8ab8588bf57c74224b5b","modified":1640330706492},{"_id":"node_modules/hexo-theme-landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1640330706493},{"_id":"node_modules/hexo-theme-landscape/languages/zh-CN.yml","hash":"1efd95774f401c80193eac6ee3f1794bfe93dc5a","modified":1640330706493},{"_id":"node_modules/hexo-theme-landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1640330706493},{"_id":"node_modules/hexo-theme-landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1640330705890},{"_id":"node_modules/hexo-theme-landscape/layout/layout.ejs","hash":"0d1765036e4874500e68256fedb7470e96eeb6ee","modified":1640330705891},{"_id":"node_modules/hexo-theme-landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1640330705887},{"_id":"node_modules/hexo-theme-landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1640330705879},{"_id":"node_modules/hexo-theme-landscape/scripts/fancybox.js","hash":"c857d7a5e4a5d71c743a009c5932bf84229db428","modified":1640330705972},{"_id":"node_modules/hexo-theme-landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1640330705886},{"_id":"node_modules/hexo-theme-landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1640330705881},{"_id":"node_modules/hexo-theme-landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1640330705881},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1640330705886},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/after-footer.ejs","hash":"414914ebb159fac1922b056b905e570ac7521925","modified":1640330705879},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/archive.ejs","hash":"7cb70a7a54f8c7ae49b10d1f37c0a9b74eab8826","modified":1640330705886},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1640330705890},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/footer.ejs","hash":"3656eb692254346671abc03cb3ba1459829e0dce","modified":1640330705880},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/head.ejs","hash":"f215d92a882247a7cc5ea80b241bedfcec0ea6ca","modified":1640330705890},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/header.ejs","hash":"c1acd247e14588cdf101a69460cb8319c18cd078","modified":1640330705890},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/article.ejs","hash":"dfd555c00e85ffc4207c88968d12b219c1f086ec","modified":1640330705887},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1640330705891},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1640330705891},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1640330705882},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1640330705886},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1640330705887},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/recent_posts.ejs","hash":"60c4b012dcc656438ff59997e60367e5a21ab746","modified":1640330705882},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1640330705887},{"_id":"node_modules/hexo-theme-landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1640330705893},{"_id":"node_modules/hexo-theme-landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1640330706074},{"_id":"node_modules/hexo-theme-landscape/source/css/_variables.styl","hash":"581b0cbefdaa5f894922133989dd2d3bf71ded79","modified":1640330706074},{"_id":"node_modules/hexo-theme-landscape/source/css/style.styl","hash":"9c451e5efd72c5bb8b56e8c2b94be731e99db05b","modified":1640330706074},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1640330705884},{"_id":"node_modules/hexo-theme-landscape/source/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1640330706029},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1640330705880},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/date.ejs","hash":"f1458584b679545830b75bef2526e2f3eb931045","modified":1640330705887},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1640330705887},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1640330705882},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/title.ejs","hash":"4d7e62574ddf46de9b41605fe3140d77b5ddb26d","modified":1640330705886},{"_id":"node_modules/hexo-theme-landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1640330705891},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1640330706077},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/article.styl","hash":"80759482d07063c091e940f964a1cf6693d3d406","modified":1640330706077},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1640330706077},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1640330706077},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1640330706078},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1640330706074},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1640330706074},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1640330706074},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1640330706079},{"_id":"node_modules/hexo-theme-landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1640330706074},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1640330706071},{"_id":"node_modules/hexo-theme-landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1640330706073},{"_id":"node_modules/hexo-theme-landscape/source/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1640330706015},{"_id":"node_modules/hexo-theme-landscape/source/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1640330705998},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1640330706406},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1640330706497},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1640330706372},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1640330706074},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1640330705905},{"_id":"node_modules/hexo-theme-landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1640330705972},{"_id":"node_modules/hexo-theme-landscape/source/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1640330706268},{"_id":"themes/cafe/layout/_scripts/index.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1640656406883},{"_id":"themes/cafe/.bowerrc","hash":"5d8502d31f0ed07e935bc6faf5e7f8ce8308ab75","modified":1640656406847},{"_id":"themes/cafe/.gitignore","hash":"a632e0ef685c46927968336af6b03ab3465d4fb2","modified":1640656406847},{"_id":"themes/cafe/README.md","hash":"7f7b7b853aa9f62d97fb2e5979e962dd47b93aaa","modified":1640656406847},{"_id":"themes/cafe/README_en.md","hash":"c66ddb0326313f1b912d41d735e22dd2d10509e1","modified":1640656406847},{"_id":"themes/cafe/_config.yml","hash":"5fd0430fff523d84ef511b6505886070f07b67d0","modified":1640656406847},{"_id":"themes/cafe/bower.json","hash":"b62df738176f21afb7f9bac2ddca8b269fd4b863","modified":1640656406877},{"_id":"themes/cafe/cafe-qrcode.png","hash":"4fef2c889376a208a49aa92c582b147e7e005d23","modified":1640656406877},{"_id":"themes/cafe/package.json","hash":"bf40790696da9a813489f49dcf90a87f9114869c","modified":1640656406888},{"_id":"themes/cafe/webpack.config.js","hash":"7fa25bf7c2bf831c8dfcece8bbeee6cb5c2b2c80","modified":1640656406913},{"_id":"themes/cafe/assets/duoshuo_comment.png","hash":"33402149f82b66ff4ed405f44beb06eb0172b6de","modified":1640656406848},{"_id":"themes/cafe/assets/share.png","hash":"823926d9cb8985ceb93a119ef138f9638a8ead1a","modified":1640656406877},{"_id":"themes/cafe/languages/default.yml","hash":"0f4186f8e0c5d83cddf443fb9d7d4f200780831b","modified":1640656406877},{"_id":"themes/cafe/languages/en.yml","hash":"4d072fac64d756579962d3c0d10e300c11f99668","modified":1640656406878},{"_id":"themes/cafe/languages/no.yml","hash":"d326d07449152e874d419c21fe31bbbfa624809c","modified":1640656406878},{"_id":"themes/cafe/languages/nl.yml","hash":"218d1ef7863e884de5e48c6a9fa7c8e3a07a88c6","modified":1640656406878},{"_id":"themes/cafe/languages/ru.yml","hash":"2b9f264074acbbdd46512d8d7488e7ec0eee2da9","modified":1640656406878},{"_id":"themes/cafe/languages/zh-CN.yml","hash":"fd7eb6f2395cd8c483119bb96882c7dd3004881d","modified":1640656406878},{"_id":"themes/cafe/languages/zh-TW.yml","hash":"a53f356900ffd40cb87dfbb96e5c677ed88e9992","modified":1640656406879},{"_id":"themes/cafe/layout/category.ejs","hash":"f46e99e5b68c2ee67bdab068b1da4029bc09847d","modified":1640656406886},{"_id":"themes/cafe/layout/archive.ejs","hash":"11912b8e50dafbe9b0a65df0beaeab64fde90abe","modified":1640656406886},{"_id":"themes/cafe/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1640656406886},{"_id":"themes/cafe/layout/layout.ejs","hash":"54719bf692ee75c4e0fc4a39dec83484e4851307","modified":1640656406887},{"_id":"themes/cafe/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1640656406887},{"_id":"themes/cafe/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1640656406888},{"_id":"themes/cafe/layout/tag.ejs","hash":"4349f382b07603f9d2c03dd4df70ddea9b9a035c","modified":1640656406888},{"_id":"themes/cafe/scripts/fancybox.js","hash":"1c20613889139c652923b57b42ce6f7bc279511b","modified":1640656406888},{"_id":"themes/cafe/scripts/extend.generator.js","hash":"06d801d46268351c34f1b0a2fc67726cf9418baa","modified":1640656406888},{"_id":"themes/cafe/source/favicon.ico","hash":"96b9a549337c2bec483c2879eeafa4d1f8748fed","modified":1640656406909},{"_id":"themes/cafe/layout/_partial/archive-post.ejs","hash":"4c7716e53396abdf828b518f90df3c00e63349da","modified":1640656406879},{"_id":"themes/cafe/layout/_partial/after-footer.ejs","hash":"e48868420643950050f8622a1a68d738f0fddde5","modified":1640656406879},{"_id":"themes/cafe/layout/_partial/archive.ejs","hash":"b7358ffcbd26bc2c6c7bf384c4fb7b68085b6cbc","modified":1640656406879},{"_id":"themes/cafe/layout/_partial/article.ejs","hash":"1d6e90775a6f52b862047adf2369ce8c1282554a","modified":1640656406880},{"_id":"themes/cafe/layout/_partial/comments.ejs","hash":"43217242b743530f6dd1c08e41af5c255f14abd9","modified":1640656406880},{"_id":"themes/cafe/layout/_partial/footer.ejs","hash":"fbc03f56835e967bfe6021a2102f058b1ec27af5","modified":1640656406880},{"_id":"themes/cafe/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1640656406880},{"_id":"themes/cafe/layout/_partial/head.ejs","hash":"6774dad5680a91f8a4d21e5d73189b92a9b6864b","modified":1640656406880},{"_id":"themes/cafe/layout/_partial/header.ejs","hash":"ee530030409ee4cd67136ad23c96aa1b3466293e","modified":1640656406881},{"_id":"themes/cafe/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1640656406881},{"_id":"themes/cafe/layout/_partial/random_posts.ejs","hash":"8ac10cb23345a04de2683bcfc2122f26111131ed","modified":1640656406882},{"_id":"themes/cafe/layout/_partial/sidebar.ejs","hash":"ce3ecf7c74fd5f50aebada49e403152de114e6bb","modified":1640656406882},{"_id":"themes/cafe/layout/_partial/widget.ejs","hash":"fe22996588b33eb9d44ab104c6ed5687fb11cac6","modified":1640656406882},{"_id":"themes/cafe/layout/_third-part/index.ejs","hash":"219d269b6840d5dde5a14e4f26ef49d102d32532","modified":1640656406884},{"_id":"themes/cafe/layout/_widget/archive.ejs","hash":"39a047c9bcfbce9d6a815b3938211213bd5268f7","modified":1640656406884},{"_id":"themes/cafe/layout/_widget/category.ejs","hash":"6064d276caf727d3e082343f9a30b015d30fdd48","modified":1640656406885},{"_id":"themes/cafe/layout/_widget/friendly_link.ejs","hash":"0c01b13ad81b729fd1f39e01b819d6f315a411b8","modified":1640656406885},{"_id":"themes/cafe/layout/_widget/hot_comment_posts.ejs","hash":"819fd75aad2d16d58bc06054b8fdf966d222576a","modified":1640656406885},{"_id":"themes/cafe/layout/_widget/lastest_comments.ejs","hash":"518f17d2a3ca5daca4a8a6ed186bae3ae348fde5","modified":1640656406885},{"_id":"themes/cafe/layout/_widget/post_content.ejs","hash":"9f17038635d221719c7ef10ae473f7f5b288fc9a","modified":1640656406885},{"_id":"themes/cafe/layout/_widget/recent_posts.ejs","hash":"1eca91f3cd8fb4563f708678130138be9404b70e","modified":1640656406885},{"_id":"themes/cafe/layout/_widget/social.ejs","hash":"601c0295ac544942bc78185ce5378a3a19f267fe","modified":1640656406885},{"_id":"themes/cafe/layout/_widget/tag.ejs","hash":"e82a6951bf13a05f0d2218516d51fac1953d6739","modified":1640656406886},{"_id":"themes/cafe/layout/_widget/tagcloud.ejs","hash":"a5846d3bd367a8147d84d57e64ebc93441378cd8","modified":1640656406886},{"_id":"themes/cafe/layout/_widget/wechat.ejs","hash":"22d19c533a30e41c56a45e4edb74ec30c8c70978","modified":1640656406886},{"_id":"themes/cafe/layout/partials/back2top.ejs","hash":"3b69f1d825f1837100151197da2b13b34676345d","modified":1640656406887},{"_id":"themes/cafe/layout/partials/hot-comment-posts.ejs","hash":"af27de063408d3336ea7bd700d3ea2c4bef71ae0","modified":1640656406887},{"_id":"themes/cafe/layout/partials/lastest-comments.ejs","hash":"64cf0da989e6aeb4635482f48355d74447ba32c8","modified":1640656406887},{"_id":"themes/cafe/layout/partials/pagination.ejs","hash":"146ae79bd5a89524d5f8026c21ed34a557fe753d","modified":1640656406887},{"_id":"themes/cafe/layout/partials/recent-posts.ejs","hash":"c4d6ad99fabe8a9821511e2c39861b268779d40e","modified":1640656406887},{"_id":"themes/cafe/source/_data/themes.yml","hash":"dbbd2878f85379b3c388f09539327085e0cdde34","modified":1640656406889},{"_id":"themes/cafe/source/css/_extend.styl","hash":"faef85ad9c2806b634a638b0b05b825277c11e45","modified":1640656406889},{"_id":"themes/cafe/source/css/_variables.styl","hash":"73cd2ad7c06c49b6f01ed0cd207e7aac55d22c8c","modified":1640656406892},{"_id":"themes/cafe/source/css/style.styl","hash":"78a349fe6901a1ebe6668b58a33ca129cf9cdd35","modified":1640656406904},{"_id":"themes/cafe/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1640656406904},{"_id":"themes/cafe/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1640656406905},{"_id":"themes/cafe/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1640656406905},{"_id":"themes/cafe/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1640656406905},{"_id":"themes/cafe/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1640656406905},{"_id":"themes/cafe/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1640656406906},{"_id":"themes/cafe/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1640656406908},{"_id":"themes/cafe/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1640656406908},{"_id":"themes/cafe/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1640656406909},{"_id":"themes/cafe/source/images/fly-to-top.png","hash":"f189038da3c68a8012e924185a1faee98bde3003","modified":1640656406909},{"_id":"themes/cafe/source/js/elevator.js","hash":"2aab182c3f08aa939bbf09faf49e79e0681a6389","modified":1640656406911},{"_id":"themes/cafe/source/js/is.js","hash":"457446cf7fe0b08bfa197ee76435d273b456deaa","modified":1640656406911},{"_id":"themes/cafe/source/js/script.js","hash":"320cc11fb445658e7a1e1bb2e9da499ee579d755","modified":1640656406911},{"_id":"themes/cafe/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1640656406881},{"_id":"themes/cafe/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1640656406881},{"_id":"themes/cafe/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1640656406881},{"_id":"themes/cafe/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1640656406882},{"_id":"themes/cafe/layout/_partial/post/duoshuo.ejs","hash":"0ea7f7effe32f7c9b0716c380850223feb262bcd","modified":1640656406881},{"_id":"themes/cafe/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1640656406882},{"_id":"themes/cafe/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1640656406882},{"_id":"themes/cafe/layout/_third-part/comments/changyan.ejs","hash":"b32598bc07328d8118f6b8b8b898a5d3dba4adc0","modified":1640656406883},{"_id":"themes/cafe/layout/_third-part/comments/disqus.ejs","hash":"f9543a67619272c9ff23b461ffcc63b504385461","modified":1640656406883},{"_id":"themes/cafe/layout/_third-part/comments/duoshuo.ejs","hash":"a37a59cf0226afc1d187810c81c61f4bf5a6a6b7","modified":1640656406883},{"_id":"themes/cafe/layout/_third-part/comments/index.ejs","hash":"e32b4c07c55dae75fefbe51d6afc2a0a760f2958","modified":1640656406884},{"_id":"themes/cafe/layout/_third-part/comments/youyan.ejs","hash":"466db2fad7c05b57d8987fc0e042e76072b4e6b2","modified":1640656406884},{"_id":"themes/cafe/layout/_third-part/comments/gitment.ejs","hash":"25c71114ff0ede012d2dcb72cfb4e821f1744634","modified":1640656406883},{"_id":"themes/cafe/layout/_third-part/comments/gentie.ejs","hash":"7bb3a0aa215dba09f87bf227b170d54ba69cadb3","modified":1640656406883},{"_id":"themes/cafe/layout/_third-part/mathjax/index.ejs","hash":"7b03a461fd2caf4662665a93c5d0e22b6a2ff1a6","modified":1640656406884},{"_id":"themes/cafe/source/css/_partial/archive.styl","hash":"bcc996ab9d1a3a2e0f754043a6c93ddd314d9987","modified":1640656406889},{"_id":"themes/cafe/source/css/_partial/article.styl","hash":"1273f03633fe8d4199b6269663fcb71dd2c81297","modified":1640656406889},{"_id":"themes/cafe/source/css/_partial/comment.styl","hash":"3477b4ecb2b188528b4f9c12fe78369110e0616b","modified":1640656406890},{"_id":"themes/cafe/source/css/_partial/custom.styl","hash":"f162ddfa65c268d79425e8c143688481f559ad2c","modified":1640656406890},{"_id":"themes/cafe/source/css/_partial/duoshuo.styl","hash":"5c9cb2c43be136a3cc83fb961b2e030e34cdd0f7","modified":1640656406890},{"_id":"themes/cafe/source/css/_partial/footer.styl","hash":"17fb21e25e7cdd57b3a33d402563d7c543ba9218","modified":1640656406890},{"_id":"themes/cafe/source/css/_partial/header.styl","hash":"56b324a23438b1b72c3b1de72ff123c5ca2ca266","modified":1640656406890},{"_id":"themes/cafe/source/css/_partial/highlight.styl","hash":"83af177b67e71f88a2a58cad944fb1460a41f752","modified":1640656406890},{"_id":"themes/cafe/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1640656406890},{"_id":"themes/cafe/source/css/_partial/sidebar-aside.styl","hash":"cd6e5f50b9db9a9f582995c16d634b1c427a2d00","modified":1640656406891},{"_id":"themes/cafe/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1640656406891},{"_id":"themes/cafe/source/css/_partial/other.styl","hash":"e8892f04955c0738bd80bf92d72ee634d2a4e01a","modified":1640656406891},{"_id":"themes/cafe/source/css/_partial/random-post.styl","hash":"dba79ab57f6236d7128f3b7680eb2f6ccc84c26e","modified":1640656406891},{"_id":"themes/cafe/source/css/_partial/sidebar.styl","hash":"ecd3303b117ae929558899d491e12094d4117829","modified":1640656406891},{"_id":"themes/cafe/source/css/_partial/social.styl","hash":"fc8d62aada96c75930dc03f6d4af83595eb44e71","modified":1640656406891},{"_id":"themes/cafe/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1640656406892},{"_id":"themes/cafe/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1640656406892},{"_id":"themes/cafe/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1640656406906},{"_id":"themes/cafe/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1640656406906},{"_id":"themes/cafe/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1640656406907},{"_id":"themes/cafe/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1640656406907},{"_id":"themes/cafe/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1640656406907},{"_id":"themes/cafe/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1640656406907},{"_id":"themes/cafe/source/themes/screenshots/Cafe.png","hash":"6f639068117b8d44005730864cc0b05a11b28d73","modified":1640656406912},{"_id":"themes/cafe/source/duoshuo/embed.js","hash":"6a8d90f99d17a614312f87d9a6a7182c9cb484f4","modified":1640656406904},{"_id":"themes/cafe/source/jquery/jquery.min.js","hash":"a6eedf84389e1bc9f757bc2d19538f8c8d1cae9d","modified":1640656406910},{"_id":"themes/cafe/source/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1640656406900},{"_id":"themes/cafe/source/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1640656406901},{"_id":"themes/cafe/source/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1640656406893},{"_id":"themes/cafe/source/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1640656406895},{"_id":"themes/cafe/source/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1640656406900},{"_id":"themes/cafe/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1640656406902},{"_id":"themes/cafe/source/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1640656406897},{"_id":"themes/cafe/assets/pc-display.gif","hash":"fb84eb2ba958b1e02ad5e178a6f367a561cd9252","modified":1640656406875},{"_id":"themes/cafe/assets/mobie-display.gif","hash":"d20f7aa46d9bf618ba1ebaf9b6bda71b030f0ce9","modified":1640656406862},{"_id":"themes/cafe/source/js/posts.js","hash":"dffccd156bf656d3c36a80c8bf8b2bf81258dd08","modified":1640656544353},{"_id":"themes/maupassant/.gitignore","hash":"16945417d10c15c950306794dbb0d970b5a199fe","modified":1640656547335},{"_id":"themes/maupassant/.travis.yml","hash":"0339959f29deddc365e8fe8bd85da524410b9a23","modified":1640656547335},{"_id":"themes/maupassant/LICENSE","hash":"f0ac2f92770650c9835183f79010c0d307b34acd","modified":1640656547335},{"_id":"themes/maupassant/_config.yml","hash":"8c11ee5725455ae049335419efeb9c498c7f32df","modified":1640659543875},{"_id":"themes/maupassant/README.md","hash":"08a3499122e10a8fd8e0a75dcd4cce0125e8c98d","modified":1640656547335},{"_id":"themes/maupassant/package.json","hash":"f092433469eb87362e831326425a6a5c3c9fea0d","modified":1640656547342},{"_id":"themes/maupassant/languages/de-DE.yml","hash":"7be5bc400deeb80b3f98d9caad8303926612cfb7","modified":1640657933161},{"_id":"themes/maupassant/languages/en.yml","hash":"9e382047eac31a5ff7d936280ee566d84ac9277b","modified":1640657930878},{"_id":"themes/maupassant/languages/es-ES.yml","hash":"62a893d68e2ee3bcee0a937a8c75afa44b09997f","modified":1640657935711},{"_id":"themes/maupassant/languages/fr-FR.yml","hash":"816ce8b138b1e8e22fd6afd0e59205ee11acfa6c","modified":1640657937902},{"_id":"themes/maupassant/languages/ko.yml","hash":"6a52e4056b4de89aef513db7837f8bc51b8b0f7e","modified":1640657940622},{"_id":"themes/maupassant/languages/ru.yml","hash":"22704ff0d4f0778237bc24b094fd2ba14f273996","modified":1640657943317},{"_id":"themes/maupassant/languages/zh-CN.yml","hash":"540be926bd68106740eabc004663365f39f6c34d","modified":1640657946517},{"_id":"themes/maupassant/languages/zh-TW.yml","hash":"5e56f5bd21f295fce751b8f86ccbbae21b8a03d4","modified":1640657952333},{"_id":"themes/maupassant/layout/archive.pug","hash":"749028e57a2eaad8c92ce2a2426c98605ab746a7","modified":1640656547341},{"_id":"themes/maupassant/layout/base-without-sidebar.pug","hash":"80995eadfd89ee9aa36f4672f8d405e03f13af15","modified":1640656547341},{"_id":"themes/maupassant/layout/base.pug","hash":"a226db456b92c9e8611a8bfda07818e6c3d13dd5","modified":1640656547341},{"_id":"themes/maupassant/layout/index.pug","hash":"162fe3fa695e8bea5a77916aefbb7ce98cd227bf","modified":1640656547342},{"_id":"themes/maupassant/layout/page.pug","hash":"a285a76950bb1b91f482ef9c473472bd0ede601d","modified":1640656547342},{"_id":"themes/maupassant/layout/post.pug","hash":"0e07e2df8c48fabde82290ed82827aba452c2cea","modified":1640657993437},{"_id":"themes/maupassant/layout/single-column.pug","hash":"0593f261dc208bb0b5c4232eb41eff597a291bd9","modified":1640656547342},{"_id":"themes/maupassant/layout/tagcloud.pug","hash":"4aa57b41e919a12b6d7691cd4a36d3a531b55fcb","modified":1640656547342},{"_id":"themes/maupassant/layout/timeline.pug","hash":"84fbfc92ccdf291b491140d89557553141a5d3f9","modified":1640656547342},{"_id":"themes/maupassant/layout/_partial/after_footer.pug","hash":"aefb67bac8fcef9cb3027f8622923b392f79f51e","modified":1640656547338},{"_id":"themes/maupassant/layout/_partial/comments.pug","hash":"ee41abc4fe1610293ef4958275c41c9423d68105","modified":1640656547338},{"_id":"themes/maupassant/layout/_partial/footer.pug","hash":"650781b5bc8c632658ad6880ba663b1e3bfb5798","modified":1640656547338},{"_id":"themes/maupassant/layout/_partial/head.pug","hash":"51881cde4653f00e9d0de68fb9c201b52b100b9e","modified":1640656547339},{"_id":"themes/maupassant/layout/_partial/helpers.pug","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1640656547339},{"_id":"themes/maupassant/layout/_partial/mathjax.pug","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1640656547339},{"_id":"themes/maupassant/layout/_partial/mathjax2.pug","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1640656547339},{"_id":"themes/maupassant/layout/_partial/paginator.pug","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1640656547339},{"_id":"themes/maupassant/layout/_partial/post_nav.pug","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1640656547339},{"_id":"themes/maupassant/layout/_partial/tag.pug","hash":"53d721ea4c93564cb0bdde065572ff6128574d36","modified":1640656547339},{"_id":"themes/maupassant/layout/_partial/totop.pug","hash":"8225bbc3cdb9648bc2e6872e5c616a9a1e4def4f","modified":1640656547340},{"_id":"themes/maupassant/layout/_partial/wordcount.pug","hash":"b3c846a2e0ac79933e32c343029b769f2865a27f","modified":1640656547340},{"_id":"themes/maupassant/layout/_widget/category.pug","hash":"7c6aed762934ca51aa2669b886254da24b77bc14","modified":1640656547340},{"_id":"themes/maupassant/layout/_widget/copyright.pug","hash":"32701dcba9c52d4bc73badaf8afe91af3f87b6a0","modified":1640656547340},{"_id":"themes/maupassant/layout/_widget/donate.pug","hash":"50855ce17af4298ce0f15236e2308c4a1760e7e3","modified":1640656547340},{"_id":"themes/maupassant/layout/_widget/recent_posts.pug","hash":"19431336d724d2118e46da43683bce9063176541","modified":1640656547341},{"_id":"themes/maupassant/layout/_widget/links.pug","hash":"c45aa7ec00158579e58f1f8dfd890447bb5e5e54","modified":1640656547340},{"_id":"themes/maupassant/layout/_widget/recent_comments.pug","hash":"1ef7a333ab9bfa169276d0ad48aecf5166ab63cb","modified":1640656547341},{"_id":"themes/maupassant/layout/_widget/search.pug","hash":"6e8e4123cca38840c4607c1a056205972b82bb7b","modified":1640656547341},{"_id":"themes/maupassant/layout/_widget/tag.pug","hash":"132f049ce677d0e38f50073174c4ee4b825d4a06","modified":1640656547341},{"_id":"themes/maupassant/source/css/copycode.css","hash":"e2463b8dacf629e180a1b6cd80667ca8044292eb","modified":1640656547343},{"_id":"themes/maupassant/source/css/copyright.css","hash":"a418da11a88d1feb14500df42ed97a64da6a7611","modified":1640656547343},{"_id":"themes/maupassant/source/css/dark.css","hash":"0faf42a84e243032b736c5f06ddbb95ac69e779c","modified":1640656547343},{"_id":"themes/maupassant/source/css/donate.css","hash":"95b2fd65042afecc0b5530847c369bcc11d74bd0","modified":1640656547343},{"_id":"themes/maupassant/source/css/search.css","hash":"9406e138d7bb6a9ef4a067eba1dafa627519c8a7","modified":1640656547343},{"_id":"themes/maupassant/source/img/alipay.svg","hash":"3d94d2f9b09e352802628c9225578e1086f5fef3","modified":1640656547344},{"_id":"themes/maupassant/source/css/style.scss","hash":"2435d3536b35a259e3eaca850292c1aa48cc8673","modified":1640656547344},{"_id":"themes/maupassant/source/img/bitcoin.svg","hash":"590b6b6462896168d08b30dfe2de5f08950d5553","modified":1640656547344},{"_id":"themes/maupassant/source/img/github.svg","hash":"277798d16cb6106e45ef74f6b9972011fa43401b","modified":1640656547345},{"_id":"themes/maupassant/source/img/like.svg","hash":"e6e4bd1af076be9358316cac89efdc22ef4a5064","modified":1640656547345},{"_id":"themes/maupassant/source/img/paypal.svg","hash":"09786c983a10bc570dcd05b87cec601e9d01eb00","modified":1640656547345},{"_id":"themes/maupassant/source/img/wechat.svg","hash":"19c1f68ec8c0b8e9f7855e7a6e78077f70a1aedc","modified":1640656547345},{"_id":"themes/maupassant/source/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1640656547346},{"_id":"themes/maupassant/source/js/copycode.js","hash":"fde1f153bab1f00ae8930668094c00aa9ff3c7a3","modified":1640656547346},{"_id":"themes/maupassant/source/js/copyright.js","hash":"7b1bd775ea22abf33d57f78628f436bf656e439a","modified":1640656547346},{"_id":"themes/maupassant/source/js/donate.js","hash":"bdddd8d9847462d020f7a511e7e12c046223195d","modified":1640656547346},{"_id":"themes/maupassant/source/js/love.js","hash":"5cf89f622bf891cf1986845eb92eadef6f358eb7","modified":1640656547347},{"_id":"themes/maupassant/source/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1640656547346},{"_id":"themes/maupassant/source/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1640656547347},{"_id":"themes/maupassant/source/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1640656547347},{"_id":"themes/maupassant/source/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1640656547347},{"_id":"themes/maupassant/source/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1640656547347},{"_id":"source/_posts/Composition API 异步问题.md","hash":"4fc3efb3eadf511f2fa89ed1c7aff81b45d9c936","modified":1640657183147},{"_id":"source/_posts/ES2022 feature: class static initialization blocks.md","hash":"5fc9b2c83f25d2734ebfc7d4498af13975ba58c0","modified":1640657590121},{"_id":"source/_posts/JAVA 数据结构.md","hash":"f73f9ad7a5a7686eb0e798dec9decea3d0e117df","modified":1640657624787},{"_id":"source/_posts/Node 架构.md","hash":"06ef920f1fc33ccda16e823e5da1d9732b5c1657","modified":1640657338992},{"_id":"source/_posts/Node 模块加载.md","hash":"4e237ec1a3a21e00ae31a6eef604855b5c1e8e02","modified":1640657360808},{"_id":"source/_posts/Nuxt 源码体悟.md","hash":"9b94d475a7963b685818651464ae3c614b21ed43","modified":1640657205440},{"_id":"source/_posts/Nuxt3.md","hash":"e3fe8196864aac661539c74bc93ca5c10e49d138","modified":1640657226015},{"_id":"source/_posts/React hooks 梳理.md","hash":"546fec6ae2a1df4e8129bbeffadd2b554e01aad9","modified":1640657296290},{"_id":"source/_posts/Rxjs.md","hash":"94240d85189d295ea2fe19a2f3d8092ec4e84e60","modified":1640657020654},{"_id":"source/_posts/ServiceWorker.md","hash":"1e1241c7ba9c605b57352233af4f07613d04fb76","modified":1640657703757},{"_id":"source/_posts/TypeScript 使用.md","hash":"d606a3e33193453e1e32d329c75a31fdb8379bfa","modified":1640657130964},{"_id":"source/_posts/Vue-Loader Hot Reload.md","hash":"e531628e4e66ec1da2f102fd3f18fbcf950eae36","modified":1640657269920},{"_id":"source/_posts/css.md","hash":"7d6882e66221f8d2dcde07e5bcee33b42d90bb81","modified":1640657107528},{"_id":"source/_posts/Webpack Chunk.md","hash":"b4e4ad1d8c59b27ea5d44bbbcf2b686edf2efe22","modified":1640657452277},{"_id":"source/_posts/http2.md","hash":"6617456537c5b408a9aec327e9246845321d2cd4","modified":1640657844579},{"_id":"source/_posts/proxy_set_header.md","hash":"a3f144141ec23ee982ca022b3d52179f131a0712","modified":1640657424511},{"_id":"source/_posts/rpc.md","hash":"8e40a209abfc833eeab3bef926b8edd784520b2d","modified":1640657382468},{"_id":"source/_posts/单例 Node.js 可以处理多少请求.md","hash":"5bc95fdfc1937280a296564190e63c40094f6fb5","modified":1640657319859},{"_id":"source/_posts/高效软件开发人员的 12 个习惯.md","hash":"9aa925b905ac9b98332103e65e3e0492bec1a07b","modified":1640657571057},{"_id":"source/about/index.md","hash":"4951826203f69a55a832c988e91c7208e84aac64","modified":1640659421089},{"_id":"public/about/index.html","hash":"07f61a53046a7dd178123fb5034f4141a12ca794","modified":1640659730257},{"_id":"public/2021/12/21/ServiceWorker/index.html","hash":"2ff70aed018220bc29ba3d306e054c85a92d2622","modified":1640659730257},{"_id":"public/2021/12/17/http2/index.html","hash":"38f7a4f35aee526407da164359bfd1b132f1cd08","modified":1640659730257},{"_id":"public/2021/09/08/JAVA 数据结构/index.html","hash":"b5824e5f4a2b1fa9106031f06bea1ef75744a8a1","modified":1640659730257},{"_id":"public/2021/09/07/proxy_set_header/index.html","hash":"9398799cf313d4fe3d552ca4e06e5476dbf3331d","modified":1640659730257},{"_id":"public/2021/07/21/React hooks 梳理/index.html","hash":"3ba35b8f6d3953c0d2abc6ab4a0838fc06bde58b","modified":1640659730257},{"_id":"public/2021/07/02/Node 模块加载/index.html","hash":"82bb0d3953b3c11df9706654c86adeb0c51b2f4f","modified":1640659730257},{"_id":"public/2021/06/29/Node 架构/index.html","hash":"4e7739139e0b84051c0199560ee0e6b85c55e9e1","modified":1640659730257},{"_id":"public/2021/06/02/css/index.html","hash":"a2f83d70f0ccaff37dcf308fd97175d2230c69a3","modified":1640659730257},{"_id":"public/2021/05/28/Rxjs/index.html","hash":"a2eac5e08d2a005e0d18b443cde86d7442646abd","modified":1640659730257},{"_id":"public/2021/05/28/Vue-Loader Hot Reload/index.html","hash":"7bf6894a4f00e3d7b8ac6dd77b81565049a00142","modified":1640659730257},{"_id":"public/2021/05/28/Webpack Chunk/index.html","hash":"4d9cc81033bdbc5e5308c8b4aca0b5807036c564","modified":1640659730257},{"_id":"public/archives/page/2/index.html","hash":"d6bcf7095a54a901b3955228c5d9874ca228d8da","modified":1640659730257},{"_id":"public/archives/index.html","hash":"869fa70b563af0fe35d66faea59ee0c5cf996847","modified":1640659730257},{"_id":"public/archives/2021/index.html","hash":"1143b62f802545199f552d428d002df5ce79de6f","modified":1640659730257},{"_id":"public/archives/2021/page/2/index.html","hash":"a6f9c48d9785c34f03c52e6d75157e0e51c3d4a6","modified":1640659730257},{"_id":"public/archives/2021/05/index.html","hash":"ce6b62a79b4d5b0bf22c4b27dfee64ec477070de","modified":1640659730257},{"_id":"public/archives/2021/06/index.html","hash":"4296a27babb5eaa162a1c183b49a81d85d4b572c","modified":1640659730257},{"_id":"public/archives/2021/07/index.html","hash":"f3e4285208ac9a01d436fdb53cb8646b0240a30c","modified":1640659730257},{"_id":"public/archives/2021/08/index.html","hash":"f3e0d492d878bf3487f2a4011904d15bab075c32","modified":1640659730257},{"_id":"public/archives/2021/09/index.html","hash":"ed44b6258ed89ed5ac7f68bc0cb6d87b98b58355","modified":1640659730257},{"_id":"public/archives/2021/12/index.html","hash":"e409b465c2846043d482b6cf41264e7b04c3b342","modified":1640659730257},{"_id":"public/index.html","hash":"8838cb1acc11aef6472e756cf4aaf9f5b71db78d","modified":1640659730257},{"_id":"public/page/2/index.html","hash":"ac53bb7353a9f5d4beb9e05d83f53b31c6e8959c","modified":1640659730257},{"_id":"public/tags/vue/index.html","hash":"09cbdf190c5d9d79a8e1db3765eedb2580c10ab6","modified":1640659730257},{"_id":"public/tags/趣味杂谈/index.html","hash":"5c8f0d6c53f91f7d058cfd2179aef9e74ab8131b","modified":1640659730257},{"_id":"public/tags/java/index.html","hash":"d2b10da02e4fe2ee93bc473341efdb0472a08f8f","modified":1640659730257},{"_id":"public/tags/node/index.html","hash":"4f6e6334d7c4216f5c83fc897afb9ee237a9cd3f","modified":1640659730257},{"_id":"public/tags/react/index.html","hash":"74f4553021664bbfcc16230e44e3a442936a2e06","modified":1640659730257},{"_id":"public/tags/js/index.html","hash":"c13a26ddcdff28680b673f6bc5702429b72f82b5","modified":1640659730257},{"_id":"public/tags/性能优化/index.html","hash":"60ce4d5744ccc1434f6b106e148a5706dbdced14","modified":1640659730257},{"_id":"public/tags/css/index.html","hash":"71869b8aa1c98fbc39effeccc338c55638149263","modified":1640659730257},{"_id":"public/tags/浏览器/index.html","hash":"c37e793d27de907bfd809274546e81a0e8d74b51","modified":1640659730257},{"_id":"public/tags/运维/index.html","hash":"dac86e4fc01b525b4662d6fa8e3e534335f538c7","modified":1640659730257},{"_id":"public/2021/12/12/rpc/index.html","hash":"634cb500b11b236beec921142da506d731d0f740","modified":1640659730257},{"_id":"public/2021/12/09/Nuxt3/index.html","hash":"60216914ba3d6bd4d003e318f4b152a25f37023f","modified":1640659730257},{"_id":"public/2021/09/17/ES2022 feature: class static initialization blocks/index.html","hash":"fbcf54b4a3fa8e619b4647b3c4e2b5d0b79669db","modified":1640659730257},{"_id":"public/2021/08/03/单例 Node.js 可以处理多少请求/index.html","hash":"6db37df37993f6d179d756c6a1643d602ba7c1c0","modified":1640659730257},{"_id":"public/2021/08/02/高效软件开发人员的 12 个习惯/index.html","hash":"6360745c20d64f915e6b87174aa3b1b7c15640fb","modified":1640659730257},{"_id":"public/2021/07/29/Composition API 异步问题/index.html","hash":"accbb9b2b587e48e4cd35e5fa18b627ac69eb858","modified":1640659730257},{"_id":"public/2021/07/13/TypeScript 使用/index.html","hash":"6ade194afbf11aa60d94a7dfaade23992bac4c18","modified":1640659730257},{"_id":"public/2021/05/28/Nuxt 源码体悟/index.html","hash":"9860900896a71082bfb52fe227552d4c39421c2a","modified":1640659730257},{"_id":"public/img/alipay.svg","hash":"3d94d2f9b09e352802628c9225578e1086f5fef3","modified":1640659730257},{"_id":"public/img/bitcoin.svg","hash":"590b6b6462896168d08b30dfe2de5f08950d5553","modified":1640659730257},{"_id":"public/img/github.svg","hash":"277798d16cb6106e45ef74f6b9972011fa43401b","modified":1640659730257},{"_id":"public/img/like.svg","hash":"e6e4bd1af076be9358316cac89efdc22ef4a5064","modified":1640659730257},{"_id":"public/img/paypal.svg","hash":"09786c983a10bc570dcd05b87cec601e9d01eb00","modified":1640659730257},{"_id":"public/img/wechat.svg","hash":"19c1f68ec8c0b8e9f7855e7a6e78077f70a1aedc","modified":1640659730257},{"_id":"public/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1640659730257},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1640659730257},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1640659730257},{"_id":"public/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1640659730257},{"_id":"public/css/copycode.css","hash":"e2463b8dacf629e180a1b6cd80667ca8044292eb","modified":1640659730257},{"_id":"public/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1640659730257},{"_id":"public/fancybox/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1640659730257},{"_id":"public/css/dark.css","hash":"0faf42a84e243032b736c5f06ddbb95ac69e779c","modified":1640659730257},{"_id":"public/css/copyright.css","hash":"a418da11a88d1feb14500df42ed97a64da6a7611","modified":1640659730257},{"_id":"public/css/donate.css","hash":"95b2fd65042afecc0b5530847c369bcc11d74bd0","modified":1640659730257},{"_id":"public/css/search.css","hash":"9406e138d7bb6a9ef4a067eba1dafa627519c8a7","modified":1640659730257},{"_id":"public/js/codeblock-resizer.js","hash":"5d0b786d60bf225d9eabcc9cece2719ff4d9b6cd","modified":1640659730257},{"_id":"public/js/copycode.js","hash":"fde1f153bab1f00ae8930668094c00aa9ff3c7a3","modified":1640659730257},{"_id":"public/js/copyright.js","hash":"7b1bd775ea22abf33d57f78628f436bf656e439a","modified":1640659730257},{"_id":"public/js/donate.js","hash":"bdddd8d9847462d020f7a511e7e12c046223195d","modified":1640659730257},{"_id":"public/js/fancybox.js","hash":"13c4781570339f4fba76a3d7f202e442817dd605","modified":1640659730257},{"_id":"public/js/love.js","hash":"5cf89f622bf891cf1986845eb92eadef6f358eb7","modified":1640659730257},{"_id":"public/js/share.js","hash":"a2f9de374523dc7f2ddb90ed5f24b668c20d9272","modified":1640659730257},{"_id":"public/js/smartresize.js","hash":"3ef157fd877167e3290f42c67a624ea375a46c24","modified":1640659730257},{"_id":"public/js/totop.js","hash":"7dbf8fcf582a4fb6eb9b2c60d6de9f9c2091ec4c","modified":1640659730257},{"_id":"public/js/search.js","hash":"0c0630e2ef213701d393b041f10572e951a27985","modified":1640659730257},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1640659730257},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1640659730257},{"_id":"public/css/style.css","hash":"b62c7a610e82d973f8363daabf77cdd878323fa2","modified":1640659730257},{"_id":"public/fancybox/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1640659730257},{"_id":"public/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1640659730257},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1640659730257}],"Category":[],"Data":[],"Page":[{"_content":"![image-20211228104304838](https://tva1.sinaimg.cn/large/008i3skNly1gxtcnt96d8j31am0pmju7.jpg)","source":"about/index.md","raw":"![image-20211228104304838](https://tva1.sinaimg.cn/large/008i3skNly1gxtcnt96d8j31am0pmju7.jpg)","date":"2021-12-28T02:43:41.089Z","updated":"2021-12-28T02:43:41.089Z","path":"about/index.html","_id":"ckxpi79790000efp7ef8d5b7p","title":"","comments":1,"layout":"page","content":"<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxtcnt96d8j31am0pmju7.jpg\" alt=\"image-20211228104304838\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxtcnt96d8j31am0pmju7.jpg\" alt=\"image-20211228104304838\"></p>\n"}],"Post":[{"title":"Composition API 异步问题","_content":"\n# Composition API 异步问题\n\n> 原文： https://antfu.me/posts/async-with-composition-api\n\n在 Vue Composition API 中使用异步函数时有一个主要警告，我相信你们很多人都遇到过。接下来我整理可能的解决方案的同时进行详细说明。\n\n- 问题\n- 原理\n- 局限性\n- 解决办法\n\n## 问题\n当使用异步 `step()` 的时候，你必须在第一个 await 语句之前使用`effects`和`lifecycle hooks`挂钩。\n\n示例代码：\n```javascript\nimport { ref, watch, onMounted, onUnmounted } from 'vue';\nexport default defineAsyncComponent({\n    async step() {\n        const counter = ref(0);\n        watch(counter, () => console.log(counter.value))\n        // OK!\n        onMounted(() => console.log('Mounted'))\n        // the await statement\n        await someAsyncFunction() // <-----------\n        // does NOT work!\n        onUnmounted(() => console.log('Unmounted'))\n        // 依旧工作，但是不自动处理\n        // 在组件destory之后，造成内存泄漏\n        watch(counter, () => console.log(counter.value * 2))\n    }\n})\n```\n在 await 语句之后, 以下功能将受到限制（不能自动处理）：\n\n- watch / watchEffect\n- computed\n- effect\n\n下面的 functions 将不能工作：\n\n- onMounted / onUnmounted / onXXX\n- provide / inject\n- getCurrentInstance\n\n## 原理\n让我们以 `onMounted` API 作为例子，众所周知，`onMounted` 当前组件加载的时候，是一个注册监听者的一个hook。注意 `onMounted` 是一个全局的API。你可以在任何地方调用他。没有局部上下文限制。\n\n举例：\n```javascript\n// local: `onMounted` is a method of `component` that bound to it\ncomponent.onMounted(/* ... */)\n\n// global: `onMounted` can be called without context\nonMounted(/* ... */)\n```\n\n那么，`onMounted` 是如何知道组件已经加载完成的呢？\n\nVue 采用了一种有趣的方法来解决这个问题。它使用一个内部变量来记录当前的组件实例。Vue 挂载组件时，它将实例存储在一个全局变量中，当在 setup 函数中调用钩子时，它将使用全局变量来获取当前组件实例。\n\n```javascript\nlet currentInstance = null\n\nexport function mountComponent(component) {\n  const instance = createComponent(component)\n\n  // hold the previous instance\n  const prev = currentInstance\n\n  // set the instance to global\n  currentInstance = instance\n\n  // hooks called inside the `setup()` will have\n  // the `currentInstance` as the context\n  component.setup() \n\n  // restore the previous instance\n  currentInstance = prev \n}\n```\n一个简单的 `onMounted` 实现如下：\n```javascript\n// (pseudo code)\nexport function onMounted(fn) {\n  if (!currentInstance) {\n    warn(`\"onMounted\" can't be called outside of component setup()`)\n    return\n  }\n\n  // bound listener to the current instance\n  currentInstance.onMounted(fn)\n}\n```\n通过上述的方法，只要 `onMounted` 在components内部`step()`方法中调用，它将能够获取当前组件的实例。\n\n## 局限性\n到目前为止一切顺利，但是异步函数有什么问题？\n\nJavaScript 是单线程的。单线程确保以下语句将彼此相邻执行。换句话说，没有人会意外地同时修改 currentInstance。举例如下:\n```javascript\ncurrentInstance = instance\ncomponent.setup() \ncurrentInstance = prev \n```\n但是当你 setup() 异步时情况发生变化，每当你 await一个promise的时候，你可以认为引擎在这里暂停工作并去做另一项任务。在这个时间段内，多个组件的创建将不可预测地改变全局变量并最终变得一团糟。举例如下：\n```javascript\ncurrentInstance = instance\nawait component.setup() // atomic lost\ncurrentInstance = prev \n```\n如果我们不使用await来检查实例，调用setup()函数会使它在第一条await语句之前完成任务，只要await语句解析完成，剩下的就会执行.\n```javascript\nasync function setup() {\n  console.log(1)\n  await someAsyncFunction()\n  console.log(2)\n}\n\nconsole.log(3)\nsetup()\nconsole.log(4)\n// 3 - 1 - 4 - 2;\n```\n这意味着，Vue 无法知道何时会从外部调用异步部分，因此也无法将实例绑定到上下文。\n\n## 解决办法\n\n这实际上是 JavaScript 本身的一个限制，除非我们有一些新的提议在语言层面打开大门，否则我们必须接受它。但是为了解决这个问题，我收集了一些解决方案供您根据需要进行选择。\n\n### 1. 开发时有效提醒\n\n当然，这是一个明显的“解决方案”。您可以尝试在第一个 await 语句之前移动您的效果和钩子，并小心记住不要在此之后再次使用它们。幸运的是，如果您使用 ESLint，您可以启用 eslint-plugin-vue 中的 vue/no-watch-after-await 和 vue/no-lifecycle-after-await 规则，以便在您犯一些错误时发出警告。\n\n### 2. 将异步函数包装为同步\n在某些情况下，您的逻辑可能依赖于异步获取的数据。\n```javascript\nconst data = await fetch('https://api.github.com/').then(r => r.json())\nconst user = data.user\n```\n```javascript\nconst data = ref(null)\nfetch('https://api.github.com/')\n  .then(r => r.json())\n  .then(res => data.value = res)\nconst user = computed(() => data?.user)\n```\n这种方法首先解决逻辑之间的“连接”，然后在异步函数得到解决并填充数据时进行反应更新。\n### 3. 显式绑定实例\n生命周期钩子实际上接受第二个参数来显式设置实例。但是，缺点是此解决方案不适用于 watch/watchEffect/computed/provide/inject，因为它们不接受实例参数。\n```javascript\nexport default defineAsyncComponent({\n  async setup() {\n    // get and hold the instance before `await`\n    const instance = getCurrentInstance()\n\n    await someAsyncFunction() // <-----------\n\n    onUnmounted(\n      () => console.log('Unmounted'),\n      instance // <--- pass the instance to it\n    )\n  }\n})\n```\n要获得效果，您可以在即将发布的 Vue 中使用 effectScope API.\n```javascript\nimport { effectScope } from 'vue'\n\nexport default defineAsyncComponent({\n  async setup() {\n    // create the scope before `await`, so it will be bond to the instance\n    const scope = effectScope()\n\n    const data = await someAsyncFunction() // <-----------\n\n    scope.run(() => {\n      /* Use `computed`, `watch`, etc. ... */\n    })\n\n    // the lifecycle hooks will not be available here,\n    // you will need to combine it with the previous snippet\n    // to have both lifecycle hooks and effects works.\n  }\n})\n```\n\n### 4. 编译时魔法\n\n在最近的 `<script setup>` 提案更新中，引入了新的编译时魔法。它的工作方式是在每个 await 语句之后注入一个脚本来恢复当前实例状态。\n\n```javascript\n<script setup>\nconst post = await fetch(`/api/post/1`).then((r) => r.json())\n</script>\n```\n```javascript\nimport { withAsyncContext } from 'vue'\n\nexport default {\n  async setup() {\n    let __temp, __restore\n\n    const post =\n      (([__temp, __restore] = withAsyncContext(() =>\n        fetch(`/api/post/1`).then((r) => r.json())\n      )),\n      (__temp = await __temp),\n      __restore(),\n      __temp)\n\n    // current instance context preserved\n    // e.g. onMounted() will still work.\n\n    return { post }\n  }\n}\n```\n有了它，异步函数将在与 `<script setup>` 一起使用时才起作用。唯一的遗憾是它在 `<script setup>` 之外不起作用。","source":"_posts/Composition API 异步问题.md","raw":"---\ntitle: Composition API 异步问题\ntags: vue\n---\n\n# Composition API 异步问题\n\n> 原文： https://antfu.me/posts/async-with-composition-api\n\n在 Vue Composition API 中使用异步函数时有一个主要警告，我相信你们很多人都遇到过。接下来我整理可能的解决方案的同时进行详细说明。\n\n- 问题\n- 原理\n- 局限性\n- 解决办法\n\n## 问题\n当使用异步 `step()` 的时候，你必须在第一个 await 语句之前使用`effects`和`lifecycle hooks`挂钩。\n\n示例代码：\n```javascript\nimport { ref, watch, onMounted, onUnmounted } from 'vue';\nexport default defineAsyncComponent({\n    async step() {\n        const counter = ref(0);\n        watch(counter, () => console.log(counter.value))\n        // OK!\n        onMounted(() => console.log('Mounted'))\n        // the await statement\n        await someAsyncFunction() // <-----------\n        // does NOT work!\n        onUnmounted(() => console.log('Unmounted'))\n        // 依旧工作，但是不自动处理\n        // 在组件destory之后，造成内存泄漏\n        watch(counter, () => console.log(counter.value * 2))\n    }\n})\n```\n在 await 语句之后, 以下功能将受到限制（不能自动处理）：\n\n- watch / watchEffect\n- computed\n- effect\n\n下面的 functions 将不能工作：\n\n- onMounted / onUnmounted / onXXX\n- provide / inject\n- getCurrentInstance\n\n## 原理\n让我们以 `onMounted` API 作为例子，众所周知，`onMounted` 当前组件加载的时候，是一个注册监听者的一个hook。注意 `onMounted` 是一个全局的API。你可以在任何地方调用他。没有局部上下文限制。\n\n举例：\n```javascript\n// local: `onMounted` is a method of `component` that bound to it\ncomponent.onMounted(/* ... */)\n\n// global: `onMounted` can be called without context\nonMounted(/* ... */)\n```\n\n那么，`onMounted` 是如何知道组件已经加载完成的呢？\n\nVue 采用了一种有趣的方法来解决这个问题。它使用一个内部变量来记录当前的组件实例。Vue 挂载组件时，它将实例存储在一个全局变量中，当在 setup 函数中调用钩子时，它将使用全局变量来获取当前组件实例。\n\n```javascript\nlet currentInstance = null\n\nexport function mountComponent(component) {\n  const instance = createComponent(component)\n\n  // hold the previous instance\n  const prev = currentInstance\n\n  // set the instance to global\n  currentInstance = instance\n\n  // hooks called inside the `setup()` will have\n  // the `currentInstance` as the context\n  component.setup() \n\n  // restore the previous instance\n  currentInstance = prev \n}\n```\n一个简单的 `onMounted` 实现如下：\n```javascript\n// (pseudo code)\nexport function onMounted(fn) {\n  if (!currentInstance) {\n    warn(`\"onMounted\" can't be called outside of component setup()`)\n    return\n  }\n\n  // bound listener to the current instance\n  currentInstance.onMounted(fn)\n}\n```\n通过上述的方法，只要 `onMounted` 在components内部`step()`方法中调用，它将能够获取当前组件的实例。\n\n## 局限性\n到目前为止一切顺利，但是异步函数有什么问题？\n\nJavaScript 是单线程的。单线程确保以下语句将彼此相邻执行。换句话说，没有人会意外地同时修改 currentInstance。举例如下:\n```javascript\ncurrentInstance = instance\ncomponent.setup() \ncurrentInstance = prev \n```\n但是当你 setup() 异步时情况发生变化，每当你 await一个promise的时候，你可以认为引擎在这里暂停工作并去做另一项任务。在这个时间段内，多个组件的创建将不可预测地改变全局变量并最终变得一团糟。举例如下：\n```javascript\ncurrentInstance = instance\nawait component.setup() // atomic lost\ncurrentInstance = prev \n```\n如果我们不使用await来检查实例，调用setup()函数会使它在第一条await语句之前完成任务，只要await语句解析完成，剩下的就会执行.\n```javascript\nasync function setup() {\n  console.log(1)\n  await someAsyncFunction()\n  console.log(2)\n}\n\nconsole.log(3)\nsetup()\nconsole.log(4)\n// 3 - 1 - 4 - 2;\n```\n这意味着，Vue 无法知道何时会从外部调用异步部分，因此也无法将实例绑定到上下文。\n\n## 解决办法\n\n这实际上是 JavaScript 本身的一个限制，除非我们有一些新的提议在语言层面打开大门，否则我们必须接受它。但是为了解决这个问题，我收集了一些解决方案供您根据需要进行选择。\n\n### 1. 开发时有效提醒\n\n当然，这是一个明显的“解决方案”。您可以尝试在第一个 await 语句之前移动您的效果和钩子，并小心记住不要在此之后再次使用它们。幸运的是，如果您使用 ESLint，您可以启用 eslint-plugin-vue 中的 vue/no-watch-after-await 和 vue/no-lifecycle-after-await 规则，以便在您犯一些错误时发出警告。\n\n### 2. 将异步函数包装为同步\n在某些情况下，您的逻辑可能依赖于异步获取的数据。\n```javascript\nconst data = await fetch('https://api.github.com/').then(r => r.json())\nconst user = data.user\n```\n```javascript\nconst data = ref(null)\nfetch('https://api.github.com/')\n  .then(r => r.json())\n  .then(res => data.value = res)\nconst user = computed(() => data?.user)\n```\n这种方法首先解决逻辑之间的“连接”，然后在异步函数得到解决并填充数据时进行反应更新。\n### 3. 显式绑定实例\n生命周期钩子实际上接受第二个参数来显式设置实例。但是，缺点是此解决方案不适用于 watch/watchEffect/computed/provide/inject，因为它们不接受实例参数。\n```javascript\nexport default defineAsyncComponent({\n  async setup() {\n    // get and hold the instance before `await`\n    const instance = getCurrentInstance()\n\n    await someAsyncFunction() // <-----------\n\n    onUnmounted(\n      () => console.log('Unmounted'),\n      instance // <--- pass the instance to it\n    )\n  }\n})\n```\n要获得效果，您可以在即将发布的 Vue 中使用 effectScope API.\n```javascript\nimport { effectScope } from 'vue'\n\nexport default defineAsyncComponent({\n  async setup() {\n    // create the scope before `await`, so it will be bond to the instance\n    const scope = effectScope()\n\n    const data = await someAsyncFunction() // <-----------\n\n    scope.run(() => {\n      /* Use `computed`, `watch`, etc. ... */\n    })\n\n    // the lifecycle hooks will not be available here,\n    // you will need to combine it with the previous snippet\n    // to have both lifecycle hooks and effects works.\n  }\n})\n```\n\n### 4. 编译时魔法\n\n在最近的 `<script setup>` 提案更新中，引入了新的编译时魔法。它的工作方式是在每个 await 语句之后注入一个脚本来恢复当前实例状态。\n\n```javascript\n<script setup>\nconst post = await fetch(`/api/post/1`).then((r) => r.json())\n</script>\n```\n```javascript\nimport { withAsyncContext } from 'vue'\n\nexport default {\n  async setup() {\n    let __temp, __restore\n\n    const post =\n      (([__temp, __restore] = withAsyncContext(() =>\n        fetch(`/api/post/1`).then((r) => r.json())\n      )),\n      (__temp = await __temp),\n      __restore(),\n      __temp)\n\n    // current instance context preserved\n    // e.g. onMounted() will still work.\n\n    return { post }\n  }\n}\n```\n有了它，异步函数将在与 `<script setup>` 一起使用时才起作用。唯一的遗憾是它在 `<script setup>` 之外不起作用。","slug":"Composition API 异步问题","published":1,"date":"2021-07-29T01:56:35.668Z","updated":"2021-12-28T02:06:23.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxph7qm000001op7ebbpepd7","content":"<h1 id=\"Composition-API-异步问题\"><a href=\"#Composition-API-异步问题\" class=\"headerlink\" title=\"Composition API 异步问题\"></a>Composition API 异步问题</h1><blockquote>\n<p>原文： <a href=\"https://antfu.me/posts/async-with-composition-api\">https://antfu.me/posts/async-with-composition-api</a></p>\n</blockquote>\n<p>在 Vue Composition API 中使用异步函数时有一个主要警告，我相信你们很多人都遇到过。接下来我整理可能的解决方案的同时进行详细说明。</p>\n<ul>\n<li>问题</li>\n<li>原理</li>\n<li>局限性</li>\n<li>解决办法</li>\n</ul>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>当使用异步 <code>step()</code> 的时候，你必须在第一个 await 语句之前使用<code>effects</code>和<code>lifecycle hooks</code>挂钩。</p>\n<p>示例代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ref, watch, onMounted, onUnmounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> defineAsyncComponent(&#123;</span><br><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">step</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> counter = ref(<span class=\"number\">0</span>);</span><br><span class=\"line\">        watch(counter, <span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(counter.value))</span><br><span class=\"line\">        <span class=\"comment\">// OK!</span></span><br><span class=\"line\">        onMounted(<span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Mounted&#x27;</span>))</span><br><span class=\"line\">        <span class=\"comment\">// the await statement</span></span><br><span class=\"line\">        <span class=\"keyword\">await</span> someAsyncFunction() <span class=\"comment\">// &lt;-----------</span></span><br><span class=\"line\">        <span class=\"comment\">// does NOT work!</span></span><br><span class=\"line\">        onUnmounted(<span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Unmounted&#x27;</span>))</span><br><span class=\"line\">        <span class=\"comment\">// 依旧工作，但是不自动处理</span></span><br><span class=\"line\">        <span class=\"comment\">// 在组件destory之后，造成内存泄漏</span></span><br><span class=\"line\">        watch(counter, <span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(counter.value * <span class=\"number\">2</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在 await 语句之后, 以下功能将受到限制（不能自动处理）：</p>\n<ul>\n<li>watch / watchEffect</li>\n<li>computed</li>\n<li>effect</li>\n</ul>\n<p>下面的 functions 将不能工作：</p>\n<ul>\n<li>onMounted / onUnmounted / onXXX</li>\n<li>provide / inject</li>\n<li>getCurrentInstance</li>\n</ul>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>让我们以 <code>onMounted</code> API 作为例子，众所周知，<code>onMounted</code> 当前组件加载的时候，是一个注册监听者的一个hook。注意 <code>onMounted</code> 是一个全局的API。你可以在任何地方调用他。没有局部上下文限制。</p>\n<p>举例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// local: `onMounted` is a method of `component` that bound to it</span></span><br><span class=\"line\">component.onMounted(<span class=\"comment\">/* ... */</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// global: `onMounted` can be called without context</span></span><br><span class=\"line\">onMounted(<span class=\"comment\">/* ... */</span>)</span><br></pre></td></tr></table></figure>\n\n<p>那么，<code>onMounted</code> 是如何知道组件已经加载完成的呢？</p>\n<p>Vue 采用了一种有趣的方法来解决这个问题。它使用一个内部变量来记录当前的组件实例。Vue 挂载组件时，它将实例存储在一个全局变量中，当在 setup 函数中调用钩子时，它将使用全局变量来获取当前组件实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> currentInstance = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mountComponent</span>(<span class=\"params\">component</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> instance = createComponent(component)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// hold the previous instance</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> prev = currentInstance</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// set the instance to global</span></span><br><span class=\"line\">  currentInstance = instance</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// hooks called inside the `setup()` will have</span></span><br><span class=\"line\">  <span class=\"comment\">// the `currentInstance` as the context</span></span><br><span class=\"line\">  component.setup() </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// restore the previous instance</span></span><br><span class=\"line\">  currentInstance = prev </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个简单的 <code>onMounted</code> 实现如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (pseudo code)</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onMounted</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!currentInstance) &#123;</span><br><span class=\"line\">    warn(<span class=\"string\">`&quot;onMounted&quot; can&#x27;t be called outside of component setup()`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// bound listener to the current instance</span></span><br><span class=\"line\">  currentInstance.onMounted(fn)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上述的方法，只要 <code>onMounted</code> 在components内部<code>step()</code>方法中调用，它将能够获取当前组件的实例。</p>\n<h2 id=\"局限性\"><a href=\"#局限性\" class=\"headerlink\" title=\"局限性\"></a>局限性</h2><p>到目前为止一切顺利，但是异步函数有什么问题？</p>\n<p>JavaScript 是单线程的。单线程确保以下语句将彼此相邻执行。换句话说，没有人会意外地同时修改 currentInstance。举例如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">currentInstance = instance</span><br><span class=\"line\">component.setup() </span><br><span class=\"line\">currentInstance = prev </span><br></pre></td></tr></table></figure>\n<p>但是当你 setup() 异步时情况发生变化，每当你 await一个promise的时候，你可以认为引擎在这里暂停工作并去做另一项任务。在这个时间段内，多个组件的创建将不可预测地改变全局变量并最终变得一团糟。举例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">currentInstance = instance</span><br><span class=\"line\"><span class=\"keyword\">await</span> component.setup() <span class=\"comment\">// atomic lost</span></span><br><span class=\"line\">currentInstance = prev </span><br></pre></td></tr></table></figure>\n<p>如果我们不使用await来检查实例，调用setup()函数会使它在第一条await语句之前完成任务，只要await语句解析完成，剩下的就会执行.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setup</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> someAsyncFunction()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br><span class=\"line\">setup()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">// 3 - 1 - 4 - 2;</span></span><br></pre></td></tr></table></figure>\n<p>这意味着，Vue 无法知道何时会从外部调用异步部分，因此也无法将实例绑定到上下文。</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>这实际上是 JavaScript 本身的一个限制，除非我们有一些新的提议在语言层面打开大门，否则我们必须接受它。但是为了解决这个问题，我收集了一些解决方案供您根据需要进行选择。</p>\n<h3 id=\"1-开发时有效提醒\"><a href=\"#1-开发时有效提醒\" class=\"headerlink\" title=\"1. 开发时有效提醒\"></a>1. 开发时有效提醒</h3><p>当然，这是一个明显的“解决方案”。您可以尝试在第一个 await 语句之前移动您的效果和钩子，并小心记住不要在此之后再次使用它们。幸运的是，如果您使用 ESLint，您可以启用 eslint-plugin-vue 中的 vue/no-watch-after-await 和 vue/no-lifecycle-after-await 规则，以便在您犯一些错误时发出警告。</p>\n<h3 id=\"2-将异步函数包装为同步\"><a href=\"#2-将异步函数包装为同步\" class=\"headerlink\" title=\"2. 将异步函数包装为同步\"></a>2. 将异步函数包装为同步</h3><p>在某些情况下，您的逻辑可能依赖于异步获取的数据。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(<span class=\"string\">&#x27;https://api.github.com/&#x27;</span>).then(<span class=\"function\"><span class=\"params\">r</span> =&gt;</span> r.json())</span><br><span class=\"line\"><span class=\"keyword\">const</span> user = data.user</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = ref(<span class=\"literal\">null</span>)</span><br><span class=\"line\">fetch(<span class=\"string\">&#x27;https://api.github.com/&#x27;</span>)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">r</span> =&gt;</span> r.json())</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> data.value = res)</span><br><span class=\"line\"><span class=\"keyword\">const</span> user = computed(<span class=\"function\">() =&gt;</span> data?.user)</span><br></pre></td></tr></table></figure>\n<p>这种方法首先解决逻辑之间的“连接”，然后在异步函数得到解决并填充数据时进行反应更新。</p>\n<h3 id=\"3-显式绑定实例\"><a href=\"#3-显式绑定实例\" class=\"headerlink\" title=\"3. 显式绑定实例\"></a>3. 显式绑定实例</h3><p>生命周期钩子实际上接受第二个参数来显式设置实例。但是，缺点是此解决方案不适用于 watch/watchEffect/computed/provide/inject，因为它们不接受实例参数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> defineAsyncComponent(&#123;</span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">setup</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// get and hold the instance before `await`</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> instance = getCurrentInstance()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">await</span> someAsyncFunction() <span class=\"comment\">// &lt;-----------</span></span><br><span class=\"line\"></span><br><span class=\"line\">    onUnmounted(</span><br><span class=\"line\">      <span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Unmounted&#x27;</span>),</span><br><span class=\"line\">      instance <span class=\"comment\">// &lt;--- pass the instance to it</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>要获得效果，您可以在即将发布的 Vue 中使用 effectScope API.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; effectScope &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> defineAsyncComponent(&#123;</span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">setup</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// create the scope before `await`, so it will be bond to the instance</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> scope = effectScope()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> someAsyncFunction() <span class=\"comment\">// &lt;-----------</span></span><br><span class=\"line\"></span><br><span class=\"line\">    scope.run(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* Use `computed`, `watch`, etc. ... */</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// the lifecycle hooks will not be available here,</span></span><br><span class=\"line\">    <span class=\"comment\">// you will need to combine it with the previous snippet</span></span><br><span class=\"line\">    <span class=\"comment\">// to have both lifecycle hooks and effects works.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-编译时魔法\"><a href=\"#4-编译时魔法\" class=\"headerlink\" title=\"4. 编译时魔法\"></a>4. 编译时魔法</h3><p>在最近的 <code>&lt;script setup&gt;</code> 提案更新中，引入了新的编译时魔法。它的工作方式是在每个 await 语句之后注入一个脚本来恢复当前实例状态。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\"><span class=\"keyword\">const</span> post = <span class=\"keyword\">await</span> fetch(<span class=\"string\">`/api/post/1`</span>).then(<span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> r.json())</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; withAsyncContext &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">setup</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> __temp, __restore</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> post =</span><br><span class=\"line\">      (([__temp, __restore] = withAsyncContext(<span class=\"function\">() =&gt;</span></span><br><span class=\"line\">        fetch(<span class=\"string\">`/api/post/1`</span>).then(<span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> r.json())</span><br><span class=\"line\">      )),</span><br><span class=\"line\">      (__temp = <span class=\"keyword\">await</span> __temp),</span><br><span class=\"line\">      __restore(),</span><br><span class=\"line\">      __temp)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// current instance context preserved</span></span><br><span class=\"line\">    <span class=\"comment\">// e.g. onMounted() will still work.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; post &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有了它，异步函数将在与 <code>&lt;script setup&gt;</code> 一起使用时才起作用。唯一的遗憾是它在 <code>&lt;script setup&gt;</code> 之外不起作用。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Composition-API-异步问题\"><a href=\"#Composition-API-异步问题\" class=\"headerlink\" title=\"Composition API 异步问题\"></a>Composition API 异步问题</h1><blockquote>\n<p>原文： <a href=\"https://antfu.me/posts/async-with-composition-api\">https://antfu.me/posts/async-with-composition-api</a></p>\n</blockquote>\n<p>在 Vue Composition API 中使用异步函数时有一个主要警告，我相信你们很多人都遇到过。接下来我整理可能的解决方案的同时进行详细说明。</p>\n<ul>\n<li>问题</li>\n<li>原理</li>\n<li>局限性</li>\n<li>解决办法</li>\n</ul>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>当使用异步 <code>step()</code> 的时候，你必须在第一个 await 语句之前使用<code>effects</code>和<code>lifecycle hooks</code>挂钩。</p>\n<p>示例代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; ref, watch, onMounted, onUnmounted &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> defineAsyncComponent(&#123;</span><br><span class=\"line\">    <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">step</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> counter = ref(<span class=\"number\">0</span>);</span><br><span class=\"line\">        watch(counter, <span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(counter.value))</span><br><span class=\"line\">        <span class=\"comment\">// OK!</span></span><br><span class=\"line\">        onMounted(<span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Mounted&#x27;</span>))</span><br><span class=\"line\">        <span class=\"comment\">// the await statement</span></span><br><span class=\"line\">        <span class=\"keyword\">await</span> someAsyncFunction() <span class=\"comment\">// &lt;-----------</span></span><br><span class=\"line\">        <span class=\"comment\">// does NOT work!</span></span><br><span class=\"line\">        onUnmounted(<span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Unmounted&#x27;</span>))</span><br><span class=\"line\">        <span class=\"comment\">// 依旧工作，但是不自动处理</span></span><br><span class=\"line\">        <span class=\"comment\">// 在组件destory之后，造成内存泄漏</span></span><br><span class=\"line\">        watch(counter, <span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(counter.value * <span class=\"number\">2</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>在 await 语句之后, 以下功能将受到限制（不能自动处理）：</p>\n<ul>\n<li>watch / watchEffect</li>\n<li>computed</li>\n<li>effect</li>\n</ul>\n<p>下面的 functions 将不能工作：</p>\n<ul>\n<li>onMounted / onUnmounted / onXXX</li>\n<li>provide / inject</li>\n<li>getCurrentInstance</li>\n</ul>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><p>让我们以 <code>onMounted</code> API 作为例子，众所周知，<code>onMounted</code> 当前组件加载的时候，是一个注册监听者的一个hook。注意 <code>onMounted</code> 是一个全局的API。你可以在任何地方调用他。没有局部上下文限制。</p>\n<p>举例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// local: `onMounted` is a method of `component` that bound to it</span></span><br><span class=\"line\">component.onMounted(<span class=\"comment\">/* ... */</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// global: `onMounted` can be called without context</span></span><br><span class=\"line\">onMounted(<span class=\"comment\">/* ... */</span>)</span><br></pre></td></tr></table></figure>\n\n<p>那么，<code>onMounted</code> 是如何知道组件已经加载完成的呢？</p>\n<p>Vue 采用了一种有趣的方法来解决这个问题。它使用一个内部变量来记录当前的组件实例。Vue 挂载组件时，它将实例存储在一个全局变量中，当在 setup 函数中调用钩子时，它将使用全局变量来获取当前组件实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> currentInstance = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mountComponent</span>(<span class=\"params\">component</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> instance = createComponent(component)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// hold the previous instance</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> prev = currentInstance</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// set the instance to global</span></span><br><span class=\"line\">  currentInstance = instance</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// hooks called inside the `setup()` will have</span></span><br><span class=\"line\">  <span class=\"comment\">// the `currentInstance` as the context</span></span><br><span class=\"line\">  component.setup() </span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// restore the previous instance</span></span><br><span class=\"line\">  currentInstance = prev </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>一个简单的 <code>onMounted</code> 实现如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (pseudo code)</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onMounted</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!currentInstance) &#123;</span><br><span class=\"line\">    warn(<span class=\"string\">`&quot;onMounted&quot; can&#x27;t be called outside of component setup()`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// bound listener to the current instance</span></span><br><span class=\"line\">  currentInstance.onMounted(fn)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>通过上述的方法，只要 <code>onMounted</code> 在components内部<code>step()</code>方法中调用，它将能够获取当前组件的实例。</p>\n<h2 id=\"局限性\"><a href=\"#局限性\" class=\"headerlink\" title=\"局限性\"></a>局限性</h2><p>到目前为止一切顺利，但是异步函数有什么问题？</p>\n<p>JavaScript 是单线程的。单线程确保以下语句将彼此相邻执行。换句话说，没有人会意外地同时修改 currentInstance。举例如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">currentInstance = instance</span><br><span class=\"line\">component.setup() </span><br><span class=\"line\">currentInstance = prev </span><br></pre></td></tr></table></figure>\n<p>但是当你 setup() 异步时情况发生变化，每当你 await一个promise的时候，你可以认为引擎在这里暂停工作并去做另一项任务。在这个时间段内，多个组件的创建将不可预测地改变全局变量并最终变得一团糟。举例如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">currentInstance = instance</span><br><span class=\"line\"><span class=\"keyword\">await</span> component.setup() <span class=\"comment\">// atomic lost</span></span><br><span class=\"line\">currentInstance = prev </span><br></pre></td></tr></table></figure>\n<p>如果我们不使用await来检查实例，调用setup()函数会使它在第一条await语句之前完成任务，只要await语句解析完成，剩下的就会执行.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setup</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">await</span> someAsyncFunction()</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>)</span><br><span class=\"line\">setup()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\">// 3 - 1 - 4 - 2;</span></span><br></pre></td></tr></table></figure>\n<p>这意味着，Vue 无法知道何时会从外部调用异步部分，因此也无法将实例绑定到上下文。</p>\n<h2 id=\"解决办法\"><a href=\"#解决办法\" class=\"headerlink\" title=\"解决办法\"></a>解决办法</h2><p>这实际上是 JavaScript 本身的一个限制，除非我们有一些新的提议在语言层面打开大门，否则我们必须接受它。但是为了解决这个问题，我收集了一些解决方案供您根据需要进行选择。</p>\n<h3 id=\"1-开发时有效提醒\"><a href=\"#1-开发时有效提醒\" class=\"headerlink\" title=\"1. 开发时有效提醒\"></a>1. 开发时有效提醒</h3><p>当然，这是一个明显的“解决方案”。您可以尝试在第一个 await 语句之前移动您的效果和钩子，并小心记住不要在此之后再次使用它们。幸运的是，如果您使用 ESLint，您可以启用 eslint-plugin-vue 中的 vue/no-watch-after-await 和 vue/no-lifecycle-after-await 规则，以便在您犯一些错误时发出警告。</p>\n<h3 id=\"2-将异步函数包装为同步\"><a href=\"#2-将异步函数包装为同步\" class=\"headerlink\" title=\"2. 将异步函数包装为同步\"></a>2. 将异步函数包装为同步</h3><p>在某些情况下，您的逻辑可能依赖于异步获取的数据。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> fetch(<span class=\"string\">&#x27;https://api.github.com/&#x27;</span>).then(<span class=\"function\"><span class=\"params\">r</span> =&gt;</span> r.json())</span><br><span class=\"line\"><span class=\"keyword\">const</span> user = data.user</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> data = ref(<span class=\"literal\">null</span>)</span><br><span class=\"line\">fetch(<span class=\"string\">&#x27;https://api.github.com/&#x27;</span>)</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">r</span> =&gt;</span> r.json())</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"params\">res</span> =&gt;</span> data.value = res)</span><br><span class=\"line\"><span class=\"keyword\">const</span> user = computed(<span class=\"function\">() =&gt;</span> data?.user)</span><br></pre></td></tr></table></figure>\n<p>这种方法首先解决逻辑之间的“连接”，然后在异步函数得到解决并填充数据时进行反应更新。</p>\n<h3 id=\"3-显式绑定实例\"><a href=\"#3-显式绑定实例\" class=\"headerlink\" title=\"3. 显式绑定实例\"></a>3. 显式绑定实例</h3><p>生命周期钩子实际上接受第二个参数来显式设置实例。但是，缺点是此解决方案不适用于 watch/watchEffect/computed/provide/inject，因为它们不接受实例参数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> defineAsyncComponent(&#123;</span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">setup</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// get and hold the instance before `await`</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> instance = getCurrentInstance()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">await</span> someAsyncFunction() <span class=\"comment\">// &lt;-----------</span></span><br><span class=\"line\"></span><br><span class=\"line\">    onUnmounted(</span><br><span class=\"line\">      <span class=\"function\">() =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;Unmounted&#x27;</span>),</span><br><span class=\"line\">      instance <span class=\"comment\">// &lt;--- pass the instance to it</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>要获得效果，您可以在即将发布的 Vue 中使用 effectScope API.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; effectScope &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> defineAsyncComponent(&#123;</span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">setup</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// create the scope before `await`, so it will be bond to the instance</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> scope = effectScope()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> someAsyncFunction() <span class=\"comment\">// &lt;-----------</span></span><br><span class=\"line\"></span><br><span class=\"line\">    scope.run(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* Use `computed`, `watch`, etc. ... */</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// the lifecycle hooks will not be available here,</span></span><br><span class=\"line\">    <span class=\"comment\">// you will need to combine it with the previous snippet</span></span><br><span class=\"line\">    <span class=\"comment\">// to have both lifecycle hooks and effects works.</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"4-编译时魔法\"><a href=\"#4-编译时魔法\" class=\"headerlink\" title=\"4. 编译时魔法\"></a>4. 编译时魔法</h3><p>在最近的 <code>&lt;script setup&gt;</code> 提案更新中，引入了新的编译时魔法。它的工作方式是在每个 await 语句之后注入一个脚本来恢复当前实例状态。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script setup&gt;</span><br><span class=\"line\"><span class=\"keyword\">const</span> post = <span class=\"keyword\">await</span> fetch(<span class=\"string\">`/api/post/1`</span>).then(<span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> r.json())</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; withAsyncContext &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;vue&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">setup</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> __temp, __restore</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">const</span> post =</span><br><span class=\"line\">      (([__temp, __restore] = withAsyncContext(<span class=\"function\">() =&gt;</span></span><br><span class=\"line\">        fetch(<span class=\"string\">`/api/post/1`</span>).then(<span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> r.json())</span><br><span class=\"line\">      )),</span><br><span class=\"line\">      (__temp = <span class=\"keyword\">await</span> __temp),</span><br><span class=\"line\">      __restore(),</span><br><span class=\"line\">      __temp)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// current instance context preserved</span></span><br><span class=\"line\">    <span class=\"comment\">// e.g. onMounted() will still work.</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; post &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有了它，异步函数将在与 <code>&lt;script setup&gt;</code> 一起使用时才起作用。唯一的遗憾是它在 <code>&lt;script setup&gt;</code> 之外不起作用。</p>\n"},{"title":"ES2022 feature class static initialization blocks","_content":"\n## ES2022 feature: class static initialization blocks\n\n\n\n### Introduction 简介\n\nRon Buckton 在 *ECMAScript* 规范中提出  [“Class static initialization blocks” ](https://github.com/tc39/proposal-class-static-block)已经进入到第四阶段，预计将写入2022年ECMAScript中。\n\n当我们创建Class类，通常我们可以有两种方式创建 constructs：\n\n*  Field: 创建（并可选择初始化）实例属性；\n* 构造函数Constructor：在设置完成之前执行的代码块。\n\n为了设置类的静态部分，我们只有静态字段。 ECMAScript 提案为类引入了**static initialization blocks** 。\n\n\n\n大致上，对于静态类来说，构造函数对于实例来说是一样的。\n\n\n\n### 目录\n\n* 为什么我们需要**static blocks**在class类中？\n* 一个更复杂的例子\n* 支持类静态块的引擎\n* JavaScript 是否变得很像 Java 和/或一团糟？\n* 结论\n\n\n\n#### 1. 为什么我们需要**static blocks**在class类中？\n\n为了方便外部函数调用内部属性，我们通常会这样设置：\n\n```javascript\nclass Translator {\n  static translations = {\n    yes: 'ja',\n    no: 'nein',\n    maybe: 'vielleicht',\n  };\n  static englishWords = extractEnglish(this.translations);\n  static germanWords = extractGerman(this.translations);\n}\nfunction extractEnglish(translations) {\n  return Object.keys(translations);\n}\nfunction extractGerman(translations) {\n  return Object.values(translations);\n}\n```\n\n在这种情况下，使用外部函数 extractEnglish() 和 extractGerman() 效果很好，因为我们可以看到它们是从**类内部调用的**，并且它们完全**独立于类**。但是，如果我们想同时设置两个静态字段，事情就会变得不那么优雅：\n\n```javascript\nclass Translator {\n  static translations = {\n    yes: 'ja',\n    no: 'nein',\n    maybe: 'vielleicht',\n  };\n  static englishWords = [];\n  static germanWords = [];\n  static _ = initializeTranslator( // (A)\n    this.translations, this.englishWords, this.germanWords);\n}\nfunction initializeTranslator(translations, englishWords, germanWords) {\n  for (const [english, german] of Object.entries(translations)) {\n    englishWords.push(english);\n    germanWords.push(german);\n  }\n}\n```\n\n这次有几个问题：\n\n* 调用 initializeTranslator() 是一个额外的步骤，必须在创建类之后在类之外执行。或者通过变通方法执行（A 行）。\n* initializeTranslator() 无权访问 Translator 的私有属性。\n\n当我们使用 **static initialization blocks**（A 行），我们有一个更优雅的解决方案。\n\n```javascript\nclass Translator {\n  static translations = {\n    yes: 'ja',\n    no: 'nein',\n    maybe: 'vielleicht',\n  };\n  static englishWords = [];\n  static germanWords = [];\n  static { // (A)\n    for (const [english, german] of Object.entries(this.translations)) {\n      this.englishWords.push(english);\n      this.germanWords.push(german);\n    }\n  }\n}\n```\n\n\n\n#### 2.一个更复杂的例子\n\n**static initialization blocks** 的细节是相对合乎逻辑的（相对于更复杂的实例成员规则）：\n\n* 每个类可以有多个静态块。\n* 静态块的执行与静态字段初始值设定项的执行交错执行。\n* 超类的静态成员在子类的静态成员之前执行。\n\n以下代码演示了这些规则：\n\n```javascript\nclass SuperClass {\n  static superField1 = console.log('superField1');\n  static {\n    assert.equal(this, SuperClass);\n    console.log('static block 1 SuperClass');\n  }\n  static superField2 = console.log('superField2');\n  static {\n    console.log('static block 2 SuperClass');\n  }\n}\n\nclass SubClass extends SuperClass {\n  static subField1 = console.log('subField1');\n  static {\n    assert.equal(this, SubClass);\n    console.log('static block 1 SubClass');\n  }\n  static subField2 = console.log('subField2');\n  static {\n    console.log('static block 2 SubClass');\n  }\n}\n\n// Output:\n// 'superField1'\n// 'static block 1 SuperClass'\n// 'superField2'\n// 'static block 2 SuperClass'\n// 'subField1'\n// 'static block 1 SubClass'\n// 'subField2'\n// 'static block 2 SubClass'\n```\n\n\n\n#### 3. 支持类静态块的引擎\n\n- V8: unflagged in v9.4.146 ([source](https://github.com/tc39/proposal-class-static-block#stage-4-entrance-criteria))\n- SpiderMonkey: behind a flag in v92, intent to ship unflagged in v93 ([source](https://github.com/tc39/proposal-class-static-block#stage-4-entrance-criteria))\n- TypeScript: v4.4 ([source](https://devblogs.microsoft.com/typescript/announcing-typescript-4-4-rc/))\n\n\n\n#### 4. JavaScript 是否变得很像 Java 和/或一团糟？\n\n这是一个小功能，不会与其他功能竞争。我们已经可以通过带有 ` static _ = ... ` 解决方法的运行。**static initialization blocks** 意味着不再需要这种解决方法。除此之外，类只是JavaScript程序员的众多工具之一。有些人使用它，有些人不使用，还有很多替代方法。即使是使用类的JavaScript代码也经常使用函数，并且趋向于轻量级。\n\n\n\n#### 5.结论\n\n**static initialization blocks** 是一个相对简单的特性，它完善了类的静态属性。粗略地说，它是实例构造函数的静态版本。当我们必须设置多个静态字段时，它可以发挥很大的作用。\n\n","source":"_posts/ES2022 feature: class static initialization blocks.md","raw":"---\ntitle: ES2022 feature class static initialization blocks\ntags: 趣味杂谈\n---\n\n## ES2022 feature: class static initialization blocks\n\n\n\n### Introduction 简介\n\nRon Buckton 在 *ECMAScript* 规范中提出  [“Class static initialization blocks” ](https://github.com/tc39/proposal-class-static-block)已经进入到第四阶段，预计将写入2022年ECMAScript中。\n\n当我们创建Class类，通常我们可以有两种方式创建 constructs：\n\n*  Field: 创建（并可选择初始化）实例属性；\n* 构造函数Constructor：在设置完成之前执行的代码块。\n\n为了设置类的静态部分，我们只有静态字段。 ECMAScript 提案为类引入了**static initialization blocks** 。\n\n\n\n大致上，对于静态类来说，构造函数对于实例来说是一样的。\n\n\n\n### 目录\n\n* 为什么我们需要**static blocks**在class类中？\n* 一个更复杂的例子\n* 支持类静态块的引擎\n* JavaScript 是否变得很像 Java 和/或一团糟？\n* 结论\n\n\n\n#### 1. 为什么我们需要**static blocks**在class类中？\n\n为了方便外部函数调用内部属性，我们通常会这样设置：\n\n```javascript\nclass Translator {\n  static translations = {\n    yes: 'ja',\n    no: 'nein',\n    maybe: 'vielleicht',\n  };\n  static englishWords = extractEnglish(this.translations);\n  static germanWords = extractGerman(this.translations);\n}\nfunction extractEnglish(translations) {\n  return Object.keys(translations);\n}\nfunction extractGerman(translations) {\n  return Object.values(translations);\n}\n```\n\n在这种情况下，使用外部函数 extractEnglish() 和 extractGerman() 效果很好，因为我们可以看到它们是从**类内部调用的**，并且它们完全**独立于类**。但是，如果我们想同时设置两个静态字段，事情就会变得不那么优雅：\n\n```javascript\nclass Translator {\n  static translations = {\n    yes: 'ja',\n    no: 'nein',\n    maybe: 'vielleicht',\n  };\n  static englishWords = [];\n  static germanWords = [];\n  static _ = initializeTranslator( // (A)\n    this.translations, this.englishWords, this.germanWords);\n}\nfunction initializeTranslator(translations, englishWords, germanWords) {\n  for (const [english, german] of Object.entries(translations)) {\n    englishWords.push(english);\n    germanWords.push(german);\n  }\n}\n```\n\n这次有几个问题：\n\n* 调用 initializeTranslator() 是一个额外的步骤，必须在创建类之后在类之外执行。或者通过变通方法执行（A 行）。\n* initializeTranslator() 无权访问 Translator 的私有属性。\n\n当我们使用 **static initialization blocks**（A 行），我们有一个更优雅的解决方案。\n\n```javascript\nclass Translator {\n  static translations = {\n    yes: 'ja',\n    no: 'nein',\n    maybe: 'vielleicht',\n  };\n  static englishWords = [];\n  static germanWords = [];\n  static { // (A)\n    for (const [english, german] of Object.entries(this.translations)) {\n      this.englishWords.push(english);\n      this.germanWords.push(german);\n    }\n  }\n}\n```\n\n\n\n#### 2.一个更复杂的例子\n\n**static initialization blocks** 的细节是相对合乎逻辑的（相对于更复杂的实例成员规则）：\n\n* 每个类可以有多个静态块。\n* 静态块的执行与静态字段初始值设定项的执行交错执行。\n* 超类的静态成员在子类的静态成员之前执行。\n\n以下代码演示了这些规则：\n\n```javascript\nclass SuperClass {\n  static superField1 = console.log('superField1');\n  static {\n    assert.equal(this, SuperClass);\n    console.log('static block 1 SuperClass');\n  }\n  static superField2 = console.log('superField2');\n  static {\n    console.log('static block 2 SuperClass');\n  }\n}\n\nclass SubClass extends SuperClass {\n  static subField1 = console.log('subField1');\n  static {\n    assert.equal(this, SubClass);\n    console.log('static block 1 SubClass');\n  }\n  static subField2 = console.log('subField2');\n  static {\n    console.log('static block 2 SubClass');\n  }\n}\n\n// Output:\n// 'superField1'\n// 'static block 1 SuperClass'\n// 'superField2'\n// 'static block 2 SuperClass'\n// 'subField1'\n// 'static block 1 SubClass'\n// 'subField2'\n// 'static block 2 SubClass'\n```\n\n\n\n#### 3. 支持类静态块的引擎\n\n- V8: unflagged in v9.4.146 ([source](https://github.com/tc39/proposal-class-static-block#stage-4-entrance-criteria))\n- SpiderMonkey: behind a flag in v92, intent to ship unflagged in v93 ([source](https://github.com/tc39/proposal-class-static-block#stage-4-entrance-criteria))\n- TypeScript: v4.4 ([source](https://devblogs.microsoft.com/typescript/announcing-typescript-4-4-rc/))\n\n\n\n#### 4. JavaScript 是否变得很像 Java 和/或一团糟？\n\n这是一个小功能，不会与其他功能竞争。我们已经可以通过带有 ` static _ = ... ` 解决方法的运行。**static initialization blocks** 意味着不再需要这种解决方法。除此之外，类只是JavaScript程序员的众多工具之一。有些人使用它，有些人不使用，还有很多替代方法。即使是使用类的JavaScript代码也经常使用函数，并且趋向于轻量级。\n\n\n\n#### 5.结论\n\n**static initialization blocks** 是一个相对简单的特性，它完善了类的静态属性。粗略地说，它是实例构造函数的静态版本。当我们必须设置多个静态字段时，它可以发挥很大的作用。\n\n","slug":"ES2022 feature: class static initialization blocks","published":1,"date":"2021-09-17T01:58:43.648Z","updated":"2021-12-28T02:13:10.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxph7qm400011op7e5vackdp","content":"<h2 id=\"ES2022-feature-class-static-initialization-blocks\"><a href=\"#ES2022-feature-class-static-initialization-blocks\" class=\"headerlink\" title=\"ES2022 feature: class static initialization blocks\"></a>ES2022 feature: class static initialization blocks</h2><h3 id=\"Introduction-简介\"><a href=\"#Introduction-简介\" class=\"headerlink\" title=\"Introduction 简介\"></a>Introduction 简介</h3><p>Ron Buckton 在 <em>ECMAScript</em> 规范中提出  <a href=\"https://github.com/tc39/proposal-class-static-block\">“Class static initialization blocks” </a>已经进入到第四阶段，预计将写入2022年ECMAScript中。</p>\n<p>当我们创建Class类，通常我们可以有两种方式创建 constructs：</p>\n<ul>\n<li> Field: 创建（并可选择初始化）实例属性；</li>\n<li>构造函数Constructor：在设置完成之前执行的代码块。</li>\n</ul>\n<p>为了设置类的静态部分，我们只有静态字段。 ECMAScript 提案为类引入了<strong>static initialization blocks</strong> 。</p>\n<p>大致上，对于静态类来说，构造函数对于实例来说是一样的。</p>\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><ul>\n<li>为什么我们需要<strong>static blocks</strong>在class类中？</li>\n<li>一个更复杂的例子</li>\n<li>支持类静态块的引擎</li>\n<li>JavaScript 是否变得很像 Java 和/或一团糟？</li>\n<li>结论</li>\n</ul>\n<h4 id=\"1-为什么我们需要static-blocks在class类中？\"><a href=\"#1-为什么我们需要static-blocks在class类中？\" class=\"headerlink\" title=\"1. 为什么我们需要static blocks在class类中？\"></a>1. 为什么我们需要<strong>static blocks</strong>在class类中？</h4><p>为了方便外部函数调用内部属性，我们通常会这样设置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Translator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> translations = &#123;</span><br><span class=\"line\">    <span class=\"attr\">yes</span>: <span class=\"string\">&#x27;ja&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">no</span>: <span class=\"string\">&#x27;nein&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">maybe</span>: <span class=\"string\">&#x27;vielleicht&#x27;</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> englishWords = extractEnglish(<span class=\"built_in\">this</span>.translations);</span><br><span class=\"line\">  <span class=\"keyword\">static</span> germanWords = extractGerman(<span class=\"built_in\">this</span>.translations);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extractEnglish</span>(<span class=\"params\">translations</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(translations);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extractGerman</span>(<span class=\"params\">translations</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.values(translations);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这种情况下，使用外部函数 extractEnglish() 和 extractGerman() 效果很好，因为我们可以看到它们是从<strong>类内部调用的</strong>，并且它们完全<strong>独立于类</strong>。但是，如果我们想同时设置两个静态字段，事情就会变得不那么优雅：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Translator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> translations = &#123;</span><br><span class=\"line\">    <span class=\"attr\">yes</span>: <span class=\"string\">&#x27;ja&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">no</span>: <span class=\"string\">&#x27;nein&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">maybe</span>: <span class=\"string\">&#x27;vielleicht&#x27;</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> englishWords = [];</span><br><span class=\"line\">  <span class=\"keyword\">static</span> germanWords = [];</span><br><span class=\"line\">  <span class=\"keyword\">static</span> _ = initializeTranslator( <span class=\"comment\">// (A)</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.translations, <span class=\"built_in\">this</span>.englishWords, <span class=\"built_in\">this</span>.germanWords);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initializeTranslator</span>(<span class=\"params\">translations, englishWords, germanWords</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> [english, german] <span class=\"keyword\">of</span> <span class=\"built_in\">Object</span>.entries(translations)) &#123;</span><br><span class=\"line\">    englishWords.push(english);</span><br><span class=\"line\">    germanWords.push(german);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这次有几个问题：</p>\n<ul>\n<li>调用 initializeTranslator() 是一个额外的步骤，必须在创建类之后在类之外执行。或者通过变通方法执行（A 行）。</li>\n<li>initializeTranslator() 无权访问 Translator 的私有属性。</li>\n</ul>\n<p>当我们使用 <strong>static initialization blocks</strong>（A 行），我们有一个更优雅的解决方案。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Translator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> translations = &#123;</span><br><span class=\"line\">    <span class=\"attr\">yes</span>: <span class=\"string\">&#x27;ja&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">no</span>: <span class=\"string\">&#x27;nein&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">maybe</span>: <span class=\"string\">&#x27;vielleicht&#x27;</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> englishWords = [];</span><br><span class=\"line\">  <span class=\"keyword\">static</span> germanWords = [];</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123; <span class=\"comment\">// (A)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> [english, german] <span class=\"keyword\">of</span> <span class=\"built_in\">Object</span>.entries(<span class=\"built_in\">this</span>.translations)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.englishWords.push(english);</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.germanWords.push(german);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-一个更复杂的例子\"><a href=\"#2-一个更复杂的例子\" class=\"headerlink\" title=\"2.一个更复杂的例子\"></a>2.一个更复杂的例子</h4><p><strong>static initialization blocks</strong> 的细节是相对合乎逻辑的（相对于更复杂的实例成员规则）：</p>\n<ul>\n<li>每个类可以有多个静态块。</li>\n<li>静态块的执行与静态字段初始值设定项的执行交错执行。</li>\n<li>超类的静态成员在子类的静态成员之前执行。</li>\n</ul>\n<p>以下代码演示了这些规则：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> superField1 = <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;superField1&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    assert.equal(<span class=\"built_in\">this</span>, SuperClass);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;static block 1 SuperClass&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> superField2 = <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;superField2&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;static block 2 SuperClass&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubClass</span> <span class=\"keyword\">extends</span> <span class=\"title\">SuperClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> subField1 = <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;subField1&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    assert.equal(<span class=\"built_in\">this</span>, SubClass);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;static block 1 SubClass&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> subField2 = <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;subField2&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;static block 2 SubClass&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;superField1&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;static block 1 SuperClass&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;superField2&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;static block 2 SuperClass&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;subField1&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;static block 1 SubClass&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;subField2&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;static block 2 SubClass&#x27;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-支持类静态块的引擎\"><a href=\"#3-支持类静态块的引擎\" class=\"headerlink\" title=\"3. 支持类静态块的引擎\"></a>3. 支持类静态块的引擎</h4><ul>\n<li>V8: unflagged in v9.4.146 (<a href=\"https://github.com/tc39/proposal-class-static-block#stage-4-entrance-criteria\">source</a>)</li>\n<li>SpiderMonkey: behind a flag in v92, intent to ship unflagged in v93 (<a href=\"https://github.com/tc39/proposal-class-static-block#stage-4-entrance-criteria\">source</a>)</li>\n<li>TypeScript: v4.4 (<a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-4-4-rc/\">source</a>)</li>\n</ul>\n<h4 id=\"4-JavaScript-是否变得很像-Java-和-或一团糟？\"><a href=\"#4-JavaScript-是否变得很像-Java-和-或一团糟？\" class=\"headerlink\" title=\"4. JavaScript 是否变得很像 Java 和/或一团糟？\"></a>4. JavaScript 是否变得很像 Java 和/或一团糟？</h4><p>这是一个小功能，不会与其他功能竞争。我们已经可以通过带有 <code>static _ = ...</code> 解决方法的运行。<strong>static initialization blocks</strong> 意味着不再需要这种解决方法。除此之外，类只是JavaScript程序员的众多工具之一。有些人使用它，有些人不使用，还有很多替代方法。即使是使用类的JavaScript代码也经常使用函数，并且趋向于轻量级。</p>\n<h4 id=\"5-结论\"><a href=\"#5-结论\" class=\"headerlink\" title=\"5.结论\"></a>5.结论</h4><p><strong>static initialization blocks</strong> 是一个相对简单的特性，它完善了类的静态属性。粗略地说，它是实例构造函数的静态版本。当我们必须设置多个静态字段时，它可以发挥很大的作用。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"ES2022-feature-class-static-initialization-blocks\"><a href=\"#ES2022-feature-class-static-initialization-blocks\" class=\"headerlink\" title=\"ES2022 feature: class static initialization blocks\"></a>ES2022 feature: class static initialization blocks</h2><h3 id=\"Introduction-简介\"><a href=\"#Introduction-简介\" class=\"headerlink\" title=\"Introduction 简介\"></a>Introduction 简介</h3><p>Ron Buckton 在 <em>ECMAScript</em> 规范中提出  <a href=\"https://github.com/tc39/proposal-class-static-block\">“Class static initialization blocks” </a>已经进入到第四阶段，预计将写入2022年ECMAScript中。</p>\n<p>当我们创建Class类，通常我们可以有两种方式创建 constructs：</p>\n<ul>\n<li> Field: 创建（并可选择初始化）实例属性；</li>\n<li>构造函数Constructor：在设置完成之前执行的代码块。</li>\n</ul>\n<p>为了设置类的静态部分，我们只有静态字段。 ECMAScript 提案为类引入了<strong>static initialization blocks</strong> 。</p>\n<p>大致上，对于静态类来说，构造函数对于实例来说是一样的。</p>\n<h3 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h3><ul>\n<li>为什么我们需要<strong>static blocks</strong>在class类中？</li>\n<li>一个更复杂的例子</li>\n<li>支持类静态块的引擎</li>\n<li>JavaScript 是否变得很像 Java 和/或一团糟？</li>\n<li>结论</li>\n</ul>\n<h4 id=\"1-为什么我们需要static-blocks在class类中？\"><a href=\"#1-为什么我们需要static-blocks在class类中？\" class=\"headerlink\" title=\"1. 为什么我们需要static blocks在class类中？\"></a>1. 为什么我们需要<strong>static blocks</strong>在class类中？</h4><p>为了方便外部函数调用内部属性，我们通常会这样设置：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Translator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> translations = &#123;</span><br><span class=\"line\">    <span class=\"attr\">yes</span>: <span class=\"string\">&#x27;ja&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">no</span>: <span class=\"string\">&#x27;nein&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">maybe</span>: <span class=\"string\">&#x27;vielleicht&#x27;</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> englishWords = extractEnglish(<span class=\"built_in\">this</span>.translations);</span><br><span class=\"line\">  <span class=\"keyword\">static</span> germanWords = extractGerman(<span class=\"built_in\">this</span>.translations);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extractEnglish</span>(<span class=\"params\">translations</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.keys(translations);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">extractGerman</span>(<span class=\"params\">translations</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.values(translations);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这种情况下，使用外部函数 extractEnglish() 和 extractGerman() 效果很好，因为我们可以看到它们是从<strong>类内部调用的</strong>，并且它们完全<strong>独立于类</strong>。但是，如果我们想同时设置两个静态字段，事情就会变得不那么优雅：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Translator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> translations = &#123;</span><br><span class=\"line\">    <span class=\"attr\">yes</span>: <span class=\"string\">&#x27;ja&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">no</span>: <span class=\"string\">&#x27;nein&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">maybe</span>: <span class=\"string\">&#x27;vielleicht&#x27;</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> englishWords = [];</span><br><span class=\"line\">  <span class=\"keyword\">static</span> germanWords = [];</span><br><span class=\"line\">  <span class=\"keyword\">static</span> _ = initializeTranslator( <span class=\"comment\">// (A)</span></span><br><span class=\"line\">    <span class=\"built_in\">this</span>.translations, <span class=\"built_in\">this</span>.englishWords, <span class=\"built_in\">this</span>.germanWords);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initializeTranslator</span>(<span class=\"params\">translations, englishWords, germanWords</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> [english, german] <span class=\"keyword\">of</span> <span class=\"built_in\">Object</span>.entries(translations)) &#123;</span><br><span class=\"line\">    englishWords.push(english);</span><br><span class=\"line\">    germanWords.push(german);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这次有几个问题：</p>\n<ul>\n<li>调用 initializeTranslator() 是一个额外的步骤，必须在创建类之后在类之外执行。或者通过变通方法执行（A 行）。</li>\n<li>initializeTranslator() 无权访问 Translator 的私有属性。</li>\n</ul>\n<p>当我们使用 <strong>static initialization blocks</strong>（A 行），我们有一个更优雅的解决方案。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Translator</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> translations = &#123;</span><br><span class=\"line\">    <span class=\"attr\">yes</span>: <span class=\"string\">&#x27;ja&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">no</span>: <span class=\"string\">&#x27;nein&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">maybe</span>: <span class=\"string\">&#x27;vielleicht&#x27;</span>,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> englishWords = [];</span><br><span class=\"line\">  <span class=\"keyword\">static</span> germanWords = [];</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123; <span class=\"comment\">// (A)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> [english, german] <span class=\"keyword\">of</span> <span class=\"built_in\">Object</span>.entries(<span class=\"built_in\">this</span>.translations)) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.englishWords.push(english);</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.germanWords.push(german);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"2-一个更复杂的例子\"><a href=\"#2-一个更复杂的例子\" class=\"headerlink\" title=\"2.一个更复杂的例子\"></a>2.一个更复杂的例子</h4><p><strong>static initialization blocks</strong> 的细节是相对合乎逻辑的（相对于更复杂的实例成员规则）：</p>\n<ul>\n<li>每个类可以有多个静态块。</li>\n<li>静态块的执行与静态字段初始值设定项的执行交错执行。</li>\n<li>超类的静态成员在子类的静态成员之前执行。</li>\n</ul>\n<p>以下代码演示了这些规则：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SuperClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> superField1 = <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;superField1&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    assert.equal(<span class=\"built_in\">this</span>, SuperClass);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;static block 1 SuperClass&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> superField2 = <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;superField2&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;static block 2 SuperClass&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubClass</span> <span class=\"keyword\">extends</span> <span class=\"title\">SuperClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> subField1 = <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;subField1&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    assert.equal(<span class=\"built_in\">this</span>, SubClass);</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;static block 1 SubClass&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> subField2 = <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;subField2&#x27;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;static block 2 SubClass&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Output:</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;superField1&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;static block 1 SuperClass&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;superField2&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;static block 2 SuperClass&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;subField1&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;static block 1 SubClass&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;subField2&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// &#x27;static block 2 SubClass&#x27;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"3-支持类静态块的引擎\"><a href=\"#3-支持类静态块的引擎\" class=\"headerlink\" title=\"3. 支持类静态块的引擎\"></a>3. 支持类静态块的引擎</h4><ul>\n<li>V8: unflagged in v9.4.146 (<a href=\"https://github.com/tc39/proposal-class-static-block#stage-4-entrance-criteria\">source</a>)</li>\n<li>SpiderMonkey: behind a flag in v92, intent to ship unflagged in v93 (<a href=\"https://github.com/tc39/proposal-class-static-block#stage-4-entrance-criteria\">source</a>)</li>\n<li>TypeScript: v4.4 (<a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-4-4-rc/\">source</a>)</li>\n</ul>\n<h4 id=\"4-JavaScript-是否变得很像-Java-和-或一团糟？\"><a href=\"#4-JavaScript-是否变得很像-Java-和-或一团糟？\" class=\"headerlink\" title=\"4. JavaScript 是否变得很像 Java 和/或一团糟？\"></a>4. JavaScript 是否变得很像 Java 和/或一团糟？</h4><p>这是一个小功能，不会与其他功能竞争。我们已经可以通过带有 <code>static _ = ...</code> 解决方法的运行。<strong>static initialization blocks</strong> 意味着不再需要这种解决方法。除此之外，类只是JavaScript程序员的众多工具之一。有些人使用它，有些人不使用，还有很多替代方法。即使是使用类的JavaScript代码也经常使用函数，并且趋向于轻量级。</p>\n<h4 id=\"5-结论\"><a href=\"#5-结论\" class=\"headerlink\" title=\"5.结论\"></a>5.结论</h4><p><strong>static initialization blocks</strong> 是一个相对简单的特性，它完善了类的静态属性。粗略地说，它是实例构造函数的静态版本。当我们必须设置多个静态字段时，它可以发挥很大的作用。</p>\n"},{"title":"JAVA 数据结构","_content":"\n## JAVA 数据结构\n\n\n### ArrayList：\n\n在java中定义的数组，不需要定义数组的长度，我们可以添加或删除元素。\n\n```java\nimport java.util.ArrayList;\n\nArrayList<T> objectName = new ArrayList<>();\n\n// 添加元素\nobjectName.add(\"Google1\");\nobjectName.add(\"Google2\");\nobjectName.add(\"Google3\");\n// 访问元素\nobjectName.get(1);\n// 修改元素\nobjectName.set(1, 'Google4');\n// 删除元素\nobjectName.remove(1);\n// 计算大小\nobjectName.size();\n// 迭代数组\nfor (int i = 0; i < objectName.size(); i++) {\n  System.out.println(objectName.get(i));\n}\n\n```\n\n\n\n### LinkedList：\n\n链表（Linked list）是一种常见的基础数据结构，是一种线性表，与 ArrayList 相比，LinkedList 的增加和删除对操作效率更高，而查找和修改的操作效率较低。\n\n```javascript\nimport java.util.LinkedList;\n\nLinkedList<T> objectName = new LinkedList<>();\n// 添加元素\nobjectName.add(\"Google1\");\nobjectName.add(\"Google2\");\nobjectName.add(\"Google3\");\n// 首位添加元素\nobjectName.addFirst(\"Google4\");\n```\n\n\n\n### HashSet：\n\nHashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。HashSet 允许有 null 值。HashSet 是无序的，即不会记录插入的顺序。\n\n```java\nimport java.util.HashSet;\n\nHashSet<T> objectName = new HashSet<>();\n// 添加元素\nobjectName.add(\"Google1\");\nobjectName.add(\"Google2\");\nobjectName.add(\"Google3\");\n// 判断是否包含元素\nobjectName.contains(\"Google3\");\n// 清除集合\nobjectName.clear();\n```\n\n\n\n### HashMap：\n\nHashMap 是一个散列表，它存储的内容是键值对(key-value)映射。\n\n```java\nimport java.util.HashMap;\n\nHashMap<Integer, String> objectName = new HashMap<Integer, String>();\n\nobjectName.put(1, 'hello')\nobjectName.put(2, 'world')\n\n```\n\n\n\n\n\n\n\n","source":"_posts/JAVA 数据结构.md","raw":"---\ntitle: JAVA 数据结构\ntags: java\n---\n\n## JAVA 数据结构\n\n\n### ArrayList：\n\n在java中定义的数组，不需要定义数组的长度，我们可以添加或删除元素。\n\n```java\nimport java.util.ArrayList;\n\nArrayList<T> objectName = new ArrayList<>();\n\n// 添加元素\nobjectName.add(\"Google1\");\nobjectName.add(\"Google2\");\nobjectName.add(\"Google3\");\n// 访问元素\nobjectName.get(1);\n// 修改元素\nobjectName.set(1, 'Google4');\n// 删除元素\nobjectName.remove(1);\n// 计算大小\nobjectName.size();\n// 迭代数组\nfor (int i = 0; i < objectName.size(); i++) {\n  System.out.println(objectName.get(i));\n}\n\n```\n\n\n\n### LinkedList：\n\n链表（Linked list）是一种常见的基础数据结构，是一种线性表，与 ArrayList 相比，LinkedList 的增加和删除对操作效率更高，而查找和修改的操作效率较低。\n\n```javascript\nimport java.util.LinkedList;\n\nLinkedList<T> objectName = new LinkedList<>();\n// 添加元素\nobjectName.add(\"Google1\");\nobjectName.add(\"Google2\");\nobjectName.add(\"Google3\");\n// 首位添加元素\nobjectName.addFirst(\"Google4\");\n```\n\n\n\n### HashSet：\n\nHashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。HashSet 允许有 null 值。HashSet 是无序的，即不会记录插入的顺序。\n\n```java\nimport java.util.HashSet;\n\nHashSet<T> objectName = new HashSet<>();\n// 添加元素\nobjectName.add(\"Google1\");\nobjectName.add(\"Google2\");\nobjectName.add(\"Google3\");\n// 判断是否包含元素\nobjectName.contains(\"Google3\");\n// 清除集合\nobjectName.clear();\n```\n\n\n\n### HashMap：\n\nHashMap 是一个散列表，它存储的内容是键值对(key-value)映射。\n\n```java\nimport java.util.HashMap;\n\nHashMap<Integer, String> objectName = new HashMap<Integer, String>();\n\nobjectName.put(1, 'hello')\nobjectName.put(2, 'world')\n\n```\n\n\n\n\n\n\n\n","slug":"JAVA 数据结构","published":1,"date":"2021-09-08T01:33:27.780Z","updated":"2021-12-28T02:13:44.787Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxph7qm700031op756h37h9w","content":"<h2 id=\"JAVA-数据结构\"><a href=\"#JAVA-数据结构\" class=\"headerlink\" title=\"JAVA 数据结构\"></a>JAVA 数据结构</h2><h3 id=\"ArrayList：\"><a href=\"#ArrayList：\" class=\"headerlink\" title=\"ArrayList：\"></a>ArrayList：</h3><p>在java中定义的数组，不需要定义数组的长度，我们可以添加或删除元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"></span><br><span class=\"line\">ArrayList&lt;T&gt; objectName = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加元素</span></span><br><span class=\"line\">objectName.add(<span class=\"string\">&quot;Google1&quot;</span>);</span><br><span class=\"line\">objectName.add(<span class=\"string\">&quot;Google2&quot;</span>);</span><br><span class=\"line\">objectName.add(<span class=\"string\">&quot;Google3&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 访问元素</span></span><br><span class=\"line\">objectName.get(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 修改元素</span></span><br><span class=\"line\">objectName.set(<span class=\"number\">1</span>, <span class=\"string\">&#x27;Google4&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 删除元素</span></span><br><span class=\"line\">objectName.remove(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 计算大小</span></span><br><span class=\"line\">objectName.size();</span><br><span class=\"line\"><span class=\"comment\">// 迭代数组</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; objectName.size(); i++) &#123;</span><br><span class=\"line\">  System.out.println(objectName.get(i));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"LinkedList：\"><a href=\"#LinkedList：\" class=\"headerlink\" title=\"LinkedList：\"></a>LinkedList：</h3><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，与 ArrayList 相比，LinkedList 的增加和删除对操作效率更高，而查找和修改的操作效率较低。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedList;</span><br><span class=\"line\"></span><br><span class=\"line\">LinkedList&lt;T&gt; objectName = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 添加元素</span></span><br><span class=\"line\">objectName.add(<span class=\"string\">&quot;Google1&quot;</span>);</span><br><span class=\"line\">objectName.add(<span class=\"string\">&quot;Google2&quot;</span>);</span><br><span class=\"line\">objectName.add(<span class=\"string\">&quot;Google3&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 首位添加元素</span></span><br><span class=\"line\">objectName.addFirst(<span class=\"string\">&quot;Google4&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"HashSet：\"><a href=\"#HashSet：\" class=\"headerlink\" title=\"HashSet：\"></a>HashSet：</h3><p>HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。HashSet 允许有 null 值。HashSet 是无序的，即不会记录插入的顺序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet;</span><br><span class=\"line\"></span><br><span class=\"line\">HashSet&lt;T&gt; objectName = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 添加元素</span></span><br><span class=\"line\">objectName.add(<span class=\"string\">&quot;Google1&quot;</span>);</span><br><span class=\"line\">objectName.add(<span class=\"string\">&quot;Google2&quot;</span>);</span><br><span class=\"line\">objectName.add(<span class=\"string\">&quot;Google3&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 判断是否包含元素</span></span><br><span class=\"line\">objectName.contains(<span class=\"string\">&quot;Google3&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 清除集合</span></span><br><span class=\"line\">objectName.clear();</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"HashMap：\"><a href=\"#HashMap：\" class=\"headerlink\" title=\"HashMap：\"></a>HashMap：</h3><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\">HashMap&lt;Integer, String&gt; objectName = <span class=\"keyword\">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">objectName.put(<span class=\"number\">1</span>, <span class=\"string\">&#x27;hello&#x27;</span>)</span><br><span class=\"line\">objectName.put(<span class=\"number\">2</span>, <span class=\"string\">&#x27;world&#x27;</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"JAVA-数据结构\"><a href=\"#JAVA-数据结构\" class=\"headerlink\" title=\"JAVA 数据结构\"></a>JAVA 数据结构</h2><h3 id=\"ArrayList：\"><a href=\"#ArrayList：\" class=\"headerlink\" title=\"ArrayList：\"></a>ArrayList：</h3><p>在java中定义的数组，不需要定义数组的长度，我们可以添加或删除元素。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"></span><br><span class=\"line\">ArrayList&lt;T&gt; objectName = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加元素</span></span><br><span class=\"line\">objectName.add(<span class=\"string\">&quot;Google1&quot;</span>);</span><br><span class=\"line\">objectName.add(<span class=\"string\">&quot;Google2&quot;</span>);</span><br><span class=\"line\">objectName.add(<span class=\"string\">&quot;Google3&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 访问元素</span></span><br><span class=\"line\">objectName.get(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 修改元素</span></span><br><span class=\"line\">objectName.set(<span class=\"number\">1</span>, <span class=\"string\">&#x27;Google4&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 删除元素</span></span><br><span class=\"line\">objectName.remove(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"comment\">// 计算大小</span></span><br><span class=\"line\">objectName.size();</span><br><span class=\"line\"><span class=\"comment\">// 迭代数组</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; objectName.size(); i++) &#123;</span><br><span class=\"line\">  System.out.println(objectName.get(i));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"LinkedList：\"><a href=\"#LinkedList：\" class=\"headerlink\" title=\"LinkedList：\"></a>LinkedList：</h3><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，与 ArrayList 相比，LinkedList 的增加和删除对操作效率更高，而查找和修改的操作效率较低。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.LinkedList;</span><br><span class=\"line\"></span><br><span class=\"line\">LinkedList&lt;T&gt; objectName = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 添加元素</span></span><br><span class=\"line\">objectName.add(<span class=\"string\">&quot;Google1&quot;</span>);</span><br><span class=\"line\">objectName.add(<span class=\"string\">&quot;Google2&quot;</span>);</span><br><span class=\"line\">objectName.add(<span class=\"string\">&quot;Google3&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 首位添加元素</span></span><br><span class=\"line\">objectName.addFirst(<span class=\"string\">&quot;Google4&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"HashSet：\"><a href=\"#HashSet：\" class=\"headerlink\" title=\"HashSet：\"></a>HashSet：</h3><p>HashSet 基于 HashMap 来实现的，是一个不允许有重复元素的集合。HashSet 允许有 null 值。HashSet 是无序的，即不会记录插入的顺序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet;</span><br><span class=\"line\"></span><br><span class=\"line\">HashSet&lt;T&gt; objectName = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\"><span class=\"comment\">// 添加元素</span></span><br><span class=\"line\">objectName.add(<span class=\"string\">&quot;Google1&quot;</span>);</span><br><span class=\"line\">objectName.add(<span class=\"string\">&quot;Google2&quot;</span>);</span><br><span class=\"line\">objectName.add(<span class=\"string\">&quot;Google3&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 判断是否包含元素</span></span><br><span class=\"line\">objectName.contains(<span class=\"string\">&quot;Google3&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 清除集合</span></span><br><span class=\"line\">objectName.clear();</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"HashMap：\"><a href=\"#HashMap：\" class=\"headerlink\" title=\"HashMap：\"></a>HashMap：</h3><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"></span><br><span class=\"line\">HashMap&lt;Integer, String&gt; objectName = <span class=\"keyword\">new</span> HashMap&lt;Integer, String&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">objectName.put(<span class=\"number\">1</span>, <span class=\"string\">&#x27;hello&#x27;</span>)</span><br><span class=\"line\">objectName.put(<span class=\"number\">2</span>, <span class=\"string\">&#x27;world&#x27;</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n"},{"title":"Node 架构一览","_content":"\n# Node 架构一览\n\n## 架构图\n![image-20211227203004503](https://tva1.sinaimg.cn/large/008i3skNly1gxso0a3v9ej31a40u0n18.jpg)\n\n- Node Standard library 为 node 官网提供的API调用库\n- Node bindings 实现 API 结合 C++ 调用的中间层\n- v8 javascript 虚拟机，提供javascript 执行环境\n- libuv 实现文件I/O，提供事件循环机制。\n- c-ares 提供异步处理DNS能力\n- 其他提供包括 http 解析、SSL、数据压缩等其他的能力\n\n## libuv \n![image-20211227203016485](https://tva1.sinaimg.cn/large/008i3skNly1gxso0hgctij31j80qedjd.jpg)\n\n网路请求 + 文件I/O + DNS 功能通讯 + 用户代码占用不同的消息机制。Network I/O相关的请求， 根据OS平台不同，分别使用Linux上的epoll，OSX和BSD类OS上的kqueue，SunOS上的event ports以及Windows上的IOCP机制。\n\n## V8\n\n```javascript\nv8 === handle + scoped + context\n```\nv8 中变量存放到heap中。可以使用 [heapdump](https://www.npmjs.com/package/heapdump) 对内存进行快照。并分析当前运行时内存占用情况。handle 存放的是变量的引用。Handle 分为 Local（本地） 和 Persistent（全局） 两种。当handle存放的引用删除了，那么对应heap中变量就会被GC回收。\n\nscoped 作用域。当一个函数体内执行完成后，GC开始回收函数内部变量，逐个回收显然么有通过作用域一次性回收效率高。\n\ncontext 执行上下文。Context 可以嵌套，即当前函数有一个 Context，调用其它函数时如果又有一个 Context，则在被调用的函数中 javascript 是以最近的 Context 为准的，当退出这个函数时，又恢复到了原来的 Context。平行之间的context相对独立，互不影响。\n\n```javascript\n// 平行context\n// a b 之间的context依赖当前共同执行环境，但是二者之间的执行环境不互相影响\nfunction a () {\n}\nfunction b () {\n}\n```\n","source":"_posts/Node 架构.md","raw":"---\ntitle: Node 架构一览\ntags: node\n---\n\n# Node 架构一览\n\n## 架构图\n![image-20211227203004503](https://tva1.sinaimg.cn/large/008i3skNly1gxso0a3v9ej31a40u0n18.jpg)\n\n- Node Standard library 为 node 官网提供的API调用库\n- Node bindings 实现 API 结合 C++ 调用的中间层\n- v8 javascript 虚拟机，提供javascript 执行环境\n- libuv 实现文件I/O，提供事件循环机制。\n- c-ares 提供异步处理DNS能力\n- 其他提供包括 http 解析、SSL、数据压缩等其他的能力\n\n## libuv \n![image-20211227203016485](https://tva1.sinaimg.cn/large/008i3skNly1gxso0hgctij31j80qedjd.jpg)\n\n网路请求 + 文件I/O + DNS 功能通讯 + 用户代码占用不同的消息机制。Network I/O相关的请求， 根据OS平台不同，分别使用Linux上的epoll，OSX和BSD类OS上的kqueue，SunOS上的event ports以及Windows上的IOCP机制。\n\n## V8\n\n```javascript\nv8 === handle + scoped + context\n```\nv8 中变量存放到heap中。可以使用 [heapdump](https://www.npmjs.com/package/heapdump) 对内存进行快照。并分析当前运行时内存占用情况。handle 存放的是变量的引用。Handle 分为 Local（本地） 和 Persistent（全局） 两种。当handle存放的引用删除了，那么对应heap中变量就会被GC回收。\n\nscoped 作用域。当一个函数体内执行完成后，GC开始回收函数内部变量，逐个回收显然么有通过作用域一次性回收效率高。\n\ncontext 执行上下文。Context 可以嵌套，即当前函数有一个 Context，调用其它函数时如果又有一个 Context，则在被调用的函数中 javascript 是以最近的 Context 为准的，当退出这个函数时，又恢复到了原来的 Context。平行之间的context相对独立，互不影响。\n\n```javascript\n// 平行context\n// a b 之间的context依赖当前共同执行环境，但是二者之间的执行环境不互相影响\nfunction a () {\n}\nfunction b () {\n}\n```\n","slug":"Node 架构","published":1,"date":"2021-06-29T14:55:02.962Z","updated":"2021-12-28T02:08:58.992Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxph7qm800041op7h7v64ahg","content":"<h1 id=\"Node-架构一览\"><a href=\"#Node-架构一览\" class=\"headerlink\" title=\"Node 架构一览\"></a>Node 架构一览</h1><h2 id=\"架构图\"><a href=\"#架构图\" class=\"headerlink\" title=\"架构图\"></a>架构图</h2><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso0a3v9ej31a40u0n18.jpg\" alt=\"image-20211227203004503\"></p>\n<ul>\n<li>Node Standard library 为 node 官网提供的API调用库</li>\n<li>Node bindings 实现 API 结合 C++ 调用的中间层</li>\n<li>v8 javascript 虚拟机，提供javascript 执行环境</li>\n<li>libuv 实现文件I/O，提供事件循环机制。</li>\n<li>c-ares 提供异步处理DNS能力</li>\n<li>其他提供包括 http 解析、SSL、数据压缩等其他的能力</li>\n</ul>\n<h2 id=\"libuv\"><a href=\"#libuv\" class=\"headerlink\" title=\"libuv\"></a>libuv</h2><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso0hgctij31j80qedjd.jpg\" alt=\"image-20211227203016485\"></p>\n<p>网路请求 + 文件I/O + DNS 功能通讯 + 用户代码占用不同的消息机制。Network I/O相关的请求， 根据OS平台不同，分别使用Linux上的epoll，OSX和BSD类OS上的kqueue，SunOS上的event ports以及Windows上的IOCP机制。</p>\n<h2 id=\"V8\"><a href=\"#V8\" class=\"headerlink\" title=\"V8\"></a>V8</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v8 === handle + scoped + context</span><br></pre></td></tr></table></figure>\n<p>v8 中变量存放到heap中。可以使用 <a href=\"https://www.npmjs.com/package/heapdump\">heapdump</a> 对内存进行快照。并分析当前运行时内存占用情况。handle 存放的是变量的引用。Handle 分为 Local（本地） 和 Persistent（全局） 两种。当handle存放的引用删除了，那么对应heap中变量就会被GC回收。</p>\n<p>scoped 作用域。当一个函数体内执行完成后，GC开始回收函数内部变量，逐个回收显然么有通过作用域一次性回收效率高。</p>\n<p>context 执行上下文。Context 可以嵌套，即当前函数有一个 Context，调用其它函数时如果又有一个 Context，则在被调用的函数中 javascript 是以最近的 Context 为准的，当退出这个函数时，又恢复到了原来的 Context。平行之间的context相对独立，互不影响。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 平行context</span></span><br><span class=\"line\"><span class=\"comment\">// a b 之间的context依赖当前共同执行环境，但是二者之间的执行环境不互相影响</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Node-架构一览\"><a href=\"#Node-架构一览\" class=\"headerlink\" title=\"Node 架构一览\"></a>Node 架构一览</h1><h2 id=\"架构图\"><a href=\"#架构图\" class=\"headerlink\" title=\"架构图\"></a>架构图</h2><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso0a3v9ej31a40u0n18.jpg\" alt=\"image-20211227203004503\"></p>\n<ul>\n<li>Node Standard library 为 node 官网提供的API调用库</li>\n<li>Node bindings 实现 API 结合 C++ 调用的中间层</li>\n<li>v8 javascript 虚拟机，提供javascript 执行环境</li>\n<li>libuv 实现文件I/O，提供事件循环机制。</li>\n<li>c-ares 提供异步处理DNS能力</li>\n<li>其他提供包括 http 解析、SSL、数据压缩等其他的能力</li>\n</ul>\n<h2 id=\"libuv\"><a href=\"#libuv\" class=\"headerlink\" title=\"libuv\"></a>libuv</h2><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso0hgctij31j80qedjd.jpg\" alt=\"image-20211227203016485\"></p>\n<p>网路请求 + 文件I/O + DNS 功能通讯 + 用户代码占用不同的消息机制。Network I/O相关的请求， 根据OS平台不同，分别使用Linux上的epoll，OSX和BSD类OS上的kqueue，SunOS上的event ports以及Windows上的IOCP机制。</p>\n<h2 id=\"V8\"><a href=\"#V8\" class=\"headerlink\" title=\"V8\"></a>V8</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v8 === handle + scoped + context</span><br></pre></td></tr></table></figure>\n<p>v8 中变量存放到heap中。可以使用 <a href=\"https://www.npmjs.com/package/heapdump\">heapdump</a> 对内存进行快照。并分析当前运行时内存占用情况。handle 存放的是变量的引用。Handle 分为 Local（本地） 和 Persistent（全局） 两种。当handle存放的引用删除了，那么对应heap中变量就会被GC回收。</p>\n<p>scoped 作用域。当一个函数体内执行完成后，GC开始回收函数内部变量，逐个回收显然么有通过作用域一次性回收效率高。</p>\n<p>context 执行上下文。Context 可以嵌套，即当前函数有一个 Context，调用其它函数时如果又有一个 Context，则在被调用的函数中 javascript 是以最近的 Context 为准的，当退出这个函数时，又恢复到了原来的 Context。平行之间的context相对独立，互不影响。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 平行context</span></span><br><span class=\"line\"><span class=\"comment\">// a b 之间的context依赖当前共同执行环境，但是二者之间的执行环境不互相影响</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Node 模块加载","_content":"\n# Node 模块加载\n\n```javascript\nconst http = require('http');\n```\n\n## 传送门\nhttps://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js\n\n## 解读\n\n### 模块检索\n![image-20211227203041858](https://tva1.sinaimg.cn/large/008i3skNly1gxso0xczkaj30xi0hcjss.jpg)\n- node作为js的运行环境，当你执行 `require` 的时候，采用回溯算法加载所有的模块。\n- requireDepth作为查找树深度。\n- 根据模块名称加载模块。\n\n```javascript\n// request ===> 模块加载的名称，例如：http\n// parent ===> Module的执行上下文Context\n// isMain ===> 判断是否是内置的系统模块\nModule._load = function(request, parent, isMain) {}\n```\n\n- Node 加载模块第一次会把加载好的模块进行缓存\n- 模块分三种：缓存模块、本地第三方模块、内置全局模块\n\n### import & require\n![image-20211227203054520](https://tva1.sinaimg.cn/large/008i3skNly1gxso14qs6vj31mq0cgdgy.jpg)\n\n如图所示：\n- es6 import 的提供，可以理解为一种规范。底层依旧是通过require来实现的。\n- import 在转换的过程中。添加了一个业内默认的标识： `__esModule`。\n- 内部代码采用严格模式：`\"use strict\"`。\n\n#### 为什么import只能放到文件头部？\n举例：\n```javascript\n// 执行异常\nfunction test () {\n    import bar from './b.mjs';\n    console.log(bar);\n}\n```\n![image-20211227203109337](https://tva1.sinaimg.cn/large/008i3skNly1gxso1e91awj318t0u0q95.jpg)\n\n个人总结：\n- `import` 与 `require` 最大的区别就是一个发生在运行时阶段，一个发生在编译阶段。\n- `import` 的出现是为了更好的提升静态语法分析，提升编译阶段的性能。\n- 如果提前将 `import` 编译后，是可以放到 function 内部的，所以import不允许在函数内部放置是偏约定性的，并不是绝对的。\n\n![image-20211227203120011](https://tva1.sinaimg.cn/large/008i3skNly1gxso1kp1xoj316j0u0acw.jpg)\n\n","source":"_posts/Node 模块加载.md","raw":"---\ntitle: Node 模块加载\ntags: node\n---\n\n# Node 模块加载\n\n```javascript\nconst http = require('http');\n```\n\n## 传送门\nhttps://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js\n\n## 解读\n\n### 模块检索\n![image-20211227203041858](https://tva1.sinaimg.cn/large/008i3skNly1gxso0xczkaj30xi0hcjss.jpg)\n- node作为js的运行环境，当你执行 `require` 的时候，采用回溯算法加载所有的模块。\n- requireDepth作为查找树深度。\n- 根据模块名称加载模块。\n\n```javascript\n// request ===> 模块加载的名称，例如：http\n// parent ===> Module的执行上下文Context\n// isMain ===> 判断是否是内置的系统模块\nModule._load = function(request, parent, isMain) {}\n```\n\n- Node 加载模块第一次会把加载好的模块进行缓存\n- 模块分三种：缓存模块、本地第三方模块、内置全局模块\n\n### import & require\n![image-20211227203054520](https://tva1.sinaimg.cn/large/008i3skNly1gxso14qs6vj31mq0cgdgy.jpg)\n\n如图所示：\n- es6 import 的提供，可以理解为一种规范。底层依旧是通过require来实现的。\n- import 在转换的过程中。添加了一个业内默认的标识： `__esModule`。\n- 内部代码采用严格模式：`\"use strict\"`。\n\n#### 为什么import只能放到文件头部？\n举例：\n```javascript\n// 执行异常\nfunction test () {\n    import bar from './b.mjs';\n    console.log(bar);\n}\n```\n![image-20211227203109337](https://tva1.sinaimg.cn/large/008i3skNly1gxso1e91awj318t0u0q95.jpg)\n\n个人总结：\n- `import` 与 `require` 最大的区别就是一个发生在运行时阶段，一个发生在编译阶段。\n- `import` 的出现是为了更好的提升静态语法分析，提升编译阶段的性能。\n- 如果提前将 `import` 编译后，是可以放到 function 内部的，所以import不允许在函数内部放置是偏约定性的，并不是绝对的。\n\n![image-20211227203120011](https://tva1.sinaimg.cn/large/008i3skNly1gxso1kp1xoj316j0u0acw.jpg)\n\n","slug":"Node 模块加载","published":1,"date":"2021-07-02T02:51:04.402Z","updated":"2021-12-28T02:09:20.808Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxph7qm900051op7fv2i5u6t","content":"<h1 id=\"Node-模块加载\"><a href=\"#Node-模块加载\" class=\"headerlink\" title=\"Node 模块加载\"></a>Node 模块加载</h1><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h2><p><a href=\"https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js\">https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js</a></p>\n<h2 id=\"解读\"><a href=\"#解读\" class=\"headerlink\" title=\"解读\"></a>解读</h2><h3 id=\"模块检索\"><a href=\"#模块检索\" class=\"headerlink\" title=\"模块检索\"></a>模块检索</h3><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso0xczkaj30xi0hcjss.jpg\" alt=\"image-20211227203041858\"></p>\n<ul>\n<li>node作为js的运行环境，当你执行 <code>require</code> 的时候，采用回溯算法加载所有的模块。</li>\n<li>requireDepth作为查找树深度。</li>\n<li>根据模块名称加载模块。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// request ===&gt; 模块加载的名称，例如：http</span></span><br><span class=\"line\"><span class=\"comment\">// parent ===&gt; Module的执行上下文Context</span></span><br><span class=\"line\"><span class=\"comment\">// isMain ===&gt; 判断是否是内置的系统模块</span></span><br><span class=\"line\">Module._load = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">request, parent, isMain</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Node 加载模块第一次会把加载好的模块进行缓存</li>\n<li>模块分三种：缓存模块、本地第三方模块、内置全局模块</li>\n</ul>\n<h3 id=\"import-amp-require\"><a href=\"#import-amp-require\" class=\"headerlink\" title=\"import &amp; require\"></a>import &amp; require</h3><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso14qs6vj31mq0cgdgy.jpg\" alt=\"image-20211227203054520\"></p>\n<p>如图所示：</p>\n<ul>\n<li>es6 import 的提供，可以理解为一种规范。底层依旧是通过require来实现的。</li>\n<li>import 在转换的过程中。添加了一个业内默认的标识： <code>__esModule</code>。</li>\n<li>内部代码采用严格模式：<code>&quot;use strict&quot;</code>。</li>\n</ul>\n<h4 id=\"为什么import只能放到文件头部？\"><a href=\"#为什么import只能放到文件头部？\" class=\"headerlink\" title=\"为什么import只能放到文件头部？\"></a>为什么import只能放到文件头部？</h4><p>举例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 执行异常</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">import</span> bar <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./b.mjs&#x27;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(bar);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso1e91awj318t0u0q95.jpg\" alt=\"image-20211227203109337\"></p>\n<p>个人总结：</p>\n<ul>\n<li><code>import</code> 与 <code>require</code> 最大的区别就是一个发生在运行时阶段，一个发生在编译阶段。</li>\n<li><code>import</code> 的出现是为了更好的提升静态语法分析，提升编译阶段的性能。</li>\n<li>如果提前将 <code>import</code> 编译后，是可以放到 function 内部的，所以import不允许在函数内部放置是偏约定性的，并不是绝对的。</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso1kp1xoj316j0u0acw.jpg\" alt=\"image-20211227203120011\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Node-模块加载\"><a href=\"#Node-模块加载\" class=\"headerlink\" title=\"Node 模块加载\"></a>Node 模块加载</h1><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"传送门\"><a href=\"#传送门\" class=\"headerlink\" title=\"传送门\"></a>传送门</h2><p><a href=\"https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js\">https://github.com/nodejs/node/blob/master/lib/internal/modules/cjs/loader.js</a></p>\n<h2 id=\"解读\"><a href=\"#解读\" class=\"headerlink\" title=\"解读\"></a>解读</h2><h3 id=\"模块检索\"><a href=\"#模块检索\" class=\"headerlink\" title=\"模块检索\"></a>模块检索</h3><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso0xczkaj30xi0hcjss.jpg\" alt=\"image-20211227203041858\"></p>\n<ul>\n<li>node作为js的运行环境，当你执行 <code>require</code> 的时候，采用回溯算法加载所有的模块。</li>\n<li>requireDepth作为查找树深度。</li>\n<li>根据模块名称加载模块。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// request ===&gt; 模块加载的名称，例如：http</span></span><br><span class=\"line\"><span class=\"comment\">// parent ===&gt; Module的执行上下文Context</span></span><br><span class=\"line\"><span class=\"comment\">// isMain ===&gt; 判断是否是内置的系统模块</span></span><br><span class=\"line\">Module._load = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">request, parent, isMain</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Node 加载模块第一次会把加载好的模块进行缓存</li>\n<li>模块分三种：缓存模块、本地第三方模块、内置全局模块</li>\n</ul>\n<h3 id=\"import-amp-require\"><a href=\"#import-amp-require\" class=\"headerlink\" title=\"import &amp; require\"></a>import &amp; require</h3><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso14qs6vj31mq0cgdgy.jpg\" alt=\"image-20211227203054520\"></p>\n<p>如图所示：</p>\n<ul>\n<li>es6 import 的提供，可以理解为一种规范。底层依旧是通过require来实现的。</li>\n<li>import 在转换的过程中。添加了一个业内默认的标识： <code>__esModule</code>。</li>\n<li>内部代码采用严格模式：<code>&quot;use strict&quot;</code>。</li>\n</ul>\n<h4 id=\"为什么import只能放到文件头部？\"><a href=\"#为什么import只能放到文件头部？\" class=\"headerlink\" title=\"为什么import只能放到文件头部？\"></a>为什么import只能放到文件头部？</h4><p>举例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 执行异常</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">import</span> bar <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./b.mjs&#x27;</span>;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(bar);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso1e91awj318t0u0q95.jpg\" alt=\"image-20211227203109337\"></p>\n<p>个人总结：</p>\n<ul>\n<li><code>import</code> 与 <code>require</code> 最大的区别就是一个发生在运行时阶段，一个发生在编译阶段。</li>\n<li><code>import</code> 的出现是为了更好的提升静态语法分析，提升编译阶段的性能。</li>\n<li>如果提前将 <code>import</code> 编译后，是可以放到 function 内部的，所以import不允许在函数内部放置是偏约定性的，并不是绝对的。</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso1kp1xoj316j0u0acw.jpg\" alt=\"image-20211227203120011\"></p>\n"},{"title":"Nuxt 源码体悟","_content":"\n# Nuxt 源码体悟\n\n## 模式\n\n`Nuxt` 或者是 `Next` 都提供了三种模式，借此梳理了一下。\n\n<table>\n  <thead>\n    <tr>\n      <th style=\"text-align:left\">&#x540D;&#x79F0;</th>\n      <th style=\"text-align:left\">&#x4F18;&#x70B9;</th>\n      <th style=\"text-align:left\">&#x7F3A;&#x70B9;</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"text-align:left\">SPA</td>\n      <td style=\"text-align:left\">\n        <p>1. Javascript Framework(vue/react/rn)&#x7B80;&#x5316;&#x9AD8;&#x5EA6;&#x6570;&#x636E;&#x6570;&#x636E;&#x7ED1;&#x5B9A;&#xFF0C;&#x7B80;&#x5316;&#x4EA4;&#x4E92;&#x5F0F;&#x5E94;&#x7528;&#x7A0B;&#x5E8F;&#x7684;&#x5F00;&#x53D1;&#x3002;</p>\n        <p>2. &#x4E00;&#x6B21;&#x8BF7;&#x6C42;&#xFF0C;&#x540E;&#x9762;&#x4E0D;&#x9700;&#x8981;&#x5728;&#x91CD;&#x590D;&#x8BF7;&#x6C42;&#x8D44;&#x6E90;&#x3002;</p>\n        <p>3. SPA &#x901A;&#x8FC7; API &#x63A8;&#x52A8;&#x6570;&#x636E;&#x4E0E;&#x5C55;&#x793A;&#x5C42;&#x7684;&#x5206;&#x79BB;&#x3002;</p>\n      </td>\n      <td style=\"text-align:left\">\n        <p>1. &#x5305;&#x4F53;&#x79EF;&#x8FC7;&#x5927;&#x3002;</p>\n        <p>2. &#x4E0D;&#x80FD;&#x5F88;&#x597D;&#x7684;SEO&#x3002;</p>\n        <p>3. &#x5E94;&#x7528;&#x72B6;&#x7531;&#x4E8E;&#x90FD;&#x5B58;&#x653E;&#x5230;&#x5185;&#x5B58;&#x4E2D;&#xFF0C;&#x5927;&#x578B;&#x5E94;&#x7528;&#x72B6;&#x6001;&#x590D;&#x6742;&#x5EA6;&#x8F83;&#x9AD8;&#x3002;</p>\n      </td>\n    </tr>\n    <tr>\n      <td style=\"text-align:left\">SSG</td>\n      <td style=\"text-align:left\">\n        <p>1. &#x66F4;&#x597D;&#x7684;SEO</p>\n        <p>2. &#x51CF;&#x5C11;LCP&#x7684;&#x8017;&#x65F6;&#x3002;</p>\n      </td>\n      <td style=\"text-align:left\">\n        <p>1. &#x5185;&#x5BB9;&#x66F4;&#x65B0;&#x4E0D;&#x53CA;&#x65F6;&#x3002;</p>\n        <p>2. &#x5B9A;&#x5236;&#x7C7B;&#x5BA2;&#x6237;&#x9700;&#x6C42;&#x53D8;&#x5F97;&#x590D;&#x6742;&#x3002;</p>\n      </td>\n    </tr>\n    <tr>\n      <td style=\"text-align:left\">SSR</td>\n      <td style=\"text-align:left\">\n        <p>1. &#x51CF;&#x5C11;LCP&#x7684;&#x8017;&#x65F6;</p>\n        <p>2. &#x5185;&#x5BB9;&#x66F4;&#x65B0;&#x53CA;&#x65F6;</p>\n      </td>\n      <td style=\"text-align:left\">\n        <p>1. &#x5E26;&#x6765;&#x670D;&#x52A1;&#x5668;&#x8FD0;&#x7EF4;&#x6210;&#x672C;&#x3002;</p>\n        <p>2. JS&#x591A;&#x73AF;&#x5883;&#x8FD0;&#x884C;&#x5BF9;&#x5F00;&#x53D1;&#x8005;&#x5168;&#x5C40;&#x53D8;&#x91CF;&#x4F7F;&#x7528;&#x6709;&#x8981;&#x6C42;&#x3002;</p>\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n## 为什么选择Nuxt?\n\nSSR 旨在用户请求访达时，首屏页面真实 DOM 早已从前端 Javascript Framework 中编译解析出来。从而浏览器渲染进程在渲染页面的时候，区别于 SPA, 不依赖 Javascript 解析。从而减少 LCP 的耗时。\n\n但是，当用户行为的注册、监听的时间，比如用户点击行为。还是依赖 js 。而且，SSR 服务端渲染出页面后，页面如何进行跳转。同样是开发者需要考虑的问题。\n\n开发部署阶段编译 → 路由表匹配模板 → 编译模板 + 打包工具输出JS → 生成页面返回 → http 用户请求 → koa 等server 拦截请求 → 路由表匹配模板 → 动态加载js\n\n以上是 Nuxt SSR模式下的主要流程。为什么选择Nuxt，在我看来，他提供了一种方便，方便开发者在不考虑内部机制的情况下，快速实现APP应用的SSR模式。所以，他的SSR模式是主打功能，相对于SPA，个人觉得框架本身它的侧重点不在与此。\n\n## Nuxt 编译阶段线性工作流\n\nNuxt 源码中，基类 Nuxt 继承一个NPM包，[Hable](https://www.npmjs.com/package/hable)。它贯穿整个 Nuxt 编译阶段的生命周期。Nuxt 官网中也有描述，它主要的功能对标 Webpack [Tapable](https://www.npmjs.com/package/tapable)。内部源码实现很好理解，一共不到200行代码。如图： ![GitHub](../.gitbook/assets/2.png) \n\n这里我浓缩了一下，代码如下：\n\n```javascript\nconst cache = {};\nfunction hook (name, fn) {\n    if (!cache[name]) {\n        cache[name] = [fn];\n    } else {\n        cache[name].push(fn);\n    }\n    return () => {\n        if (fn) {\n            console.log(\"==remove==\");\n        }\n    }\n} \n// 方法调用\nhook('test1', () => {\n    console.log(\"====待调用方法===\");\n})\nhook('test2', () => {\n    console.log(\"====待调用方法===\");\n})\n```\n\n```javascript\n// 内部对 cache 缓存的方法进行顺序执行\nfunction serial(task, fn) {\n    return tasks.reduce((promise, task) => promise.then(() => fn(task)), Promise.resolve(null))\n}\n```\n\n使用这样一个库的意义是保证 Nuxt 在编译阶段，各个部分都可以按照调用顺序执行，并且保证每一次的方法执行都基于上一次 Promise 的执行完成之后，从而形成编译阶段的线性工作流。\n\n## Nuxt Server\n\nNuxt 本身提供三种启动方式。开发阶段本身的诉求就是，高效的HMR，项目实时预览。那么在Nuxt中，底层是用了 Webpack 作为开发编译阶段的工具。如下图对比可以所示：\n\n![image-20211227192126293](https://tva1.sinaimg.cn/large/008i3skNly1gxsm0uze9jj31k80l4gnq.jpg)\n\n第一张图运行时内存占用较大，是因为webpack在动态编译js时候，会把编译所形成的DSL存储在内存当中，方便模板修改后，对 DSL 的 diff。而第二张图，代表着 Nuxt 提供的生产模式下的 server 启动方式。其本质基于 Node HTTP + [Connect](https://www.npmjs.com/package/connect) 模块结合。\n\n## Nuxt 各阶段梳理\n\n### 1. 开发部署阶段编译\n\nNuxt 基于vue，所以在编模板时，理所应当的利用了`vue-template-complier` 以及 `vue-loader` 对文件进行编译。同时，vue 提供了 SSR 模式的 `renderToString()`将模板转换成这是 DOM 字符串。\n\n### 2. 打包工具输出js\n\nNuxt 本身提供 Webpack + vue-loader 对模板进行编译、切割、解释、生成压缩文件。作为开发者，也可以结合自身去动完成。\n\n### 3. 生成页面返回\n\n`VueRender.renderer` 包含 \\( `SpaRender` + `SsrRender` \\)，两种模式被不通的Render方法所处理，处理过程中，结合 Nuxt.config.js 配置。生成完成的html字符串。输出到html中。\n\n![image-20211227192137232](https://tva1.sinaimg.cn/large/008i3skNly1gxsm11fajej310c0ly3zv.jpg)\n\n### 4. 路由表匹配实现页面切换\n\nNuxt 实现页面切换，主要是在编译解析路由的过程中，会生成不同的chunkName。chunkName 本身是和编译后的JS存在对应关系。所以当页面路由发生变化。Nuxt 会动态匹配并完成JS执行。\n\n![image-20211227192146683](https://tva1.sinaimg.cn/large/008i3skNly1gxsm17jordj313y0i40uv.jpg)\n\n","source":"_posts/Nuxt 源码体悟.md","raw":"---\ntitle: Nuxt 源码体悟\ntags: vue\n---\n\n# Nuxt 源码体悟\n\n## 模式\n\n`Nuxt` 或者是 `Next` 都提供了三种模式，借此梳理了一下。\n\n<table>\n  <thead>\n    <tr>\n      <th style=\"text-align:left\">&#x540D;&#x79F0;</th>\n      <th style=\"text-align:left\">&#x4F18;&#x70B9;</th>\n      <th style=\"text-align:left\">&#x7F3A;&#x70B9;</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"text-align:left\">SPA</td>\n      <td style=\"text-align:left\">\n        <p>1. Javascript Framework(vue/react/rn)&#x7B80;&#x5316;&#x9AD8;&#x5EA6;&#x6570;&#x636E;&#x6570;&#x636E;&#x7ED1;&#x5B9A;&#xFF0C;&#x7B80;&#x5316;&#x4EA4;&#x4E92;&#x5F0F;&#x5E94;&#x7528;&#x7A0B;&#x5E8F;&#x7684;&#x5F00;&#x53D1;&#x3002;</p>\n        <p>2. &#x4E00;&#x6B21;&#x8BF7;&#x6C42;&#xFF0C;&#x540E;&#x9762;&#x4E0D;&#x9700;&#x8981;&#x5728;&#x91CD;&#x590D;&#x8BF7;&#x6C42;&#x8D44;&#x6E90;&#x3002;</p>\n        <p>3. SPA &#x901A;&#x8FC7; API &#x63A8;&#x52A8;&#x6570;&#x636E;&#x4E0E;&#x5C55;&#x793A;&#x5C42;&#x7684;&#x5206;&#x79BB;&#x3002;</p>\n      </td>\n      <td style=\"text-align:left\">\n        <p>1. &#x5305;&#x4F53;&#x79EF;&#x8FC7;&#x5927;&#x3002;</p>\n        <p>2. &#x4E0D;&#x80FD;&#x5F88;&#x597D;&#x7684;SEO&#x3002;</p>\n        <p>3. &#x5E94;&#x7528;&#x72B6;&#x7531;&#x4E8E;&#x90FD;&#x5B58;&#x653E;&#x5230;&#x5185;&#x5B58;&#x4E2D;&#xFF0C;&#x5927;&#x578B;&#x5E94;&#x7528;&#x72B6;&#x6001;&#x590D;&#x6742;&#x5EA6;&#x8F83;&#x9AD8;&#x3002;</p>\n      </td>\n    </tr>\n    <tr>\n      <td style=\"text-align:left\">SSG</td>\n      <td style=\"text-align:left\">\n        <p>1. &#x66F4;&#x597D;&#x7684;SEO</p>\n        <p>2. &#x51CF;&#x5C11;LCP&#x7684;&#x8017;&#x65F6;&#x3002;</p>\n      </td>\n      <td style=\"text-align:left\">\n        <p>1. &#x5185;&#x5BB9;&#x66F4;&#x65B0;&#x4E0D;&#x53CA;&#x65F6;&#x3002;</p>\n        <p>2. &#x5B9A;&#x5236;&#x7C7B;&#x5BA2;&#x6237;&#x9700;&#x6C42;&#x53D8;&#x5F97;&#x590D;&#x6742;&#x3002;</p>\n      </td>\n    </tr>\n    <tr>\n      <td style=\"text-align:left\">SSR</td>\n      <td style=\"text-align:left\">\n        <p>1. &#x51CF;&#x5C11;LCP&#x7684;&#x8017;&#x65F6;</p>\n        <p>2. &#x5185;&#x5BB9;&#x66F4;&#x65B0;&#x53CA;&#x65F6;</p>\n      </td>\n      <td style=\"text-align:left\">\n        <p>1. &#x5E26;&#x6765;&#x670D;&#x52A1;&#x5668;&#x8FD0;&#x7EF4;&#x6210;&#x672C;&#x3002;</p>\n        <p>2. JS&#x591A;&#x73AF;&#x5883;&#x8FD0;&#x884C;&#x5BF9;&#x5F00;&#x53D1;&#x8005;&#x5168;&#x5C40;&#x53D8;&#x91CF;&#x4F7F;&#x7528;&#x6709;&#x8981;&#x6C42;&#x3002;</p>\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n## 为什么选择Nuxt?\n\nSSR 旨在用户请求访达时，首屏页面真实 DOM 早已从前端 Javascript Framework 中编译解析出来。从而浏览器渲染进程在渲染页面的时候，区别于 SPA, 不依赖 Javascript 解析。从而减少 LCP 的耗时。\n\n但是，当用户行为的注册、监听的时间，比如用户点击行为。还是依赖 js 。而且，SSR 服务端渲染出页面后，页面如何进行跳转。同样是开发者需要考虑的问题。\n\n开发部署阶段编译 → 路由表匹配模板 → 编译模板 + 打包工具输出JS → 生成页面返回 → http 用户请求 → koa 等server 拦截请求 → 路由表匹配模板 → 动态加载js\n\n以上是 Nuxt SSR模式下的主要流程。为什么选择Nuxt，在我看来，他提供了一种方便，方便开发者在不考虑内部机制的情况下，快速实现APP应用的SSR模式。所以，他的SSR模式是主打功能，相对于SPA，个人觉得框架本身它的侧重点不在与此。\n\n## Nuxt 编译阶段线性工作流\n\nNuxt 源码中，基类 Nuxt 继承一个NPM包，[Hable](https://www.npmjs.com/package/hable)。它贯穿整个 Nuxt 编译阶段的生命周期。Nuxt 官网中也有描述，它主要的功能对标 Webpack [Tapable](https://www.npmjs.com/package/tapable)。内部源码实现很好理解，一共不到200行代码。如图： ![GitHub](../.gitbook/assets/2.png) \n\n这里我浓缩了一下，代码如下：\n\n```javascript\nconst cache = {};\nfunction hook (name, fn) {\n    if (!cache[name]) {\n        cache[name] = [fn];\n    } else {\n        cache[name].push(fn);\n    }\n    return () => {\n        if (fn) {\n            console.log(\"==remove==\");\n        }\n    }\n} \n// 方法调用\nhook('test1', () => {\n    console.log(\"====待调用方法===\");\n})\nhook('test2', () => {\n    console.log(\"====待调用方法===\");\n})\n```\n\n```javascript\n// 内部对 cache 缓存的方法进行顺序执行\nfunction serial(task, fn) {\n    return tasks.reduce((promise, task) => promise.then(() => fn(task)), Promise.resolve(null))\n}\n```\n\n使用这样一个库的意义是保证 Nuxt 在编译阶段，各个部分都可以按照调用顺序执行，并且保证每一次的方法执行都基于上一次 Promise 的执行完成之后，从而形成编译阶段的线性工作流。\n\n## Nuxt Server\n\nNuxt 本身提供三种启动方式。开发阶段本身的诉求就是，高效的HMR，项目实时预览。那么在Nuxt中，底层是用了 Webpack 作为开发编译阶段的工具。如下图对比可以所示：\n\n![image-20211227192126293](https://tva1.sinaimg.cn/large/008i3skNly1gxsm0uze9jj31k80l4gnq.jpg)\n\n第一张图运行时内存占用较大，是因为webpack在动态编译js时候，会把编译所形成的DSL存储在内存当中，方便模板修改后，对 DSL 的 diff。而第二张图，代表着 Nuxt 提供的生产模式下的 server 启动方式。其本质基于 Node HTTP + [Connect](https://www.npmjs.com/package/connect) 模块结合。\n\n## Nuxt 各阶段梳理\n\n### 1. 开发部署阶段编译\n\nNuxt 基于vue，所以在编模板时，理所应当的利用了`vue-template-complier` 以及 `vue-loader` 对文件进行编译。同时，vue 提供了 SSR 模式的 `renderToString()`将模板转换成这是 DOM 字符串。\n\n### 2. 打包工具输出js\n\nNuxt 本身提供 Webpack + vue-loader 对模板进行编译、切割、解释、生成压缩文件。作为开发者，也可以结合自身去动完成。\n\n### 3. 生成页面返回\n\n`VueRender.renderer` 包含 \\( `SpaRender` + `SsrRender` \\)，两种模式被不通的Render方法所处理，处理过程中，结合 Nuxt.config.js 配置。生成完成的html字符串。输出到html中。\n\n![image-20211227192137232](https://tva1.sinaimg.cn/large/008i3skNly1gxsm11fajej310c0ly3zv.jpg)\n\n### 4. 路由表匹配实现页面切换\n\nNuxt 实现页面切换，主要是在编译解析路由的过程中，会生成不同的chunkName。chunkName 本身是和编译后的JS存在对应关系。所以当页面路由发生变化。Nuxt 会动态匹配并完成JS执行。\n\n![image-20211227192146683](https://tva1.sinaimg.cn/large/008i3skNly1gxsm17jordj313y0i40uv.jpg)\n\n","slug":"Nuxt 源码体悟","published":1,"date":"2021-05-28T09:42:21.199Z","updated":"2021-12-28T02:06:45.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxph7qma00081op79h15g4kg","content":"<h1 id=\"Nuxt-源码体悟\"><a href=\"#Nuxt-源码体悟\" class=\"headerlink\" title=\"Nuxt 源码体悟\"></a>Nuxt 源码体悟</h1><h2 id=\"模式\"><a href=\"#模式\" class=\"headerlink\" title=\"模式\"></a>模式</h2><p><code>Nuxt</code> 或者是 <code>Next</code> 都提供了三种模式，借此梳理了一下。</p>\n<table>\n  <thead>\n    <tr>\n      <th style=\"text-align:left\">&#x540D;&#x79F0;</th>\n      <th style=\"text-align:left\">&#x4F18;&#x70B9;</th>\n      <th style=\"text-align:left\">&#x7F3A;&#x70B9;</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"text-align:left\">SPA</td>\n      <td style=\"text-align:left\">\n        <p>1. Javascript Framework(vue/react/rn)&#x7B80;&#x5316;&#x9AD8;&#x5EA6;&#x6570;&#x636E;&#x6570;&#x636E;&#x7ED1;&#x5B9A;&#xFF0C;&#x7B80;&#x5316;&#x4EA4;&#x4E92;&#x5F0F;&#x5E94;&#x7528;&#x7A0B;&#x5E8F;&#x7684;&#x5F00;&#x53D1;&#x3002;</p>\n        <p>2. &#x4E00;&#x6B21;&#x8BF7;&#x6C42;&#xFF0C;&#x540E;&#x9762;&#x4E0D;&#x9700;&#x8981;&#x5728;&#x91CD;&#x590D;&#x8BF7;&#x6C42;&#x8D44;&#x6E90;&#x3002;</p>\n        <p>3. SPA &#x901A;&#x8FC7; API &#x63A8;&#x52A8;&#x6570;&#x636E;&#x4E0E;&#x5C55;&#x793A;&#x5C42;&#x7684;&#x5206;&#x79BB;&#x3002;</p>\n      </td>\n      <td style=\"text-align:left\">\n        <p>1. &#x5305;&#x4F53;&#x79EF;&#x8FC7;&#x5927;&#x3002;</p>\n        <p>2. &#x4E0D;&#x80FD;&#x5F88;&#x597D;&#x7684;SEO&#x3002;</p>\n        <p>3. &#x5E94;&#x7528;&#x72B6;&#x7531;&#x4E8E;&#x90FD;&#x5B58;&#x653E;&#x5230;&#x5185;&#x5B58;&#x4E2D;&#xFF0C;&#x5927;&#x578B;&#x5E94;&#x7528;&#x72B6;&#x6001;&#x590D;&#x6742;&#x5EA6;&#x8F83;&#x9AD8;&#x3002;</p>\n      </td>\n    </tr>\n    <tr>\n      <td style=\"text-align:left\">SSG</td>\n      <td style=\"text-align:left\">\n        <p>1. &#x66F4;&#x597D;&#x7684;SEO</p>\n        <p>2. &#x51CF;&#x5C11;LCP&#x7684;&#x8017;&#x65F6;&#x3002;</p>\n      </td>\n      <td style=\"text-align:left\">\n        <p>1. &#x5185;&#x5BB9;&#x66F4;&#x65B0;&#x4E0D;&#x53CA;&#x65F6;&#x3002;</p>\n        <p>2. &#x5B9A;&#x5236;&#x7C7B;&#x5BA2;&#x6237;&#x9700;&#x6C42;&#x53D8;&#x5F97;&#x590D;&#x6742;&#x3002;</p>\n      </td>\n    </tr>\n    <tr>\n      <td style=\"text-align:left\">SSR</td>\n      <td style=\"text-align:left\">\n        <p>1. &#x51CF;&#x5C11;LCP&#x7684;&#x8017;&#x65F6;</p>\n        <p>2. &#x5185;&#x5BB9;&#x66F4;&#x65B0;&#x53CA;&#x65F6;</p>\n      </td>\n      <td style=\"text-align:left\">\n        <p>1. &#x5E26;&#x6765;&#x670D;&#x52A1;&#x5668;&#x8FD0;&#x7EF4;&#x6210;&#x672C;&#x3002;</p>\n        <p>2. JS&#x591A;&#x73AF;&#x5883;&#x8FD0;&#x884C;&#x5BF9;&#x5F00;&#x53D1;&#x8005;&#x5168;&#x5C40;&#x53D8;&#x91CF;&#x4F7F;&#x7528;&#x6709;&#x8981;&#x6C42;&#x3002;</p>\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"为什么选择Nuxt\"><a href=\"#为什么选择Nuxt\" class=\"headerlink\" title=\"为什么选择Nuxt?\"></a>为什么选择Nuxt?</h2><p>SSR 旨在用户请求访达时，首屏页面真实 DOM 早已从前端 Javascript Framework 中编译解析出来。从而浏览器渲染进程在渲染页面的时候，区别于 SPA, 不依赖 Javascript 解析。从而减少 LCP 的耗时。</p>\n<p>但是，当用户行为的注册、监听的时间，比如用户点击行为。还是依赖 js 。而且，SSR 服务端渲染出页面后，页面如何进行跳转。同样是开发者需要考虑的问题。</p>\n<p>开发部署阶段编译 → 路由表匹配模板 → 编译模板 + 打包工具输出JS → 生成页面返回 → http 用户请求 → koa 等server 拦截请求 → 路由表匹配模板 → 动态加载js</p>\n<p>以上是 Nuxt SSR模式下的主要流程。为什么选择Nuxt，在我看来，他提供了一种方便，方便开发者在不考虑内部机制的情况下，快速实现APP应用的SSR模式。所以，他的SSR模式是主打功能，相对于SPA，个人觉得框架本身它的侧重点不在与此。</p>\n<h2 id=\"Nuxt-编译阶段线性工作流\"><a href=\"#Nuxt-编译阶段线性工作流\" class=\"headerlink\" title=\"Nuxt 编译阶段线性工作流\"></a>Nuxt 编译阶段线性工作流</h2><p>Nuxt 源码中，基类 Nuxt 继承一个NPM包，<a href=\"https://www.npmjs.com/package/hable\">Hable</a>。它贯穿整个 Nuxt 编译阶段的生命周期。Nuxt 官网中也有描述，它主要的功能对标 Webpack <a href=\"https://www.npmjs.com/package/tapable\">Tapable</a>。内部源码实现很好理解，一共不到200行代码。如图： <img src=\"../.gitbook/assets/2.png\" alt=\"GitHub\"> </p>\n<p>这里我浓缩了一下，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cache = &#123;&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hook</span> (<span class=\"params\">name, fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cache[name]) &#123;</span><br><span class=\"line\">        cache[name] = [fn];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        cache[name].push(fn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fn) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;==remove==&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">// 方法调用</span></span><br><span class=\"line\">hook(<span class=\"string\">&#x27;test1&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;====待调用方法===&quot;</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">hook(<span class=\"string\">&#x27;test2&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;====待调用方法===&quot;</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 内部对 cache 缓存的方法进行顺序执行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">serial</span>(<span class=\"params\">task, fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tasks.reduce(<span class=\"function\">(<span class=\"params\">promise, task</span>) =&gt;</span> promise.then(<span class=\"function\">() =&gt;</span> fn(task)), <span class=\"built_in\">Promise</span>.resolve(<span class=\"literal\">null</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用这样一个库的意义是保证 Nuxt 在编译阶段，各个部分都可以按照调用顺序执行，并且保证每一次的方法执行都基于上一次 Promise 的执行完成之后，从而形成编译阶段的线性工作流。</p>\n<h2 id=\"Nuxt-Server\"><a href=\"#Nuxt-Server\" class=\"headerlink\" title=\"Nuxt Server\"></a>Nuxt Server</h2><p>Nuxt 本身提供三种启动方式。开发阶段本身的诉求就是，高效的HMR，项目实时预览。那么在Nuxt中，底层是用了 Webpack 作为开发编译阶段的工具。如下图对比可以所示：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsm0uze9jj31k80l4gnq.jpg\" alt=\"image-20211227192126293\"></p>\n<p>第一张图运行时内存占用较大，是因为webpack在动态编译js时候，会把编译所形成的DSL存储在内存当中，方便模板修改后，对 DSL 的 diff。而第二张图，代表着 Nuxt 提供的生产模式下的 server 启动方式。其本质基于 Node HTTP + <a href=\"https://www.npmjs.com/package/connect\">Connect</a> 模块结合。</p>\n<h2 id=\"Nuxt-各阶段梳理\"><a href=\"#Nuxt-各阶段梳理\" class=\"headerlink\" title=\"Nuxt 各阶段梳理\"></a>Nuxt 各阶段梳理</h2><h3 id=\"1-开发部署阶段编译\"><a href=\"#1-开发部署阶段编译\" class=\"headerlink\" title=\"1. 开发部署阶段编译\"></a>1. 开发部署阶段编译</h3><p>Nuxt 基于vue，所以在编模板时，理所应当的利用了<code>vue-template-complier</code> 以及 <code>vue-loader</code> 对文件进行编译。同时，vue 提供了 SSR 模式的 <code>renderToString()</code>将模板转换成这是 DOM 字符串。</p>\n<h3 id=\"2-打包工具输出js\"><a href=\"#2-打包工具输出js\" class=\"headerlink\" title=\"2. 打包工具输出js\"></a>2. 打包工具输出js</h3><p>Nuxt 本身提供 Webpack + vue-loader 对模板进行编译、切割、解释、生成压缩文件。作为开发者，也可以结合自身去动完成。</p>\n<h3 id=\"3-生成页面返回\"><a href=\"#3-生成页面返回\" class=\"headerlink\" title=\"3. 生成页面返回\"></a>3. 生成页面返回</h3><p><code>VueRender.renderer</code> 包含 ( <code>SpaRender</code> + <code>SsrRender</code> )，两种模式被不通的Render方法所处理，处理过程中，结合 Nuxt.config.js 配置。生成完成的html字符串。输出到html中。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsm11fajej310c0ly3zv.jpg\" alt=\"image-20211227192137232\"></p>\n<h3 id=\"4-路由表匹配实现页面切换\"><a href=\"#4-路由表匹配实现页面切换\" class=\"headerlink\" title=\"4. 路由表匹配实现页面切换\"></a>4. 路由表匹配实现页面切换</h3><p>Nuxt 实现页面切换，主要是在编译解析路由的过程中，会生成不同的chunkName。chunkName 本身是和编译后的JS存在对应关系。所以当页面路由发生变化。Nuxt 会动态匹配并完成JS执行。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsm17jordj313y0i40uv.jpg\" alt=\"image-20211227192146683\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Nuxt-源码体悟\"><a href=\"#Nuxt-源码体悟\" class=\"headerlink\" title=\"Nuxt 源码体悟\"></a>Nuxt 源码体悟</h1><h2 id=\"模式\"><a href=\"#模式\" class=\"headerlink\" title=\"模式\"></a>模式</h2><p><code>Nuxt</code> 或者是 <code>Next</code> 都提供了三种模式，借此梳理了一下。</p>\n<table>\n  <thead>\n    <tr>\n      <th style=\"text-align:left\">&#x540D;&#x79F0;</th>\n      <th style=\"text-align:left\">&#x4F18;&#x70B9;</th>\n      <th style=\"text-align:left\">&#x7F3A;&#x70B9;</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td style=\"text-align:left\">SPA</td>\n      <td style=\"text-align:left\">\n        <p>1. Javascript Framework(vue/react/rn)&#x7B80;&#x5316;&#x9AD8;&#x5EA6;&#x6570;&#x636E;&#x6570;&#x636E;&#x7ED1;&#x5B9A;&#xFF0C;&#x7B80;&#x5316;&#x4EA4;&#x4E92;&#x5F0F;&#x5E94;&#x7528;&#x7A0B;&#x5E8F;&#x7684;&#x5F00;&#x53D1;&#x3002;</p>\n        <p>2. &#x4E00;&#x6B21;&#x8BF7;&#x6C42;&#xFF0C;&#x540E;&#x9762;&#x4E0D;&#x9700;&#x8981;&#x5728;&#x91CD;&#x590D;&#x8BF7;&#x6C42;&#x8D44;&#x6E90;&#x3002;</p>\n        <p>3. SPA &#x901A;&#x8FC7; API &#x63A8;&#x52A8;&#x6570;&#x636E;&#x4E0E;&#x5C55;&#x793A;&#x5C42;&#x7684;&#x5206;&#x79BB;&#x3002;</p>\n      </td>\n      <td style=\"text-align:left\">\n        <p>1. &#x5305;&#x4F53;&#x79EF;&#x8FC7;&#x5927;&#x3002;</p>\n        <p>2. &#x4E0D;&#x80FD;&#x5F88;&#x597D;&#x7684;SEO&#x3002;</p>\n        <p>3. &#x5E94;&#x7528;&#x72B6;&#x7531;&#x4E8E;&#x90FD;&#x5B58;&#x653E;&#x5230;&#x5185;&#x5B58;&#x4E2D;&#xFF0C;&#x5927;&#x578B;&#x5E94;&#x7528;&#x72B6;&#x6001;&#x590D;&#x6742;&#x5EA6;&#x8F83;&#x9AD8;&#x3002;</p>\n      </td>\n    </tr>\n    <tr>\n      <td style=\"text-align:left\">SSG</td>\n      <td style=\"text-align:left\">\n        <p>1. &#x66F4;&#x597D;&#x7684;SEO</p>\n        <p>2. &#x51CF;&#x5C11;LCP&#x7684;&#x8017;&#x65F6;&#x3002;</p>\n      </td>\n      <td style=\"text-align:left\">\n        <p>1. &#x5185;&#x5BB9;&#x66F4;&#x65B0;&#x4E0D;&#x53CA;&#x65F6;&#x3002;</p>\n        <p>2. &#x5B9A;&#x5236;&#x7C7B;&#x5BA2;&#x6237;&#x9700;&#x6C42;&#x53D8;&#x5F97;&#x590D;&#x6742;&#x3002;</p>\n      </td>\n    </tr>\n    <tr>\n      <td style=\"text-align:left\">SSR</td>\n      <td style=\"text-align:left\">\n        <p>1. &#x51CF;&#x5C11;LCP&#x7684;&#x8017;&#x65F6;</p>\n        <p>2. &#x5185;&#x5BB9;&#x66F4;&#x65B0;&#x53CA;&#x65F6;</p>\n      </td>\n      <td style=\"text-align:left\">\n        <p>1. &#x5E26;&#x6765;&#x670D;&#x52A1;&#x5668;&#x8FD0;&#x7EF4;&#x6210;&#x672C;&#x3002;</p>\n        <p>2. JS&#x591A;&#x73AF;&#x5883;&#x8FD0;&#x884C;&#x5BF9;&#x5F00;&#x53D1;&#x8005;&#x5168;&#x5C40;&#x53D8;&#x91CF;&#x4F7F;&#x7528;&#x6709;&#x8981;&#x6C42;&#x3002;</p>\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"为什么选择Nuxt\"><a href=\"#为什么选择Nuxt\" class=\"headerlink\" title=\"为什么选择Nuxt?\"></a>为什么选择Nuxt?</h2><p>SSR 旨在用户请求访达时，首屏页面真实 DOM 早已从前端 Javascript Framework 中编译解析出来。从而浏览器渲染进程在渲染页面的时候，区别于 SPA, 不依赖 Javascript 解析。从而减少 LCP 的耗时。</p>\n<p>但是，当用户行为的注册、监听的时间，比如用户点击行为。还是依赖 js 。而且，SSR 服务端渲染出页面后，页面如何进行跳转。同样是开发者需要考虑的问题。</p>\n<p>开发部署阶段编译 → 路由表匹配模板 → 编译模板 + 打包工具输出JS → 生成页面返回 → http 用户请求 → koa 等server 拦截请求 → 路由表匹配模板 → 动态加载js</p>\n<p>以上是 Nuxt SSR模式下的主要流程。为什么选择Nuxt，在我看来，他提供了一种方便，方便开发者在不考虑内部机制的情况下，快速实现APP应用的SSR模式。所以，他的SSR模式是主打功能，相对于SPA，个人觉得框架本身它的侧重点不在与此。</p>\n<h2 id=\"Nuxt-编译阶段线性工作流\"><a href=\"#Nuxt-编译阶段线性工作流\" class=\"headerlink\" title=\"Nuxt 编译阶段线性工作流\"></a>Nuxt 编译阶段线性工作流</h2><p>Nuxt 源码中，基类 Nuxt 继承一个NPM包，<a href=\"https://www.npmjs.com/package/hable\">Hable</a>。它贯穿整个 Nuxt 编译阶段的生命周期。Nuxt 官网中也有描述，它主要的功能对标 Webpack <a href=\"https://www.npmjs.com/package/tapable\">Tapable</a>。内部源码实现很好理解，一共不到200行代码。如图： <img src=\"../.gitbook/assets/2.png\" alt=\"GitHub\"> </p>\n<p>这里我浓缩了一下，代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> cache = &#123;&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">hook</span> (<span class=\"params\">name, fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!cache[name]) &#123;</span><br><span class=\"line\">        cache[name] = [fn];</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        cache[name].push(fn);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fn) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;==remove==&quot;</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">// 方法调用</span></span><br><span class=\"line\">hook(<span class=\"string\">&#x27;test1&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;====待调用方法===&quot;</span>);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">hook(<span class=\"string\">&#x27;test2&#x27;</span>, <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;====待调用方法===&quot;</span>);</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 内部对 cache 缓存的方法进行顺序执行</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">serial</span>(<span class=\"params\">task, fn</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tasks.reduce(<span class=\"function\">(<span class=\"params\">promise, task</span>) =&gt;</span> promise.then(<span class=\"function\">() =&gt;</span> fn(task)), <span class=\"built_in\">Promise</span>.resolve(<span class=\"literal\">null</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>使用这样一个库的意义是保证 Nuxt 在编译阶段，各个部分都可以按照调用顺序执行，并且保证每一次的方法执行都基于上一次 Promise 的执行完成之后，从而形成编译阶段的线性工作流。</p>\n<h2 id=\"Nuxt-Server\"><a href=\"#Nuxt-Server\" class=\"headerlink\" title=\"Nuxt Server\"></a>Nuxt Server</h2><p>Nuxt 本身提供三种启动方式。开发阶段本身的诉求就是，高效的HMR，项目实时预览。那么在Nuxt中，底层是用了 Webpack 作为开发编译阶段的工具。如下图对比可以所示：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsm0uze9jj31k80l4gnq.jpg\" alt=\"image-20211227192126293\"></p>\n<p>第一张图运行时内存占用较大，是因为webpack在动态编译js时候，会把编译所形成的DSL存储在内存当中，方便模板修改后，对 DSL 的 diff。而第二张图，代表着 Nuxt 提供的生产模式下的 server 启动方式。其本质基于 Node HTTP + <a href=\"https://www.npmjs.com/package/connect\">Connect</a> 模块结合。</p>\n<h2 id=\"Nuxt-各阶段梳理\"><a href=\"#Nuxt-各阶段梳理\" class=\"headerlink\" title=\"Nuxt 各阶段梳理\"></a>Nuxt 各阶段梳理</h2><h3 id=\"1-开发部署阶段编译\"><a href=\"#1-开发部署阶段编译\" class=\"headerlink\" title=\"1. 开发部署阶段编译\"></a>1. 开发部署阶段编译</h3><p>Nuxt 基于vue，所以在编模板时，理所应当的利用了<code>vue-template-complier</code> 以及 <code>vue-loader</code> 对文件进行编译。同时，vue 提供了 SSR 模式的 <code>renderToString()</code>将模板转换成这是 DOM 字符串。</p>\n<h3 id=\"2-打包工具输出js\"><a href=\"#2-打包工具输出js\" class=\"headerlink\" title=\"2. 打包工具输出js\"></a>2. 打包工具输出js</h3><p>Nuxt 本身提供 Webpack + vue-loader 对模板进行编译、切割、解释、生成压缩文件。作为开发者，也可以结合自身去动完成。</p>\n<h3 id=\"3-生成页面返回\"><a href=\"#3-生成页面返回\" class=\"headerlink\" title=\"3. 生成页面返回\"></a>3. 生成页面返回</h3><p><code>VueRender.renderer</code> 包含 ( <code>SpaRender</code> + <code>SsrRender</code> )，两种模式被不通的Render方法所处理，处理过程中，结合 Nuxt.config.js 配置。生成完成的html字符串。输出到html中。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsm11fajej310c0ly3zv.jpg\" alt=\"image-20211227192137232\"></p>\n<h3 id=\"4-路由表匹配实现页面切换\"><a href=\"#4-路由表匹配实现页面切换\" class=\"headerlink\" title=\"4. 路由表匹配实现页面切换\"></a>4. 路由表匹配实现页面切换</h3><p>Nuxt 实现页面切换，主要是在编译解析路由的过程中，会生成不同的chunkName。chunkName 本身是和编译后的JS存在对应关系。所以当页面路由发生变化。Nuxt 会动态匹配并完成JS执行。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsm17jordj313y0i40uv.jpg\" alt=\"image-20211227192146683\"></p>\n"},{"title":"Nuxt 3 概述","_content":"\n# Nuxt 3 概述\n\n\n\n## 一.  Nuxt 框架\n\n\n\n### 1. 概述\n\n**Nuxt 当前版本介绍：** Build your next Vue.js application with confidence using Nuxt. An open source framework making web development simple and powerful.\n\n**Nuxt 3 新版本介绍：**Build your next application with Vue 3 and experience hybrid rendering, powerful data fetching and new features. Nuxt 3 is an open source framework making web development simple and powerful.\n\n**Nuxt** 框架，是一个集百家之所长，可以让开发者不用关心同构、注水等 **SSR** 细节，快速构建**WEB**应用的一个开源框架。**Nuxt3** 基于**vue3.0** 版本的一些新的特性，相比于nuxt之前版本，提供更快、更强、更轻量的能力。\n\n\n\n### 2. 版本更新概述\n\n- Webpack 5 and Vite 支持\n- PostCSS 8\n- rollup-plugin-esbuild 融合了 Esbuild、Rollup等优秀特性\n- Vue-bundle-renderer 基于 vue ssr 官方提供的基础API \n- 基于 Composition API\n\n\n\n### 3. Nuxt 3 工程\n\n**仓库地址：** https://github.com/nuxt/framework\n\n**工程结构简述：**\n\n![image-20211227192251521](https://tva1.sinaimg.cn/large/008i3skNly1gxsm2c2ar5j31i40ts41k.jpg)\n\n\n\n## 二. SSR 简史\n\n\n\n### 1. web 1.0 时代\n\n\n\n![image-20211213194138296](https://tva1.sinaimg.cn/large/008i3skNly1gxgtwi248qj315h0n9mye.jpg)\n\n\n\n| 优势       | 劣势                                 |\n| ---------- | ------------------------------------ |\n| 更好的SEO  | 协同开发困难                         |\n| FCP 耗时短 | 服务端对数据库频繁操作带来的性能损耗 |\n\n\n\n### 2. SSR\n\n> CSR: 客户端渲染(Client Side Render)\n\n伴随着AJAX技术的不断发展，渐渐出现前后端分离、CSR 慢慢进入到了公众的视野。但是随着业务不断的繁重，打包编译后的Bundle文件随着代码量的增加，业务功能渐渐丰满，无脑引入第三方开源库，很快变成一个巨婴项目。\n\n此时，SSR （ Server Side Rendering ）重新被提起和认识。\n\n![image-20211213194213452](https://tva1.sinaimg.cn/large/008i3skNly1gxgtwu4q0ij315l0msmyq.jpg)\n\n\n\n![image-20211213195240072](https://tva1.sinaimg.cn/large/008i3skNly1gxgtx3h2i6j315l0ll75r.jpg)\n\n\n\n#### 2.1 概念说明\n\n| 概念（行话、黑话） | 含义                                                         |\n| ------------------ | :----------------------------------------------------------- |\n| 注水               | 抵达客户端后，会将一部分数据、DOM结构体等注入到HTML页面中    |\n| 吸水               | 抵达客户端后，当期环境运行javascript脚本，发起第二次增量渲染 |\n| 脱水               | 使其在恶劣的环境同样能够以一种更简单的形态“生存”下来，比如禁用了 JavaScript 的客户端环境，脱去生命的水气（动态数据），成为风干标本一样的静态快照。 |\n| 同构               | 当我们有且只有一份源代码，要实现不同环境的运行要求所采取的一种构建方式；例如：客户端运行的Bundle需要适配低版本浏览器，转成ES5代码；服务端Bundle不需要进行代码混淆压缩；服务端Bundle不需要安装css-loader等插件。 |\n\n#### 2.2 流行框架支持\n\n![image-20211213195907961](https://tva1.sinaimg.cn/large/008i3skNly1gxgtxf5flbj315y0iwjsr.jpg)\n\n#### 2.3 Nuxt 3 举例\n\n![image-20211213200008949](https://tva1.sinaimg.cn/large/008i3skNly1gxgtxkxq9aj316c0nsq8e.jpg)\n\n## 三. Nitro 服务引擎\n\n\n\n### 1. Nitro 简介\n\nNuxt 的新服务器引擎，Nuxt研发团队历时 9 个月，解锁的服务引擎。实现类似于 Next.js 中 API 路由。在生产中，它将您的应用程序和服务器构建到一个通用[`.output` ](https://v3.nuxtjs.org/docs/directory-structure/output)目录中。此**输出很轻**：从任何 Node.js 模块（polyfill 除外）中缩小并删除。您可以将此输出部署到任何支持 JavaScript 的系统上，从 Node.js、Serverless、Workers、或纯静态。Nitro 服务器的基础是 rollup 和[h3](https://github.com/unjs/h3)：为高性能和可移植性而构建的最小 http 框架，如下图，Nitro 实际上相当于下图红色框部分。\n\n![image-20211213223119233](https://tva1.sinaimg.cn/large/008i3skNly1gxgtxt92n9j31h20u076z.jpg)\n\n\n\n### 2. h3 概述\n\nNitro 核心基于h3， 仓库地址： https://github.com/unjs/h3，试想一下，当你想实现一个SSR HTTP服务时，需要做那些事？\n\n```javascript\n// 创建HTTP服务\nconst http = require('http')\n\n// 创建server\nconst server = http.createServer((req, res) => {\n  res.writeHead(200, { 'Content-Type': 'application/json' });\n  res.end(JSON.stringify({\n    data: 'Hello World!'\n  }));\n});\n\nserver.listen(8000);\n```\n\n当你有了一个服务之后，就需要根据req path去寻找对应源文件中的components。\n\n![image-20211227192318025](https://tva1.sinaimg.cn/large/008i3skNly1gxsm2snok3j31l807ewfd.jpg)\n\n\n\n对req path normalize的过程，发生在 **createServer** 第一个参数 Function 中。实际上，h3 这个库主要就是在做这个事情。总结一下，如下如：\n\n\n\n![image-20211227192326296](https://tva1.sinaimg.cn/large/008i3skNly1gxsm2xu7gtj31iu0hygmw.jpg)\n\n### 3. Nitro 核心模块\n\n```javascript\nexport * from './build'\nexport * from './context'\nexport * from './server/middleware'\nexport * from './server/dev'\nexport { wpfs } from './utils/wpfs'\n```\n\n梳理模块功能如下图所示：\n\n![image-20211227193521127](https://tva1.sinaimg.cn/large/008i3skNly1gxsmfc33ycj319c0l2wg8.jpg)\n\n其中，中间件 Middleware 目前主要服务于开发环境下，server 端 Bundle 文件的热更新。详细代码如下：\n\n```javascript\n// 1. 初始化 worker\nfunction initWorker (filename): Promise<NitroWorker> {\n  return new Promise((resolve, reject) => {\n    const worker = new Worker(filename)\n    worker.once('exit', (code) => {\n      if (code) {\n        reject(new Error('[worker] exited with code: ' + code))\n      }\n    })\n    worker.on('error', (err) => {\n      console.error('[worker]', err)\n      err.message = '[worker] ' + err.message\n      reject(err)\n    })\n    worker.on('message', (event) => {\n      if (event && event.address) {\n        resolve({\n          worker,\n          address: event.address\n        } as NitroWorker)\n      }\n    })\n  })\n}\n\n// 2. 观察更新\nfunction watch () {\n  if (watcher) { return }\n  const dReload = \n        debounce(() => \n                 reload().catch(console.warn), \n                 200, \n                 { before: true })\n  watcher = chokidar.watch([\n    resolve(nitroContext.output.serverDir, pattern),\n    resolve(nitroContext._nuxt.buildDir, 'dist/server', pattern)\n  ]).on('all', \n        event => events.includes(event) && dReload()\n  )\n}\n\n// 3. 执行更新\nasync function reload () {\n  // Create a new worker\n  const newWorker = await initWorker(workerEntry)\n\n  // Kill old worker in background\n  killWorker(currentWorker).catch(err => console.error(err))\n\n  // Replace new worker as current\n  currentWorker = newWorker\n}\n```\n\n从上述代码中我们可以看到，当你 **dist/server** 文件下内容发生更新，会触发 watch 监听，并执行 reload 操作。此时，用到了一个 node 原生模块 **worker_threads** 。\n\n\n\n### 4. 聊聊 worker_threads\n\nNode 创建多个workers有如下几种方式：\n\n- 利用 child_process 创建子进程，子进程拥有独立的 V8 和 Libuv，父子之间可以通讯。 \n\n- 基于 child_process 利用CPU多核提供可负载均衡集中式管理 Cluster，父子之间可以通讯，内存不共享，但是子进程间是不能通讯的。\n\n- 利用worker_threads创建多个workers是可以实现内存共享的，因为在创建worker_threads worker 同时，底层 C++ 创建的是 **V8 Isolates**，它是一个独立的 chrome V8 运行实例，其有独立的 JS 堆和微任务队列。这就为每一个 Node.js worker 独立运行提供了保障。其缺陷就是，workers 之间没法直接访问对方的堆。由于这个原因，每个 worker 都有其自己的 [libuv](https://link.zhihu.com/?target=https%3A//github.com/libuv/libuv) event loop。\n\n  \n\n![image-20211227193553758](https://tva1.sinaimg.cn/large/008i3skNly1gxsmfwaha0j30y80u0tav.jpg)\n\n\n\n#### 4.1 **初始化阶段**\n\n1. 用户空间的脚本通过 `worker_threads` 模块创建一个 worker 实例\n2. Node.js 的 parent worker 初始化脚本调用 C++ 模块，创建一个空的 C++ worker 对象。\n3. 当 C++ worker 对象被创建后，它生成一个线程 ID 并分配给自己\n4. 当 worker 对象被创建的时候，parent worker 会初创建一个空的始化信道（让我们称它为 `IMC`）。就是上面图二的 “Initialisation Message Channel”\n5. Node.js 的 parent worker 初始化脚本创建一个公共的 JS 信道（让我们称它为 `PMC`）。该信道是给用户空间的 JS 使用的，便于他们在 parent worker 和 child worker 之间通过 `*.postMessage()` 方法来传递消息。就是上面图一和图二的红色部分\n6. Node.js 的 parent worker 初始化脚本调用 C++ 模块，将初始化的 metadata 写入 IMC 来传递给 worker 的执行脚本。\n\n#### 4.2 **运行阶段**\n\n此时，初始化阶段完成。然后，就会调用 C++ 来启动这个 worker 线程。\n\n1. 一个新的 v8 isolate 被创建并分配给这个 worker。这使得该 worker 可以拥有自己的运行时环境\n2. libuv 被初始化。这使得该 worker 可以拥有自己的 event loop\n3. Worker 初始化脚本被执行，启动 worker 的 event loop\n4. Worker 初始化脚本 调用 C++ 模块从 IMC 读取初始化 metadata\n5. Worker 执行脚本在 worker 中运行代码文件或代码片段。在我们的例子中就是 `worker-simple.js`\n\n\n\n## 四. Nuxt Bridge\n\nBridge 是一个向前兼容层，它允许您通过简单地安装和启用 Nuxt 模块来体验许多新的 Nuxt 3 功能。\n\n使用 Nuxt Bridge，您可以确保您的项目（几乎）为 Nuxt 3 做好准备，并拥有最佳的开发人员体验，而无需进行重大重写或冒险更改。\n\n建议参考一下官网文档： https://v3.nuxtjs.org/getting-started/bridge\n\n\n\n## 五. 结束语\n\nNuxt 3 目前仍处于Beta阶段，h3 & Nitro 仍在不断适配中，所以不建议应用于生产环境。作为学习，当我们透过本质去回忆 SSR 实现的全过程，那么 Nuxt 3 源码部分就不会生涩难懂。Nuxt 不仅仅是搬运了其他框架的优势，自己在内部也有很多比较有意思的实现。比如 mini 版本的 tapable。在Nuxt 2中定义为 Hable。它贯穿了整个 Nuxt 实例化后的生命周期。有兴趣的同学我们可以一起探索学习一下~","source":"_posts/Nuxt3.md","raw":"---\ntitle: Nuxt 3 概述\ntags: vue\n---\n\n# Nuxt 3 概述\n\n\n\n## 一.  Nuxt 框架\n\n\n\n### 1. 概述\n\n**Nuxt 当前版本介绍：** Build your next Vue.js application with confidence using Nuxt. An open source framework making web development simple and powerful.\n\n**Nuxt 3 新版本介绍：**Build your next application with Vue 3 and experience hybrid rendering, powerful data fetching and new features. Nuxt 3 is an open source framework making web development simple and powerful.\n\n**Nuxt** 框架，是一个集百家之所长，可以让开发者不用关心同构、注水等 **SSR** 细节，快速构建**WEB**应用的一个开源框架。**Nuxt3** 基于**vue3.0** 版本的一些新的特性，相比于nuxt之前版本，提供更快、更强、更轻量的能力。\n\n\n\n### 2. 版本更新概述\n\n- Webpack 5 and Vite 支持\n- PostCSS 8\n- rollup-plugin-esbuild 融合了 Esbuild、Rollup等优秀特性\n- Vue-bundle-renderer 基于 vue ssr 官方提供的基础API \n- 基于 Composition API\n\n\n\n### 3. Nuxt 3 工程\n\n**仓库地址：** https://github.com/nuxt/framework\n\n**工程结构简述：**\n\n![image-20211227192251521](https://tva1.sinaimg.cn/large/008i3skNly1gxsm2c2ar5j31i40ts41k.jpg)\n\n\n\n## 二. SSR 简史\n\n\n\n### 1. web 1.0 时代\n\n\n\n![image-20211213194138296](https://tva1.sinaimg.cn/large/008i3skNly1gxgtwi248qj315h0n9mye.jpg)\n\n\n\n| 优势       | 劣势                                 |\n| ---------- | ------------------------------------ |\n| 更好的SEO  | 协同开发困难                         |\n| FCP 耗时短 | 服务端对数据库频繁操作带来的性能损耗 |\n\n\n\n### 2. SSR\n\n> CSR: 客户端渲染(Client Side Render)\n\n伴随着AJAX技术的不断发展，渐渐出现前后端分离、CSR 慢慢进入到了公众的视野。但是随着业务不断的繁重，打包编译后的Bundle文件随着代码量的增加，业务功能渐渐丰满，无脑引入第三方开源库，很快变成一个巨婴项目。\n\n此时，SSR （ Server Side Rendering ）重新被提起和认识。\n\n![image-20211213194213452](https://tva1.sinaimg.cn/large/008i3skNly1gxgtwu4q0ij315l0msmyq.jpg)\n\n\n\n![image-20211213195240072](https://tva1.sinaimg.cn/large/008i3skNly1gxgtx3h2i6j315l0ll75r.jpg)\n\n\n\n#### 2.1 概念说明\n\n| 概念（行话、黑话） | 含义                                                         |\n| ------------------ | :----------------------------------------------------------- |\n| 注水               | 抵达客户端后，会将一部分数据、DOM结构体等注入到HTML页面中    |\n| 吸水               | 抵达客户端后，当期环境运行javascript脚本，发起第二次增量渲染 |\n| 脱水               | 使其在恶劣的环境同样能够以一种更简单的形态“生存”下来，比如禁用了 JavaScript 的客户端环境，脱去生命的水气（动态数据），成为风干标本一样的静态快照。 |\n| 同构               | 当我们有且只有一份源代码，要实现不同环境的运行要求所采取的一种构建方式；例如：客户端运行的Bundle需要适配低版本浏览器，转成ES5代码；服务端Bundle不需要进行代码混淆压缩；服务端Bundle不需要安装css-loader等插件。 |\n\n#### 2.2 流行框架支持\n\n![image-20211213195907961](https://tva1.sinaimg.cn/large/008i3skNly1gxgtxf5flbj315y0iwjsr.jpg)\n\n#### 2.3 Nuxt 3 举例\n\n![image-20211213200008949](https://tva1.sinaimg.cn/large/008i3skNly1gxgtxkxq9aj316c0nsq8e.jpg)\n\n## 三. Nitro 服务引擎\n\n\n\n### 1. Nitro 简介\n\nNuxt 的新服务器引擎，Nuxt研发团队历时 9 个月，解锁的服务引擎。实现类似于 Next.js 中 API 路由。在生产中，它将您的应用程序和服务器构建到一个通用[`.output` ](https://v3.nuxtjs.org/docs/directory-structure/output)目录中。此**输出很轻**：从任何 Node.js 模块（polyfill 除外）中缩小并删除。您可以将此输出部署到任何支持 JavaScript 的系统上，从 Node.js、Serverless、Workers、或纯静态。Nitro 服务器的基础是 rollup 和[h3](https://github.com/unjs/h3)：为高性能和可移植性而构建的最小 http 框架，如下图，Nitro 实际上相当于下图红色框部分。\n\n![image-20211213223119233](https://tva1.sinaimg.cn/large/008i3skNly1gxgtxt92n9j31h20u076z.jpg)\n\n\n\n### 2. h3 概述\n\nNitro 核心基于h3， 仓库地址： https://github.com/unjs/h3，试想一下，当你想实现一个SSR HTTP服务时，需要做那些事？\n\n```javascript\n// 创建HTTP服务\nconst http = require('http')\n\n// 创建server\nconst server = http.createServer((req, res) => {\n  res.writeHead(200, { 'Content-Type': 'application/json' });\n  res.end(JSON.stringify({\n    data: 'Hello World!'\n  }));\n});\n\nserver.listen(8000);\n```\n\n当你有了一个服务之后，就需要根据req path去寻找对应源文件中的components。\n\n![image-20211227192318025](https://tva1.sinaimg.cn/large/008i3skNly1gxsm2snok3j31l807ewfd.jpg)\n\n\n\n对req path normalize的过程，发生在 **createServer** 第一个参数 Function 中。实际上，h3 这个库主要就是在做这个事情。总结一下，如下如：\n\n\n\n![image-20211227192326296](https://tva1.sinaimg.cn/large/008i3skNly1gxsm2xu7gtj31iu0hygmw.jpg)\n\n### 3. Nitro 核心模块\n\n```javascript\nexport * from './build'\nexport * from './context'\nexport * from './server/middleware'\nexport * from './server/dev'\nexport { wpfs } from './utils/wpfs'\n```\n\n梳理模块功能如下图所示：\n\n![image-20211227193521127](https://tva1.sinaimg.cn/large/008i3skNly1gxsmfc33ycj319c0l2wg8.jpg)\n\n其中，中间件 Middleware 目前主要服务于开发环境下，server 端 Bundle 文件的热更新。详细代码如下：\n\n```javascript\n// 1. 初始化 worker\nfunction initWorker (filename): Promise<NitroWorker> {\n  return new Promise((resolve, reject) => {\n    const worker = new Worker(filename)\n    worker.once('exit', (code) => {\n      if (code) {\n        reject(new Error('[worker] exited with code: ' + code))\n      }\n    })\n    worker.on('error', (err) => {\n      console.error('[worker]', err)\n      err.message = '[worker] ' + err.message\n      reject(err)\n    })\n    worker.on('message', (event) => {\n      if (event && event.address) {\n        resolve({\n          worker,\n          address: event.address\n        } as NitroWorker)\n      }\n    })\n  })\n}\n\n// 2. 观察更新\nfunction watch () {\n  if (watcher) { return }\n  const dReload = \n        debounce(() => \n                 reload().catch(console.warn), \n                 200, \n                 { before: true })\n  watcher = chokidar.watch([\n    resolve(nitroContext.output.serverDir, pattern),\n    resolve(nitroContext._nuxt.buildDir, 'dist/server', pattern)\n  ]).on('all', \n        event => events.includes(event) && dReload()\n  )\n}\n\n// 3. 执行更新\nasync function reload () {\n  // Create a new worker\n  const newWorker = await initWorker(workerEntry)\n\n  // Kill old worker in background\n  killWorker(currentWorker).catch(err => console.error(err))\n\n  // Replace new worker as current\n  currentWorker = newWorker\n}\n```\n\n从上述代码中我们可以看到，当你 **dist/server** 文件下内容发生更新，会触发 watch 监听，并执行 reload 操作。此时，用到了一个 node 原生模块 **worker_threads** 。\n\n\n\n### 4. 聊聊 worker_threads\n\nNode 创建多个workers有如下几种方式：\n\n- 利用 child_process 创建子进程，子进程拥有独立的 V8 和 Libuv，父子之间可以通讯。 \n\n- 基于 child_process 利用CPU多核提供可负载均衡集中式管理 Cluster，父子之间可以通讯，内存不共享，但是子进程间是不能通讯的。\n\n- 利用worker_threads创建多个workers是可以实现内存共享的，因为在创建worker_threads worker 同时，底层 C++ 创建的是 **V8 Isolates**，它是一个独立的 chrome V8 运行实例，其有独立的 JS 堆和微任务队列。这就为每一个 Node.js worker 独立运行提供了保障。其缺陷就是，workers 之间没法直接访问对方的堆。由于这个原因，每个 worker 都有其自己的 [libuv](https://link.zhihu.com/?target=https%3A//github.com/libuv/libuv) event loop。\n\n  \n\n![image-20211227193553758](https://tva1.sinaimg.cn/large/008i3skNly1gxsmfwaha0j30y80u0tav.jpg)\n\n\n\n#### 4.1 **初始化阶段**\n\n1. 用户空间的脚本通过 `worker_threads` 模块创建一个 worker 实例\n2. Node.js 的 parent worker 初始化脚本调用 C++ 模块，创建一个空的 C++ worker 对象。\n3. 当 C++ worker 对象被创建后，它生成一个线程 ID 并分配给自己\n4. 当 worker 对象被创建的时候，parent worker 会初创建一个空的始化信道（让我们称它为 `IMC`）。就是上面图二的 “Initialisation Message Channel”\n5. Node.js 的 parent worker 初始化脚本创建一个公共的 JS 信道（让我们称它为 `PMC`）。该信道是给用户空间的 JS 使用的，便于他们在 parent worker 和 child worker 之间通过 `*.postMessage()` 方法来传递消息。就是上面图一和图二的红色部分\n6. Node.js 的 parent worker 初始化脚本调用 C++ 模块，将初始化的 metadata 写入 IMC 来传递给 worker 的执行脚本。\n\n#### 4.2 **运行阶段**\n\n此时，初始化阶段完成。然后，就会调用 C++ 来启动这个 worker 线程。\n\n1. 一个新的 v8 isolate 被创建并分配给这个 worker。这使得该 worker 可以拥有自己的运行时环境\n2. libuv 被初始化。这使得该 worker 可以拥有自己的 event loop\n3. Worker 初始化脚本被执行，启动 worker 的 event loop\n4. Worker 初始化脚本 调用 C++ 模块从 IMC 读取初始化 metadata\n5. Worker 执行脚本在 worker 中运行代码文件或代码片段。在我们的例子中就是 `worker-simple.js`\n\n\n\n## 四. Nuxt Bridge\n\nBridge 是一个向前兼容层，它允许您通过简单地安装和启用 Nuxt 模块来体验许多新的 Nuxt 3 功能。\n\n使用 Nuxt Bridge，您可以确保您的项目（几乎）为 Nuxt 3 做好准备，并拥有最佳的开发人员体验，而无需进行重大重写或冒险更改。\n\n建议参考一下官网文档： https://v3.nuxtjs.org/getting-started/bridge\n\n\n\n## 五. 结束语\n\nNuxt 3 目前仍处于Beta阶段，h3 & Nitro 仍在不断适配中，所以不建议应用于生产环境。作为学习，当我们透过本质去回忆 SSR 实现的全过程，那么 Nuxt 3 源码部分就不会生涩难懂。Nuxt 不仅仅是搬运了其他框架的优势，自己在内部也有很多比较有意思的实现。比如 mini 版本的 tapable。在Nuxt 2中定义为 Hable。它贯穿了整个 Nuxt 实例化后的生命周期。有兴趣的同学我们可以一起探索学习一下~","slug":"Nuxt3","published":1,"date":"2021-12-09T13:17:53.715Z","updated":"2021-12-28T02:07:06.015Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxph7qmb00091op72hoig3vd","content":"<h1 id=\"Nuxt-3-概述\"><a href=\"#Nuxt-3-概述\" class=\"headerlink\" title=\"Nuxt 3 概述\"></a>Nuxt 3 概述</h1><h2 id=\"一-Nuxt-框架\"><a href=\"#一-Nuxt-框架\" class=\"headerlink\" title=\"一.  Nuxt 框架\"></a>一.  Nuxt 框架</h2><h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h3><p><strong>Nuxt 当前版本介绍：</strong> Build your next Vue.js application with confidence using Nuxt. An open source framework making web development simple and powerful.</p>\n<p><strong>Nuxt 3 新版本介绍：</strong>Build your next application with Vue 3 and experience hybrid rendering, powerful data fetching and new features. Nuxt 3 is an open source framework making web development simple and powerful.</p>\n<p><strong>Nuxt</strong> 框架，是一个集百家之所长，可以让开发者不用关心同构、注水等 <strong>SSR</strong> 细节，快速构建<strong>WEB</strong>应用的一个开源框架。<strong>Nuxt3</strong> 基于<strong>vue3.0</strong> 版本的一些新的特性，相比于nuxt之前版本，提供更快、更强、更轻量的能力。</p>\n<h3 id=\"2-版本更新概述\"><a href=\"#2-版本更新概述\" class=\"headerlink\" title=\"2. 版本更新概述\"></a>2. 版本更新概述</h3><ul>\n<li>Webpack 5 and Vite 支持</li>\n<li>PostCSS 8</li>\n<li>rollup-plugin-esbuild 融合了 Esbuild、Rollup等优秀特性</li>\n<li>Vue-bundle-renderer 基于 vue ssr 官方提供的基础API </li>\n<li>基于 Composition API</li>\n</ul>\n<h3 id=\"3-Nuxt-3-工程\"><a href=\"#3-Nuxt-3-工程\" class=\"headerlink\" title=\"3. Nuxt 3 工程\"></a>3. Nuxt 3 工程</h3><p><strong>仓库地址：</strong> <a href=\"https://github.com/nuxt/framework\">https://github.com/nuxt/framework</a></p>\n<p><strong>工程结构简述：</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsm2c2ar5j31i40ts41k.jpg\" alt=\"image-20211227192251521\"></p>\n<h2 id=\"二-SSR-简史\"><a href=\"#二-SSR-简史\" class=\"headerlink\" title=\"二. SSR 简史\"></a>二. SSR 简史</h2><h3 id=\"1-web-1-0-时代\"><a href=\"#1-web-1-0-时代\" class=\"headerlink\" title=\"1. web 1.0 时代\"></a>1. web 1.0 时代</h3><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxgtwi248qj315h0n9mye.jpg\" alt=\"image-20211213194138296\"></p>\n<table>\n<thead>\n<tr>\n<th>优势</th>\n<th>劣势</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>更好的SEO</td>\n<td>协同开发困难</td>\n</tr>\n<tr>\n<td>FCP 耗时短</td>\n<td>服务端对数据库频繁操作带来的性能损耗</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-SSR\"><a href=\"#2-SSR\" class=\"headerlink\" title=\"2. SSR\"></a>2. SSR</h3><blockquote>\n<p>CSR: 客户端渲染(Client Side Render)</p>\n</blockquote>\n<p>伴随着AJAX技术的不断发展，渐渐出现前后端分离、CSR 慢慢进入到了公众的视野。但是随着业务不断的繁重，打包编译后的Bundle文件随着代码量的增加，业务功能渐渐丰满，无脑引入第三方开源库，很快变成一个巨婴项目。</p>\n<p>此时，SSR （ Server Side Rendering ）重新被提起和认识。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxgtwu4q0ij315l0msmyq.jpg\" alt=\"image-20211213194213452\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxgtx3h2i6j315l0ll75r.jpg\" alt=\"image-20211213195240072\"></p>\n<h4 id=\"2-1-概念说明\"><a href=\"#2-1-概念说明\" class=\"headerlink\" title=\"2.1 概念说明\"></a>2.1 概念说明</h4><table>\n<thead>\n<tr>\n<th>概念（行话、黑话）</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>注水</td>\n<td align=\"left\">抵达客户端后，会将一部分数据、DOM结构体等注入到HTML页面中</td>\n</tr>\n<tr>\n<td>吸水</td>\n<td align=\"left\">抵达客户端后，当期环境运行javascript脚本，发起第二次增量渲染</td>\n</tr>\n<tr>\n<td>脱水</td>\n<td align=\"left\">使其在恶劣的环境同样能够以一种更简单的形态“生存”下来，比如禁用了 JavaScript 的客户端环境，脱去生命的水气（动态数据），成为风干标本一样的静态快照。</td>\n</tr>\n<tr>\n<td>同构</td>\n<td align=\"left\">当我们有且只有一份源代码，要实现不同环境的运行要求所采取的一种构建方式；例如：客户端运行的Bundle需要适配低版本浏览器，转成ES5代码；服务端Bundle不需要进行代码混淆压缩；服务端Bundle不需要安装css-loader等插件。</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-2-流行框架支持\"><a href=\"#2-2-流行框架支持\" class=\"headerlink\" title=\"2.2 流行框架支持\"></a>2.2 流行框架支持</h4><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxgtxf5flbj315y0iwjsr.jpg\" alt=\"image-20211213195907961\"></p>\n<h4 id=\"2-3-Nuxt-3-举例\"><a href=\"#2-3-Nuxt-3-举例\" class=\"headerlink\" title=\"2.3 Nuxt 3 举例\"></a>2.3 Nuxt 3 举例</h4><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxgtxkxq9aj316c0nsq8e.jpg\" alt=\"image-20211213200008949\"></p>\n<h2 id=\"三-Nitro-服务引擎\"><a href=\"#三-Nitro-服务引擎\" class=\"headerlink\" title=\"三. Nitro 服务引擎\"></a>三. Nitro 服务引擎</h2><h3 id=\"1-Nitro-简介\"><a href=\"#1-Nitro-简介\" class=\"headerlink\" title=\"1. Nitro 简介\"></a>1. Nitro 简介</h3><p>Nuxt 的新服务器引擎，Nuxt研发团队历时 9 个月，解锁的服务引擎。实现类似于 Next.js 中 API 路由。在生产中，它将您的应用程序和服务器构建到一个通用<a href=\"https://v3.nuxtjs.org/docs/directory-structure/output\"><code>.output</code> </a>目录中。此<strong>输出很轻</strong>：从任何 Node.js 模块（polyfill 除外）中缩小并删除。您可以将此输出部署到任何支持 JavaScript 的系统上，从 Node.js、Serverless、Workers、或纯静态。Nitro 服务器的基础是 rollup 和<a href=\"https://github.com/unjs/h3\">h3</a>：为高性能和可移植性而构建的最小 http 框架，如下图，Nitro 实际上相当于下图红色框部分。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxgtxt92n9j31h20u076z.jpg\" alt=\"image-20211213223119233\"></p>\n<h3 id=\"2-h3-概述\"><a href=\"#2-h3-概述\" class=\"headerlink\" title=\"2. h3 概述\"></a>2. h3 概述</h3><p>Nitro 核心基于h3， 仓库地址： <a href=\"https://github.com/unjs/h3%EF%BC%8C%E8%AF%95%E6%83%B3%E4%B8%80%E4%B8%8B%EF%BC%8C%E5%BD%93%E4%BD%A0%E6%83%B3%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AASSR\">https://github.com/unjs/h3，试想一下，当你想实现一个SSR</a> HTTP服务时，需要做那些事？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建HTTP服务</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建server</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = http.createServer(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  res.writeHead(<span class=\"number\">200</span>, &#123; <span class=\"string\">&#x27;Content-Type&#x27;</span>: <span class=\"string\">&#x27;application/json&#x27;</span> &#125;);</span><br><span class=\"line\">  res.end(<span class=\"built_in\">JSON</span>.stringify(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: <span class=\"string\">&#x27;Hello World!&#x27;</span></span><br><span class=\"line\">  &#125;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>当你有了一个服务之后，就需要根据req path去寻找对应源文件中的components。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsm2snok3j31l807ewfd.jpg\" alt=\"image-20211227192318025\"></p>\n<p>对req path normalize的过程，发生在 <strong>createServer</strong> 第一个参数 Function 中。实际上，h3 这个库主要就是在做这个事情。总结一下，如下如：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsm2xu7gtj31iu0hygmw.jpg\" alt=\"image-20211227192326296\"></p>\n<h3 id=\"3-Nitro-核心模块\"><a href=\"#3-Nitro-核心模块\" class=\"headerlink\" title=\"3. Nitro 核心模块\"></a>3. Nitro 核心模块</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./build&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./context&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./server/middleware&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./server/dev&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; wpfs &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./utils/wpfs&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>梳理模块功能如下图所示：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsmfc33ycj319c0l2wg8.jpg\" alt=\"image-20211227193521127\"></p>\n<p>其中，中间件 Middleware 目前主要服务于开发环境下，server 端 Bundle 文件的热更新。详细代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 初始化 worker</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initWorker</span> (<span class=\"params\">filename</span>): <span class=\"title\">Promise</span>&lt;<span class=\"title\">NitroWorker</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> worker = <span class=\"keyword\">new</span> Worker(filename)</span><br><span class=\"line\">    worker.once(<span class=\"string\">&#x27;exit&#x27;</span>, <span class=\"function\">(<span class=\"params\">code</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (code) &#123;</span><br><span class=\"line\">        reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;[worker] exited with code: &#x27;</span> + code))</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    worker.on(<span class=\"string\">&#x27;error&#x27;</span>, <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">&#x27;[worker]&#x27;</span>, err)</span><br><span class=\"line\">      err.message = <span class=\"string\">&#x27;[worker] &#x27;</span> + err.message</span><br><span class=\"line\">      reject(err)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    worker.on(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (event &amp;&amp; event.address) &#123;</span><br><span class=\"line\">        resolve(&#123;</span><br><span class=\"line\">          worker,</span><br><span class=\"line\">          <span class=\"attr\">address</span>: event.address</span><br><span class=\"line\">        &#125; <span class=\"keyword\">as</span> NitroWorker)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 观察更新</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">watch</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (watcher) &#123; <span class=\"keyword\">return</span> &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dReload = </span><br><span class=\"line\">        debounce(<span class=\"function\">() =&gt;</span> </span><br><span class=\"line\">                 reload().catch(<span class=\"built_in\">console</span>.warn), </span><br><span class=\"line\">                 <span class=\"number\">200</span>, </span><br><span class=\"line\">                 &#123; <span class=\"attr\">before</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">  watcher = chokidar.watch([</span><br><span class=\"line\">    resolve(nitroContext.output.serverDir, pattern),</span><br><span class=\"line\">    resolve(nitroContext._nuxt.buildDir, <span class=\"string\">&#x27;dist/server&#x27;</span>, pattern)</span><br><span class=\"line\">  ]).on(<span class=\"string\">&#x27;all&#x27;</span>, </span><br><span class=\"line\">        <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> events.includes(event) &amp;&amp; dReload()</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 执行更新</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reload</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Create a new worker</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> newWorker = <span class=\"keyword\">await</span> initWorker(workerEntry)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Kill old worker in background</span></span><br><span class=\"line\">  killWorker(currentWorker).catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.error(err))</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Replace new worker as current</span></span><br><span class=\"line\">  currentWorker = newWorker</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上述代码中我们可以看到，当你 <strong>dist/server</strong> 文件下内容发生更新，会触发 watch 监听，并执行 reload 操作。此时，用到了一个 node 原生模块 <strong>worker_threads</strong> 。</p>\n<h3 id=\"4-聊聊-worker-threads\"><a href=\"#4-聊聊-worker-threads\" class=\"headerlink\" title=\"4. 聊聊 worker_threads\"></a>4. 聊聊 worker_threads</h3><p>Node 创建多个workers有如下几种方式：</p>\n<ul>\n<li><p>利用 child_process 创建子进程，子进程拥有独立的 V8 和 Libuv，父子之间可以通讯。 </p>\n</li>\n<li><p>基于 child_process 利用CPU多核提供可负载均衡集中式管理 Cluster，父子之间可以通讯，内存不共享，但是子进程间是不能通讯的。</p>\n</li>\n<li><p>利用worker_threads创建多个workers是可以实现内存共享的，因为在创建worker_threads worker 同时，底层 C++ 创建的是 <strong>V8 Isolates</strong>，它是一个独立的 chrome V8 运行实例，其有独立的 JS 堆和微任务队列。这就为每一个 Node.js worker 独立运行提供了保障。其缺陷就是，workers 之间没法直接访问对方的堆。由于这个原因，每个 worker 都有其自己的 <a href=\"https://link.zhihu.com/?target=https://github.com/libuv/libuv\">libuv</a> event loop。</p>\n</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsmfwaha0j30y80u0tav.jpg\" alt=\"image-20211227193553758\"></p>\n<h4 id=\"4-1-初始化阶段\"><a href=\"#4-1-初始化阶段\" class=\"headerlink\" title=\"4.1 初始化阶段\"></a>4.1 <strong>初始化阶段</strong></h4><ol>\n<li>用户空间的脚本通过 <code>worker_threads</code> 模块创建一个 worker 实例</li>\n<li>Node.js 的 parent worker 初始化脚本调用 C++ 模块，创建一个空的 C++ worker 对象。</li>\n<li>当 C++ worker 对象被创建后，它生成一个线程 ID 并分配给自己</li>\n<li>当 worker 对象被创建的时候，parent worker 会初创建一个空的始化信道（让我们称它为 <code>IMC</code>）。就是上面图二的 “Initialisation Message Channel”</li>\n<li>Node.js 的 parent worker 初始化脚本创建一个公共的 JS 信道（让我们称它为 <code>PMC</code>）。该信道是给用户空间的 JS 使用的，便于他们在 parent worker 和 child worker 之间通过 <code>*.postMessage()</code> 方法来传递消息。就是上面图一和图二的红色部分</li>\n<li>Node.js 的 parent worker 初始化脚本调用 C++ 模块，将初始化的 metadata 写入 IMC 来传递给 worker 的执行脚本。</li>\n</ol>\n<h4 id=\"4-2-运行阶段\"><a href=\"#4-2-运行阶段\" class=\"headerlink\" title=\"4.2 运行阶段\"></a>4.2 <strong>运行阶段</strong></h4><p>此时，初始化阶段完成。然后，就会调用 C++ 来启动这个 worker 线程。</p>\n<ol>\n<li>一个新的 v8 isolate 被创建并分配给这个 worker。这使得该 worker 可以拥有自己的运行时环境</li>\n<li>libuv 被初始化。这使得该 worker 可以拥有自己的 event loop</li>\n<li>Worker 初始化脚本被执行，启动 worker 的 event loop</li>\n<li>Worker 初始化脚本 调用 C++ 模块从 IMC 读取初始化 metadata</li>\n<li>Worker 执行脚本在 worker 中运行代码文件或代码片段。在我们的例子中就是 <code>worker-simple.js</code></li>\n</ol>\n<h2 id=\"四-Nuxt-Bridge\"><a href=\"#四-Nuxt-Bridge\" class=\"headerlink\" title=\"四. Nuxt Bridge\"></a>四. Nuxt Bridge</h2><p>Bridge 是一个向前兼容层，它允许您通过简单地安装和启用 Nuxt 模块来体验许多新的 Nuxt 3 功能。</p>\n<p>使用 Nuxt Bridge，您可以确保您的项目（几乎）为 Nuxt 3 做好准备，并拥有最佳的开发人员体验，而无需进行重大重写或冒险更改。</p>\n<p>建议参考一下官网文档： <a href=\"https://v3.nuxtjs.org/getting-started/bridge\">https://v3.nuxtjs.org/getting-started/bridge</a></p>\n<h2 id=\"五-结束语\"><a href=\"#五-结束语\" class=\"headerlink\" title=\"五. 结束语\"></a>五. 结束语</h2><p>Nuxt 3 目前仍处于Beta阶段，h3 &amp; Nitro 仍在不断适配中，所以不建议应用于生产环境。作为学习，当我们透过本质去回忆 SSR 实现的全过程，那么 Nuxt 3 源码部分就不会生涩难懂。Nuxt 不仅仅是搬运了其他框架的优势，自己在内部也有很多比较有意思的实现。比如 mini 版本的 tapable。在Nuxt 2中定义为 Hable。它贯穿了整个 Nuxt 实例化后的生命周期。有兴趣的同学我们可以一起探索学习一下~</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Nuxt-3-概述\"><a href=\"#Nuxt-3-概述\" class=\"headerlink\" title=\"Nuxt 3 概述\"></a>Nuxt 3 概述</h1><h2 id=\"一-Nuxt-框架\"><a href=\"#一-Nuxt-框架\" class=\"headerlink\" title=\"一.  Nuxt 框架\"></a>一.  Nuxt 框架</h2><h3 id=\"1-概述\"><a href=\"#1-概述\" class=\"headerlink\" title=\"1. 概述\"></a>1. 概述</h3><p><strong>Nuxt 当前版本介绍：</strong> Build your next Vue.js application with confidence using Nuxt. An open source framework making web development simple and powerful.</p>\n<p><strong>Nuxt 3 新版本介绍：</strong>Build your next application with Vue 3 and experience hybrid rendering, powerful data fetching and new features. Nuxt 3 is an open source framework making web development simple and powerful.</p>\n<p><strong>Nuxt</strong> 框架，是一个集百家之所长，可以让开发者不用关心同构、注水等 <strong>SSR</strong> 细节，快速构建<strong>WEB</strong>应用的一个开源框架。<strong>Nuxt3</strong> 基于<strong>vue3.0</strong> 版本的一些新的特性，相比于nuxt之前版本，提供更快、更强、更轻量的能力。</p>\n<h3 id=\"2-版本更新概述\"><a href=\"#2-版本更新概述\" class=\"headerlink\" title=\"2. 版本更新概述\"></a>2. 版本更新概述</h3><ul>\n<li>Webpack 5 and Vite 支持</li>\n<li>PostCSS 8</li>\n<li>rollup-plugin-esbuild 融合了 Esbuild、Rollup等优秀特性</li>\n<li>Vue-bundle-renderer 基于 vue ssr 官方提供的基础API </li>\n<li>基于 Composition API</li>\n</ul>\n<h3 id=\"3-Nuxt-3-工程\"><a href=\"#3-Nuxt-3-工程\" class=\"headerlink\" title=\"3. Nuxt 3 工程\"></a>3. Nuxt 3 工程</h3><p><strong>仓库地址：</strong> <a href=\"https://github.com/nuxt/framework\">https://github.com/nuxt/framework</a></p>\n<p><strong>工程结构简述：</strong></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsm2c2ar5j31i40ts41k.jpg\" alt=\"image-20211227192251521\"></p>\n<h2 id=\"二-SSR-简史\"><a href=\"#二-SSR-简史\" class=\"headerlink\" title=\"二. SSR 简史\"></a>二. SSR 简史</h2><h3 id=\"1-web-1-0-时代\"><a href=\"#1-web-1-0-时代\" class=\"headerlink\" title=\"1. web 1.0 时代\"></a>1. web 1.0 时代</h3><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxgtwi248qj315h0n9mye.jpg\" alt=\"image-20211213194138296\"></p>\n<table>\n<thead>\n<tr>\n<th>优势</th>\n<th>劣势</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>更好的SEO</td>\n<td>协同开发困难</td>\n</tr>\n<tr>\n<td>FCP 耗时短</td>\n<td>服务端对数据库频繁操作带来的性能损耗</td>\n</tr>\n</tbody></table>\n<h3 id=\"2-SSR\"><a href=\"#2-SSR\" class=\"headerlink\" title=\"2. SSR\"></a>2. SSR</h3><blockquote>\n<p>CSR: 客户端渲染(Client Side Render)</p>\n</blockquote>\n<p>伴随着AJAX技术的不断发展，渐渐出现前后端分离、CSR 慢慢进入到了公众的视野。但是随着业务不断的繁重，打包编译后的Bundle文件随着代码量的增加，业务功能渐渐丰满，无脑引入第三方开源库，很快变成一个巨婴项目。</p>\n<p>此时，SSR （ Server Side Rendering ）重新被提起和认识。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxgtwu4q0ij315l0msmyq.jpg\" alt=\"image-20211213194213452\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxgtx3h2i6j315l0ll75r.jpg\" alt=\"image-20211213195240072\"></p>\n<h4 id=\"2-1-概念说明\"><a href=\"#2-1-概念说明\" class=\"headerlink\" title=\"2.1 概念说明\"></a>2.1 概念说明</h4><table>\n<thead>\n<tr>\n<th>概念（行话、黑话）</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>注水</td>\n<td align=\"left\">抵达客户端后，会将一部分数据、DOM结构体等注入到HTML页面中</td>\n</tr>\n<tr>\n<td>吸水</td>\n<td align=\"left\">抵达客户端后，当期环境运行javascript脚本，发起第二次增量渲染</td>\n</tr>\n<tr>\n<td>脱水</td>\n<td align=\"left\">使其在恶劣的环境同样能够以一种更简单的形态“生存”下来，比如禁用了 JavaScript 的客户端环境，脱去生命的水气（动态数据），成为风干标本一样的静态快照。</td>\n</tr>\n<tr>\n<td>同构</td>\n<td align=\"left\">当我们有且只有一份源代码，要实现不同环境的运行要求所采取的一种构建方式；例如：客户端运行的Bundle需要适配低版本浏览器，转成ES5代码；服务端Bundle不需要进行代码混淆压缩；服务端Bundle不需要安装css-loader等插件。</td>\n</tr>\n</tbody></table>\n<h4 id=\"2-2-流行框架支持\"><a href=\"#2-2-流行框架支持\" class=\"headerlink\" title=\"2.2 流行框架支持\"></a>2.2 流行框架支持</h4><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxgtxf5flbj315y0iwjsr.jpg\" alt=\"image-20211213195907961\"></p>\n<h4 id=\"2-3-Nuxt-3-举例\"><a href=\"#2-3-Nuxt-3-举例\" class=\"headerlink\" title=\"2.3 Nuxt 3 举例\"></a>2.3 Nuxt 3 举例</h4><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxgtxkxq9aj316c0nsq8e.jpg\" alt=\"image-20211213200008949\"></p>\n<h2 id=\"三-Nitro-服务引擎\"><a href=\"#三-Nitro-服务引擎\" class=\"headerlink\" title=\"三. Nitro 服务引擎\"></a>三. Nitro 服务引擎</h2><h3 id=\"1-Nitro-简介\"><a href=\"#1-Nitro-简介\" class=\"headerlink\" title=\"1. Nitro 简介\"></a>1. Nitro 简介</h3><p>Nuxt 的新服务器引擎，Nuxt研发团队历时 9 个月，解锁的服务引擎。实现类似于 Next.js 中 API 路由。在生产中，它将您的应用程序和服务器构建到一个通用<a href=\"https://v3.nuxtjs.org/docs/directory-structure/output\"><code>.output</code> </a>目录中。此<strong>输出很轻</strong>：从任何 Node.js 模块（polyfill 除外）中缩小并删除。您可以将此输出部署到任何支持 JavaScript 的系统上，从 Node.js、Serverless、Workers、或纯静态。Nitro 服务器的基础是 rollup 和<a href=\"https://github.com/unjs/h3\">h3</a>：为高性能和可移植性而构建的最小 http 框架，如下图，Nitro 实际上相当于下图红色框部分。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxgtxt92n9j31h20u076z.jpg\" alt=\"image-20211213223119233\"></p>\n<h3 id=\"2-h3-概述\"><a href=\"#2-h3-概述\" class=\"headerlink\" title=\"2. h3 概述\"></a>2. h3 概述</h3><p>Nitro 核心基于h3， 仓库地址： <a href=\"https://github.com/unjs/h3%EF%BC%8C%E8%AF%95%E6%83%B3%E4%B8%80%E4%B8%8B%EF%BC%8C%E5%BD%93%E4%BD%A0%E6%83%B3%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AASSR\">https://github.com/unjs/h3，试想一下，当你想实现一个SSR</a> HTTP服务时，需要做那些事？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建HTTP服务</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建server</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = http.createServer(<span class=\"function\">(<span class=\"params\">req, res</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  res.writeHead(<span class=\"number\">200</span>, &#123; <span class=\"string\">&#x27;Content-Type&#x27;</span>: <span class=\"string\">&#x27;application/json&#x27;</span> &#125;);</span><br><span class=\"line\">  res.end(<span class=\"built_in\">JSON</span>.stringify(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: <span class=\"string\">&#x27;Hello World!&#x27;</span></span><br><span class=\"line\">  &#125;));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>当你有了一个服务之后，就需要根据req path去寻找对应源文件中的components。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsm2snok3j31l807ewfd.jpg\" alt=\"image-20211227192318025\"></p>\n<p>对req path normalize的过程，发生在 <strong>createServer</strong> 第一个参数 Function 中。实际上，h3 这个库主要就是在做这个事情。总结一下，如下如：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsm2xu7gtj31iu0hygmw.jpg\" alt=\"image-20211227192326296\"></p>\n<h3 id=\"3-Nitro-核心模块\"><a href=\"#3-Nitro-核心模块\" class=\"headerlink\" title=\"3. Nitro 核心模块\"></a>3. Nitro 核心模块</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./build&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./context&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./server/middleware&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> * <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./server/dev&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> &#123; wpfs &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;./utils/wpfs&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>梳理模块功能如下图所示：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsmfc33ycj319c0l2wg8.jpg\" alt=\"image-20211227193521127\"></p>\n<p>其中，中间件 Middleware 目前主要服务于开发环境下，server 端 Bundle 文件的热更新。详细代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 初始化 worker</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">initWorker</span> (<span class=\"params\">filename</span>): <span class=\"title\">Promise</span>&lt;<span class=\"title\">NitroWorker</span>&gt; </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> worker = <span class=\"keyword\">new</span> Worker(filename)</span><br><span class=\"line\">    worker.once(<span class=\"string\">&#x27;exit&#x27;</span>, <span class=\"function\">(<span class=\"params\">code</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (code) &#123;</span><br><span class=\"line\">        reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&#x27;[worker] exited with code: &#x27;</span> + code))</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    worker.on(<span class=\"string\">&#x27;error&#x27;</span>, <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">&#x27;[worker]&#x27;</span>, err)</span><br><span class=\"line\">      err.message = <span class=\"string\">&#x27;[worker] &#x27;</span> + err.message</span><br><span class=\"line\">      reject(err)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    worker.on(<span class=\"string\">&#x27;message&#x27;</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (event &amp;&amp; event.address) &#123;</span><br><span class=\"line\">        resolve(&#123;</span><br><span class=\"line\">          worker,</span><br><span class=\"line\">          <span class=\"attr\">address</span>: event.address</span><br><span class=\"line\">        &#125; <span class=\"keyword\">as</span> NitroWorker)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 观察更新</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">watch</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (watcher) &#123; <span class=\"keyword\">return</span> &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> dReload = </span><br><span class=\"line\">        debounce(<span class=\"function\">() =&gt;</span> </span><br><span class=\"line\">                 reload().catch(<span class=\"built_in\">console</span>.warn), </span><br><span class=\"line\">                 <span class=\"number\">200</span>, </span><br><span class=\"line\">                 &#123; <span class=\"attr\">before</span>: <span class=\"literal\">true</span> &#125;)</span><br><span class=\"line\">  watcher = chokidar.watch([</span><br><span class=\"line\">    resolve(nitroContext.output.serverDir, pattern),</span><br><span class=\"line\">    resolve(nitroContext._nuxt.buildDir, <span class=\"string\">&#x27;dist/server&#x27;</span>, pattern)</span><br><span class=\"line\">  ]).on(<span class=\"string\">&#x27;all&#x27;</span>, </span><br><span class=\"line\">        <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> events.includes(event) &amp;&amp; dReload()</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 执行更新</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reload</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Create a new worker</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> newWorker = <span class=\"keyword\">await</span> initWorker(workerEntry)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Kill old worker in background</span></span><br><span class=\"line\">  killWorker(currentWorker).catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.error(err))</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Replace new worker as current</span></span><br><span class=\"line\">  currentWorker = newWorker</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上述代码中我们可以看到，当你 <strong>dist/server</strong> 文件下内容发生更新，会触发 watch 监听，并执行 reload 操作。此时，用到了一个 node 原生模块 <strong>worker_threads</strong> 。</p>\n<h3 id=\"4-聊聊-worker-threads\"><a href=\"#4-聊聊-worker-threads\" class=\"headerlink\" title=\"4. 聊聊 worker_threads\"></a>4. 聊聊 worker_threads</h3><p>Node 创建多个workers有如下几种方式：</p>\n<ul>\n<li><p>利用 child_process 创建子进程，子进程拥有独立的 V8 和 Libuv，父子之间可以通讯。 </p>\n</li>\n<li><p>基于 child_process 利用CPU多核提供可负载均衡集中式管理 Cluster，父子之间可以通讯，内存不共享，但是子进程间是不能通讯的。</p>\n</li>\n<li><p>利用worker_threads创建多个workers是可以实现内存共享的，因为在创建worker_threads worker 同时，底层 C++ 创建的是 <strong>V8 Isolates</strong>，它是一个独立的 chrome V8 运行实例，其有独立的 JS 堆和微任务队列。这就为每一个 Node.js worker 独立运行提供了保障。其缺陷就是，workers 之间没法直接访问对方的堆。由于这个原因，每个 worker 都有其自己的 <a href=\"https://link.zhihu.com/?target=https://github.com/libuv/libuv\">libuv</a> event loop。</p>\n</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsmfwaha0j30y80u0tav.jpg\" alt=\"image-20211227193553758\"></p>\n<h4 id=\"4-1-初始化阶段\"><a href=\"#4-1-初始化阶段\" class=\"headerlink\" title=\"4.1 初始化阶段\"></a>4.1 <strong>初始化阶段</strong></h4><ol>\n<li>用户空间的脚本通过 <code>worker_threads</code> 模块创建一个 worker 实例</li>\n<li>Node.js 的 parent worker 初始化脚本调用 C++ 模块，创建一个空的 C++ worker 对象。</li>\n<li>当 C++ worker 对象被创建后，它生成一个线程 ID 并分配给自己</li>\n<li>当 worker 对象被创建的时候，parent worker 会初创建一个空的始化信道（让我们称它为 <code>IMC</code>）。就是上面图二的 “Initialisation Message Channel”</li>\n<li>Node.js 的 parent worker 初始化脚本创建一个公共的 JS 信道（让我们称它为 <code>PMC</code>）。该信道是给用户空间的 JS 使用的，便于他们在 parent worker 和 child worker 之间通过 <code>*.postMessage()</code> 方法来传递消息。就是上面图一和图二的红色部分</li>\n<li>Node.js 的 parent worker 初始化脚本调用 C++ 模块，将初始化的 metadata 写入 IMC 来传递给 worker 的执行脚本。</li>\n</ol>\n<h4 id=\"4-2-运行阶段\"><a href=\"#4-2-运行阶段\" class=\"headerlink\" title=\"4.2 运行阶段\"></a>4.2 <strong>运行阶段</strong></h4><p>此时，初始化阶段完成。然后，就会调用 C++ 来启动这个 worker 线程。</p>\n<ol>\n<li>一个新的 v8 isolate 被创建并分配给这个 worker。这使得该 worker 可以拥有自己的运行时环境</li>\n<li>libuv 被初始化。这使得该 worker 可以拥有自己的 event loop</li>\n<li>Worker 初始化脚本被执行，启动 worker 的 event loop</li>\n<li>Worker 初始化脚本 调用 C++ 模块从 IMC 读取初始化 metadata</li>\n<li>Worker 执行脚本在 worker 中运行代码文件或代码片段。在我们的例子中就是 <code>worker-simple.js</code></li>\n</ol>\n<h2 id=\"四-Nuxt-Bridge\"><a href=\"#四-Nuxt-Bridge\" class=\"headerlink\" title=\"四. Nuxt Bridge\"></a>四. Nuxt Bridge</h2><p>Bridge 是一个向前兼容层，它允许您通过简单地安装和启用 Nuxt 模块来体验许多新的 Nuxt 3 功能。</p>\n<p>使用 Nuxt Bridge，您可以确保您的项目（几乎）为 Nuxt 3 做好准备，并拥有最佳的开发人员体验，而无需进行重大重写或冒险更改。</p>\n<p>建议参考一下官网文档： <a href=\"https://v3.nuxtjs.org/getting-started/bridge\">https://v3.nuxtjs.org/getting-started/bridge</a></p>\n<h2 id=\"五-结束语\"><a href=\"#五-结束语\" class=\"headerlink\" title=\"五. 结束语\"></a>五. 结束语</h2><p>Nuxt 3 目前仍处于Beta阶段，h3 &amp; Nitro 仍在不断适配中，所以不建议应用于生产环境。作为学习，当我们透过本质去回忆 SSR 实现的全过程，那么 Nuxt 3 源码部分就不会生涩难懂。Nuxt 不仅仅是搬运了其他框架的优势，自己在内部也有很多比较有意思的实现。比如 mini 版本的 tapable。在Nuxt 2中定义为 Hable。它贯穿了整个 Nuxt 实例化后的生命周期。有兴趣的同学我们可以一起探索学习一下~</p>\n"},{"title":"React hooks API","_content":"\n# React hooks API\n\n### 基础 Hook\n\n- useState\n- useEffect\n- useContext\n\n### 额外的 Hook\n\n- useReducer\n- useCallback\n- useMemo\n- useRef\n- useImperativeHandle\n- useLayoutEffect\n- useDebugValue\n\n### 调用example\n\n<iframe src=\"https://codesandbox.io/s/naughty-cherry-3ec6k?file=/src/App.js\" width=\"100%\" height=\"600px\" />\n","source":"_posts/React hooks 梳理.md","raw":"---\ntitle: React hooks API\ntags: react\n---\n\n# React hooks API\n\n### 基础 Hook\n\n- useState\n- useEffect\n- useContext\n\n### 额外的 Hook\n\n- useReducer\n- useCallback\n- useMemo\n- useRef\n- useImperativeHandle\n- useLayoutEffect\n- useDebugValue\n\n### 调用example\n\n<iframe src=\"https://codesandbox.io/s/naughty-cherry-3ec6k?file=/src/App.js\" width=\"100%\" height=\"600px\" />\n","slug":"React hooks 梳理","published":1,"date":"2021-07-21T03:47:11.663Z","updated":"2021-12-28T02:08:16.290Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxph7qmd000c1op7csmih13a","content":"<h1 id=\"React-hooks-API\"><a href=\"#React-hooks-API\" class=\"headerlink\" title=\"React hooks API\"></a>React hooks API</h1><h3 id=\"基础-Hook\"><a href=\"#基础-Hook\" class=\"headerlink\" title=\"基础 Hook\"></a>基础 Hook</h3><ul>\n<li>useState</li>\n<li>useEffect</li>\n<li>useContext</li>\n</ul>\n<h3 id=\"额外的-Hook\"><a href=\"#额外的-Hook\" class=\"headerlink\" title=\"额外的 Hook\"></a>额外的 Hook</h3><ul>\n<li>useReducer</li>\n<li>useCallback</li>\n<li>useMemo</li>\n<li>useRef</li>\n<li>useImperativeHandle</li>\n<li>useLayoutEffect</li>\n<li>useDebugValue</li>\n</ul>\n<h3 id=\"调用example\"><a href=\"#调用example\" class=\"headerlink\" title=\"调用example\"></a>调用example</h3><iframe src=\"https://codesandbox.io/s/naughty-cherry-3ec6k?file=/src/App.js\" width=\"100%\" height=\"600px\" />\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"React-hooks-API\"><a href=\"#React-hooks-API\" class=\"headerlink\" title=\"React hooks API\"></a>React hooks API</h1><h3 id=\"基础-Hook\"><a href=\"#基础-Hook\" class=\"headerlink\" title=\"基础 Hook\"></a>基础 Hook</h3><ul>\n<li>useState</li>\n<li>useEffect</li>\n<li>useContext</li>\n</ul>\n<h3 id=\"额外的-Hook\"><a href=\"#额外的-Hook\" class=\"headerlink\" title=\"额外的 Hook\"></a>额外的 Hook</h3><ul>\n<li>useReducer</li>\n<li>useCallback</li>\n<li>useMemo</li>\n<li>useRef</li>\n<li>useImperativeHandle</li>\n<li>useLayoutEffect</li>\n<li>useDebugValue</li>\n</ul>\n<h3 id=\"调用example\"><a href=\"#调用example\" class=\"headerlink\" title=\"调用example\"></a>调用example</h3><iframe src=\"https://codesandbox.io/s/naughty-cherry-3ec6k?file=/src/App.js\" width=\"100%\" height=\"600px\" />\n"},{"title":"Rxjs","_content":"\n# Rxjs\n-------\n## 函数式编程\n首先学习 Rxjs，我们先了解两种较为传统的编程思想：`面向对象编程思想`、`面向过程过程编`程思想；\n\n**面向对象编程**：要求实例化对象具有封装、继承、多态等变现形式。其优势是属性黑盒内置，外层调用不能直接修改内部的属性，只能通过对外暴露的方法。\n\n**面向过程编程**：目前具有代表性的是`函数式编程`，`响应式编程`。其优势是数据在函数之间传递，形成的数据流，纯函数引用后即被回收，运行时占用内存较少。\n\n## Rxjs 是什么?\n通过对第一章的学习了解，首先 Rxjs 采用的是面向过程的编程思想，数据流在函数间流动，所以函数可以有效传递数据流，结合观察者模式 + 迭代器模式来管控。\n\n## Observable & Observer\n\nObservable 是一个可以被订阅的数据集合。Observer是一个订阅者。订阅者在Rxjs中充当一个被动接收数据的觉得。一旦订阅了，数据集合就会给订阅者传输数据。订阅的操作交给 `subscribe`。\n\n``` javascript\nimport {Observable} from 'rxjs/Observable';\nconst onSubscribe = observer => {\n    console.log(observer, \"---1---\");\n    observer.next(1);\n    observer.next(2);\n    observer.next(3);\n};\nconst source$ = new Observable(onSubscribe);\nconsole.log(source$, \"---2---\");\nconst theObserver = {\n        next: item => console.log(item)\n} \nsource$.subscribe(theObserver);\n```\n![](https://i.loli.net/2021/05/27/BJRx23Wvi4Cdo8y.jpg)\n\n![](https://i.loli.net/2021/05/27/RNfOV2EJBvgcZ4s.jpg)\n\n数据流不可能都是一种从A到B的流向。过程中我们可能对数据做很多的中间处理。可以利用 `pipe` 方法将数据流不断的分流，如下如所示:\n\n![](https://i.loli.net/2021/05/26/dgWFzZQ7ScTE3xm.jpg)\n\n## Hot Observable & Cold Observable\n当一个 Observable 的数据如果同时被两个订阅者订阅，并且两个订阅的订阅时机有先后，B 在 A 订阅之后在订阅。B 在订阅过程中的数据，是否考虑之前流入A的那些数据呢?\n\n- 考虑： Cold Observable\n- 不考虑：Hot Observable\n\n## 弹珠图\n地址：[弹珠图](https://rxviz.com/)\n弹珠图存在意义是考虑复杂场景下，帮助解决开发者更好的理解数据流的流向问题。\n\n## 操作符\n![image-20211227175307524](https://tva1.sinaimg.cn/large/008i3skNly1gxsjh093hnj30ej0fu0t6.jpg)\n\nRxjs 中操作符的种类有很多，但是无外乎上面这些类。\n\n\n\n","source":"_posts/Rxjs.md","raw":"---\ntitle: Rxjs\ntags: js\n---\n\n# Rxjs\n-------\n## 函数式编程\n首先学习 Rxjs，我们先了解两种较为传统的编程思想：`面向对象编程思想`、`面向过程过程编`程思想；\n\n**面向对象编程**：要求实例化对象具有封装、继承、多态等变现形式。其优势是属性黑盒内置，外层调用不能直接修改内部的属性，只能通过对外暴露的方法。\n\n**面向过程编程**：目前具有代表性的是`函数式编程`，`响应式编程`。其优势是数据在函数之间传递，形成的数据流，纯函数引用后即被回收，运行时占用内存较少。\n\n## Rxjs 是什么?\n通过对第一章的学习了解，首先 Rxjs 采用的是面向过程的编程思想，数据流在函数间流动，所以函数可以有效传递数据流，结合观察者模式 + 迭代器模式来管控。\n\n## Observable & Observer\n\nObservable 是一个可以被订阅的数据集合。Observer是一个订阅者。订阅者在Rxjs中充当一个被动接收数据的觉得。一旦订阅了，数据集合就会给订阅者传输数据。订阅的操作交给 `subscribe`。\n\n``` javascript\nimport {Observable} from 'rxjs/Observable';\nconst onSubscribe = observer => {\n    console.log(observer, \"---1---\");\n    observer.next(1);\n    observer.next(2);\n    observer.next(3);\n};\nconst source$ = new Observable(onSubscribe);\nconsole.log(source$, \"---2---\");\nconst theObserver = {\n        next: item => console.log(item)\n} \nsource$.subscribe(theObserver);\n```\n![](https://i.loli.net/2021/05/27/BJRx23Wvi4Cdo8y.jpg)\n\n![](https://i.loli.net/2021/05/27/RNfOV2EJBvgcZ4s.jpg)\n\n数据流不可能都是一种从A到B的流向。过程中我们可能对数据做很多的中间处理。可以利用 `pipe` 方法将数据流不断的分流，如下如所示:\n\n![](https://i.loli.net/2021/05/26/dgWFzZQ7ScTE3xm.jpg)\n\n## Hot Observable & Cold Observable\n当一个 Observable 的数据如果同时被两个订阅者订阅，并且两个订阅的订阅时机有先后，B 在 A 订阅之后在订阅。B 在订阅过程中的数据，是否考虑之前流入A的那些数据呢?\n\n- 考虑： Cold Observable\n- 不考虑：Hot Observable\n\n## 弹珠图\n地址：[弹珠图](https://rxviz.com/)\n弹珠图存在意义是考虑复杂场景下，帮助解决开发者更好的理解数据流的流向问题。\n\n## 操作符\n![image-20211227175307524](https://tva1.sinaimg.cn/large/008i3skNly1gxsjh093hnj30ej0fu0t6.jpg)\n\nRxjs 中操作符的种类有很多，但是无外乎上面这些类。\n\n\n\n","slug":"Rxjs","published":1,"date":"2021-05-28T09:43:34.915Z","updated":"2021-12-28T02:03:40.654Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxph7qme000e1op73sckatnx","content":"<h1 id=\"Rxjs\"><a href=\"#Rxjs\" class=\"headerlink\" title=\"Rxjs\"></a>Rxjs</h1><hr>\n<h2 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h2><p>首先学习 Rxjs，我们先了解两种较为传统的编程思想：<code>面向对象编程思想</code>、<code>面向过程过程编</code>程思想；</p>\n<p><strong>面向对象编程</strong>：要求实例化对象具有封装、继承、多态等变现形式。其优势是属性黑盒内置，外层调用不能直接修改内部的属性，只能通过对外暴露的方法。</p>\n<p><strong>面向过程编程</strong>：目前具有代表性的是<code>函数式编程</code>，<code>响应式编程</code>。其优势是数据在函数之间传递，形成的数据流，纯函数引用后即被回收，运行时占用内存较少。</p>\n<h2 id=\"Rxjs-是什么\"><a href=\"#Rxjs-是什么\" class=\"headerlink\" title=\"Rxjs 是什么?\"></a>Rxjs 是什么?</h2><p>通过对第一章的学习了解，首先 Rxjs 采用的是面向过程的编程思想，数据流在函数间流动，所以函数可以有效传递数据流，结合观察者模式 + 迭代器模式来管控。</p>\n<h2 id=\"Observable-amp-Observer\"><a href=\"#Observable-amp-Observer\" class=\"headerlink\" title=\"Observable &amp; Observer\"></a>Observable &amp; Observer</h2><p>Observable 是一个可以被订阅的数据集合。Observer是一个订阅者。订阅者在Rxjs中充当一个被动接收数据的觉得。一旦订阅了，数据集合就会给订阅者传输数据。订阅的操作交给 <code>subscribe</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Observable&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs/Observable&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> onSubscribe = <span class=\"function\"><span class=\"params\">observer</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(observer, <span class=\"string\">&quot;---1---&quot;</span>);</span><br><span class=\"line\">    observer.next(<span class=\"number\">1</span>);</span><br><span class=\"line\">    observer.next(<span class=\"number\">2</span>);</span><br><span class=\"line\">    observer.next(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> source$ = <span class=\"keyword\">new</span> Observable(onSubscribe);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(source$, <span class=\"string\">&quot;---2---&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> theObserver = &#123;</span><br><span class=\"line\">        <span class=\"attr\">next</span>: <span class=\"function\"><span class=\"params\">item</span> =&gt;</span> <span class=\"built_in\">console</span>.log(item)</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">source$.subscribe(theObserver);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://i.loli.net/2021/05/27/BJRx23Wvi4Cdo8y.jpg\"></p>\n<p><img src=\"https://i.loli.net/2021/05/27/RNfOV2EJBvgcZ4s.jpg\"></p>\n<p>数据流不可能都是一种从A到B的流向。过程中我们可能对数据做很多的中间处理。可以利用 <code>pipe</code> 方法将数据流不断的分流，如下如所示:</p>\n<p><img src=\"https://i.loli.net/2021/05/26/dgWFzZQ7ScTE3xm.jpg\"></p>\n<h2 id=\"Hot-Observable-amp-Cold-Observable\"><a href=\"#Hot-Observable-amp-Cold-Observable\" class=\"headerlink\" title=\"Hot Observable &amp; Cold Observable\"></a>Hot Observable &amp; Cold Observable</h2><p>当一个 Observable 的数据如果同时被两个订阅者订阅，并且两个订阅的订阅时机有先后，B 在 A 订阅之后在订阅。B 在订阅过程中的数据，是否考虑之前流入A的那些数据呢?</p>\n<ul>\n<li>考虑： Cold Observable</li>\n<li>不考虑：Hot Observable</li>\n</ul>\n<h2 id=\"弹珠图\"><a href=\"#弹珠图\" class=\"headerlink\" title=\"弹珠图\"></a>弹珠图</h2><p>地址：<a href=\"https://rxviz.com/\">弹珠图</a><br>弹珠图存在意义是考虑复杂场景下，帮助解决开发者更好的理解数据流的流向问题。</p>\n<h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h2><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsjh093hnj30ej0fu0t6.jpg\" alt=\"image-20211227175307524\"></p>\n<p>Rxjs 中操作符的种类有很多，但是无外乎上面这些类。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Rxjs\"><a href=\"#Rxjs\" class=\"headerlink\" title=\"Rxjs\"></a>Rxjs</h1><hr>\n<h2 id=\"函数式编程\"><a href=\"#函数式编程\" class=\"headerlink\" title=\"函数式编程\"></a>函数式编程</h2><p>首先学习 Rxjs，我们先了解两种较为传统的编程思想：<code>面向对象编程思想</code>、<code>面向过程过程编</code>程思想；</p>\n<p><strong>面向对象编程</strong>：要求实例化对象具有封装、继承、多态等变现形式。其优势是属性黑盒内置，外层调用不能直接修改内部的属性，只能通过对外暴露的方法。</p>\n<p><strong>面向过程编程</strong>：目前具有代表性的是<code>函数式编程</code>，<code>响应式编程</code>。其优势是数据在函数之间传递，形成的数据流，纯函数引用后即被回收，运行时占用内存较少。</p>\n<h2 id=\"Rxjs-是什么\"><a href=\"#Rxjs-是什么\" class=\"headerlink\" title=\"Rxjs 是什么?\"></a>Rxjs 是什么?</h2><p>通过对第一章的学习了解，首先 Rxjs 采用的是面向过程的编程思想，数据流在函数间流动，所以函数可以有效传递数据流，结合观察者模式 + 迭代器模式来管控。</p>\n<h2 id=\"Observable-amp-Observer\"><a href=\"#Observable-amp-Observer\" class=\"headerlink\" title=\"Observable &amp; Observer\"></a>Observable &amp; Observer</h2><p>Observable 是一个可以被订阅的数据集合。Observer是一个订阅者。订阅者在Rxjs中充当一个被动接收数据的觉得。一旦订阅了，数据集合就会给订阅者传输数据。订阅的操作交给 <code>subscribe</code>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123;Observable&#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;rxjs/Observable&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> onSubscribe = <span class=\"function\"><span class=\"params\">observer</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(observer, <span class=\"string\">&quot;---1---&quot;</span>);</span><br><span class=\"line\">    observer.next(<span class=\"number\">1</span>);</span><br><span class=\"line\">    observer.next(<span class=\"number\">2</span>);</span><br><span class=\"line\">    observer.next(<span class=\"number\">3</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> source$ = <span class=\"keyword\">new</span> Observable(onSubscribe);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(source$, <span class=\"string\">&quot;---2---&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> theObserver = &#123;</span><br><span class=\"line\">        <span class=\"attr\">next</span>: <span class=\"function\"><span class=\"params\">item</span> =&gt;</span> <span class=\"built_in\">console</span>.log(item)</span><br><span class=\"line\">&#125; </span><br><span class=\"line\">source$.subscribe(theObserver);</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://i.loli.net/2021/05/27/BJRx23Wvi4Cdo8y.jpg\"></p>\n<p><img src=\"https://i.loli.net/2021/05/27/RNfOV2EJBvgcZ4s.jpg\"></p>\n<p>数据流不可能都是一种从A到B的流向。过程中我们可能对数据做很多的中间处理。可以利用 <code>pipe</code> 方法将数据流不断的分流，如下如所示:</p>\n<p><img src=\"https://i.loli.net/2021/05/26/dgWFzZQ7ScTE3xm.jpg\"></p>\n<h2 id=\"Hot-Observable-amp-Cold-Observable\"><a href=\"#Hot-Observable-amp-Cold-Observable\" class=\"headerlink\" title=\"Hot Observable &amp; Cold Observable\"></a>Hot Observable &amp; Cold Observable</h2><p>当一个 Observable 的数据如果同时被两个订阅者订阅，并且两个订阅的订阅时机有先后，B 在 A 订阅之后在订阅。B 在订阅过程中的数据，是否考虑之前流入A的那些数据呢?</p>\n<ul>\n<li>考虑： Cold Observable</li>\n<li>不考虑：Hot Observable</li>\n</ul>\n<h2 id=\"弹珠图\"><a href=\"#弹珠图\" class=\"headerlink\" title=\"弹珠图\"></a>弹珠图</h2><p>地址：<a href=\"https://rxviz.com/\">弹珠图</a><br>弹珠图存在意义是考虑复杂场景下，帮助解决开发者更好的理解数据流的流向问题。</p>\n<h2 id=\"操作符\"><a href=\"#操作符\" class=\"headerlink\" title=\"操作符\"></a>操作符</h2><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsjh093hnj30ej0fu0t6.jpg\" alt=\"image-20211227175307524\"></p>\n<p>Rxjs 中操作符的种类有很多，但是无外乎上面这些类。</p>\n"},{"title":"Service Worker","_content":"\n##  Service Worker\n\n\n\n### 1. 概念区分\n\nPWA / Service Worker / WorkBox 虽然相互之间有着千丝万缕的联系，但是，他们工作的位面不一样。\n\n![image-20211221112823453](https://tva1.sinaimg.cn/large/008i3skNly1gxlamuaofxj31240fmgmp.jpg)\n\n\n\n#### 1. 1 Service Worker \n\n- Service Worker 工作在浏览器的worker进程中，API设计是纯异步的。所以同步的API在不能在其上面调用和使用。\n- Service worker运行在worker上下文，因此它不能访问DOM。\n- Service workers只能由HTTPS承载。（开发环境认可： localhost or 127.0.0.1）\n- 使用前，需要确认兼容性。（https://caniuse.com/?search=Service%20Worker）\n\n\n\n#### 1.2 PWA （Progressive Web App）\n\n- 用户端存储：Cache、IndexedDB，但是使用前要注意不同浏览器厂商对应的存储大小是有限的。溢出的话容易造成I/O失败。\n\n- 关注 ： https://web.dev/pwa-checklist/#exemplary 详细列举了 PWA 有哪些优势。\n\n- 请搞清楚如下几个 Manifest\n\n  | `html`标签的`manifest`属性: [离线缓存](https://link.segmentfault.com/?enc=30FUPA%2B0OF6S8jcR%2Btiy6w%3D%3D.HQfRYNa7bCuePN0A7niiqhgM5Puuf2cpEO2DOXmUdx%2FGMnuhEc2LPlRxvzCBpKmCqUoecRqV9Djwdtd5VlSsJt4E%2BPM%2BV68ZFZgexgB0NbI%3D)（目前已被废弃） |\n  | ------------------------------------------------------------ |\n  | [PWA](https://link.segmentfault.com/?enc=3uYS%2BFS2GnqcfbLMGXI4jg%3D%3D.cMqJMTrtQpDJhGjKLO68V2f2C6jpt9ducPhvcYmscQYNzA8h9A3rCsbYm%2Fio9UTuBfUZ7YEKEINj2xE1H%2FGrLw%3D%3D): 将Web应用程序安装到设备的主屏幕 |\n  | webpack中[webpack-manifest-plugin](https://link.segmentfault.com/?enc=l3XiYvyvmeI3JdAAqzzvrQ%3D%3D.ktTdDfXIuLCHOKl%2BvDPi3HXlUrXH6l3xGk3y264UcPN0ekiR4P98WtlW0t5lJ7msjmZn%2FeTAbFkIItR0D1ckfQ%3D%3D)插件打包出来的`manifest.json`文件，用来生成一份资源清单，为后端渲染服务 |\n  | webpack中[DLL](https://link.segmentfault.com/?enc=nlZhAFjfVIrvKisyS%2FszGw%3D%3D.qMADE2SbyN1uREswaprW7SqyrlrjoMTHAc1WCZ%2FxSK0N%2FqkOOtFKTraF21YFUjvI)打包时,输出的`manifest.json`文件，用来分析已经打包过的文件，优化打包速度和大小 |\n  | webpack中[manifest](https://link.segmentfault.com/?enc=mA6r%2FdGrhlWqzosrYJc5eQ%3D%3D.89YiF%2BuDET6nLBPORl39UYZmPdk2eFLyTMgNVeWjOWd4m8fmUR2s%2FYJ1oyMZnkYP)运行时代码 |\n\n\n\n下面是 PWA 中 manifest 的编写示例：\n\n```json\n{ \n  \"name\" : \"Minimal PWA\" , \n  \"short_name\" : \"PWA Demo\" , \n  \"display\" : \"standalone\" , \n  \"start_url\" : \"/\" , \n  \"theme_color\" : \"#313131\" , \n  \"background_color\" : \"#313131\" , \n  \"icons\" : [ \n    {\n      \"src\": \"images/touch/homescreen48.png\",\n      \"sizes\": \"48x48\",\n      \"type\": \"image/png\"\n    }\n   ] \n}\n```\n\n#### 1.3 workbox\n\nWorkbox 是一组库，可以为 Progressive Web App 提供生产就绪的 Service Worker。\n\n![image-20211222202841855](https://tva1.sinaimg.cn/large/008i3skNly1gxmvvbunp3j31l40kmq4o.jpg)","source":"_posts/ServiceWorker.md","raw":"---\ntitle: Service Worker\ntags: 浏览器\n---\n\n##  Service Worker\n\n\n\n### 1. 概念区分\n\nPWA / Service Worker / WorkBox 虽然相互之间有着千丝万缕的联系，但是，他们工作的位面不一样。\n\n![image-20211221112823453](https://tva1.sinaimg.cn/large/008i3skNly1gxlamuaofxj31240fmgmp.jpg)\n\n\n\n#### 1. 1 Service Worker \n\n- Service Worker 工作在浏览器的worker进程中，API设计是纯异步的。所以同步的API在不能在其上面调用和使用。\n- Service worker运行在worker上下文，因此它不能访问DOM。\n- Service workers只能由HTTPS承载。（开发环境认可： localhost or 127.0.0.1）\n- 使用前，需要确认兼容性。（https://caniuse.com/?search=Service%20Worker）\n\n\n\n#### 1.2 PWA （Progressive Web App）\n\n- 用户端存储：Cache、IndexedDB，但是使用前要注意不同浏览器厂商对应的存储大小是有限的。溢出的话容易造成I/O失败。\n\n- 关注 ： https://web.dev/pwa-checklist/#exemplary 详细列举了 PWA 有哪些优势。\n\n- 请搞清楚如下几个 Manifest\n\n  | `html`标签的`manifest`属性: [离线缓存](https://link.segmentfault.com/?enc=30FUPA%2B0OF6S8jcR%2Btiy6w%3D%3D.HQfRYNa7bCuePN0A7niiqhgM5Puuf2cpEO2DOXmUdx%2FGMnuhEc2LPlRxvzCBpKmCqUoecRqV9Djwdtd5VlSsJt4E%2BPM%2BV68ZFZgexgB0NbI%3D)（目前已被废弃） |\n  | ------------------------------------------------------------ |\n  | [PWA](https://link.segmentfault.com/?enc=3uYS%2BFS2GnqcfbLMGXI4jg%3D%3D.cMqJMTrtQpDJhGjKLO68V2f2C6jpt9ducPhvcYmscQYNzA8h9A3rCsbYm%2Fio9UTuBfUZ7YEKEINj2xE1H%2FGrLw%3D%3D): 将Web应用程序安装到设备的主屏幕 |\n  | webpack中[webpack-manifest-plugin](https://link.segmentfault.com/?enc=l3XiYvyvmeI3JdAAqzzvrQ%3D%3D.ktTdDfXIuLCHOKl%2BvDPi3HXlUrXH6l3xGk3y264UcPN0ekiR4P98WtlW0t5lJ7msjmZn%2FeTAbFkIItR0D1ckfQ%3D%3D)插件打包出来的`manifest.json`文件，用来生成一份资源清单，为后端渲染服务 |\n  | webpack中[DLL](https://link.segmentfault.com/?enc=nlZhAFjfVIrvKisyS%2FszGw%3D%3D.qMADE2SbyN1uREswaprW7SqyrlrjoMTHAc1WCZ%2FxSK0N%2FqkOOtFKTraF21YFUjvI)打包时,输出的`manifest.json`文件，用来分析已经打包过的文件，优化打包速度和大小 |\n  | webpack中[manifest](https://link.segmentfault.com/?enc=mA6r%2FdGrhlWqzosrYJc5eQ%3D%3D.89YiF%2BuDET6nLBPORl39UYZmPdk2eFLyTMgNVeWjOWd4m8fmUR2s%2FYJ1oyMZnkYP)运行时代码 |\n\n\n\n下面是 PWA 中 manifest 的编写示例：\n\n```json\n{ \n  \"name\" : \"Minimal PWA\" , \n  \"short_name\" : \"PWA Demo\" , \n  \"display\" : \"standalone\" , \n  \"start_url\" : \"/\" , \n  \"theme_color\" : \"#313131\" , \n  \"background_color\" : \"#313131\" , \n  \"icons\" : [ \n    {\n      \"src\": \"images/touch/homescreen48.png\",\n      \"sizes\": \"48x48\",\n      \"type\": \"image/png\"\n    }\n   ] \n}\n```\n\n#### 1.3 workbox\n\nWorkbox 是一组库，可以为 Progressive Web App 提供生产就绪的 Service Worker。\n\n![image-20211222202841855](https://tva1.sinaimg.cn/large/008i3skNly1gxmvvbunp3j31l40kmq4o.jpg)","slug":"ServiceWorker","published":1,"date":"2021-12-21T03:22:58.552Z","updated":"2021-12-28T02:15:03.757Z","_id":"ckxph7qmf000h1op71fwkbwh5","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Service-Worker\"><a href=\"#Service-Worker\" class=\"headerlink\" title=\"Service Worker\"></a>Service Worker</h2><h3 id=\"1-概念区分\"><a href=\"#1-概念区分\" class=\"headerlink\" title=\"1. 概念区分\"></a>1. 概念区分</h3><p>PWA / Service Worker / WorkBox 虽然相互之间有着千丝万缕的联系，但是，他们工作的位面不一样。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxlamuaofxj31240fmgmp.jpg\" alt=\"image-20211221112823453\"></p>\n<h4 id=\"1-1-Service-Worker\"><a href=\"#1-1-Service-Worker\" class=\"headerlink\" title=\"1. 1 Service Worker\"></a>1. 1 Service Worker</h4><ul>\n<li>Service Worker 工作在浏览器的worker进程中，API设计是纯异步的。所以同步的API在不能在其上面调用和使用。</li>\n<li>Service worker运行在worker上下文，因此它不能访问DOM。</li>\n<li>Service workers只能由HTTPS承载。（开发环境认可： localhost or 127.0.0.1）</li>\n<li>使用前，需要确认兼容性。（<a href=\"https://caniuse.com/?search=Service%20Worker%EF%BC%89\">https://caniuse.com/?search=Service%20Worker）</a></li>\n</ul>\n<h4 id=\"1-2-PWA-（Progressive-Web-App）\"><a href=\"#1-2-PWA-（Progressive-Web-App）\" class=\"headerlink\" title=\"1.2 PWA （Progressive Web App）\"></a>1.2 PWA （Progressive Web App）</h4><ul>\n<li><p>用户端存储：Cache、IndexedDB，但是使用前要注意不同浏览器厂商对应的存储大小是有限的。溢出的话容易造成I/O失败。</p>\n</li>\n<li><p>关注 ： <a href=\"https://web.dev/pwa-checklist/#exemplary\">https://web.dev/pwa-checklist/#exemplary</a> 详细列举了 PWA 有哪些优势。</p>\n</li>\n<li><p>请搞清楚如下几个 Manifest</p>\n<table>\n<thead>\n<tr>\n<th><code>html</code>标签的<code>manifest</code>属性: <a href=\"https://link.segmentfault.com/?enc=30FUPA+0OF6S8jcR+tiy6w==.HQfRYNa7bCuePN0A7niiqhgM5Puuf2cpEO2DOXmUdx/GMnuhEc2LPlRxvzCBpKmCqUoecRqV9Djwdtd5VlSsJt4E+PM+V68ZFZgexgB0NbI=\">离线缓存</a>（目前已被废弃）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://link.segmentfault.com/?enc=3uYS+FS2GnqcfbLMGXI4jg==.cMqJMTrtQpDJhGjKLO68V2f2C6jpt9ducPhvcYmscQYNzA8h9A3rCsbYm/io9UTuBfUZ7YEKEINj2xE1H/GrLw==\">PWA</a>: 将Web应用程序安装到设备的主屏幕</td>\n</tr>\n<tr>\n<td>webpack中<a href=\"https://link.segmentfault.com/?enc=l3XiYvyvmeI3JdAAqzzvrQ==.ktTdDfXIuLCHOKl+vDPi3HXlUrXH6l3xGk3y264UcPN0ekiR4P98WtlW0t5lJ7msjmZn/eTAbFkIItR0D1ckfQ==\">webpack-manifest-plugin</a>插件打包出来的<code>manifest.json</code>文件，用来生成一份资源清单，为后端渲染服务</td>\n</tr>\n<tr>\n<td>webpack中<a href=\"https://link.segmentfault.com/?enc=nlZhAFjfVIrvKisyS/szGw==.qMADE2SbyN1uREswaprW7SqyrlrjoMTHAc1WCZ/xSK0N/qkOOtFKTraF21YFUjvI\">DLL</a>打包时,输出的<code>manifest.json</code>文件，用来分析已经打包过的文件，优化打包速度和大小</td>\n</tr>\n<tr>\n<td>webpack中<a href=\"https://link.segmentfault.com/?enc=mA6r/dGrhlWqzosrYJc5eQ==.89YiF+uDET6nLBPORl39UYZmPdk2eFLyTMgNVeWjOWd4m8fmUR2s/YJ1oyMZnkYP\">manifest</a>运行时代码</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>下面是 PWA 中 manifest 的编写示例：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span> : <span class=\"string\">&quot;Minimal PWA&quot;</span> , </span><br><span class=\"line\">  <span class=\"attr\">&quot;short_name&quot;</span> : <span class=\"string\">&quot;PWA Demo&quot;</span> , </span><br><span class=\"line\">  <span class=\"attr\">&quot;display&quot;</span> : <span class=\"string\">&quot;standalone&quot;</span> , </span><br><span class=\"line\">  <span class=\"attr\">&quot;start_url&quot;</span> : <span class=\"string\">&quot;/&quot;</span> , </span><br><span class=\"line\">  <span class=\"attr\">&quot;theme_color&quot;</span> : <span class=\"string\">&quot;#313131&quot;</span> , </span><br><span class=\"line\">  <span class=\"attr\">&quot;background_color&quot;</span> : <span class=\"string\">&quot;#313131&quot;</span> , </span><br><span class=\"line\">  <span class=\"attr\">&quot;icons&quot;</span> : [ </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;src&quot;</span>: <span class=\"string\">&quot;images/touch/homescreen48.png&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;sizes&quot;</span>: <span class=\"string\">&quot;48x48&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;image/png&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   ] </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-workbox\"><a href=\"#1-3-workbox\" class=\"headerlink\" title=\"1.3 workbox\"></a>1.3 workbox</h4><p>Workbox 是一组库，可以为 Progressive Web App 提供生产就绪的 Service Worker。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxmvvbunp3j31l40kmq4o.jpg\" alt=\"image-20211222202841855\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Service-Worker\"><a href=\"#Service-Worker\" class=\"headerlink\" title=\"Service Worker\"></a>Service Worker</h2><h3 id=\"1-概念区分\"><a href=\"#1-概念区分\" class=\"headerlink\" title=\"1. 概念区分\"></a>1. 概念区分</h3><p>PWA / Service Worker / WorkBox 虽然相互之间有着千丝万缕的联系，但是，他们工作的位面不一样。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxlamuaofxj31240fmgmp.jpg\" alt=\"image-20211221112823453\"></p>\n<h4 id=\"1-1-Service-Worker\"><a href=\"#1-1-Service-Worker\" class=\"headerlink\" title=\"1. 1 Service Worker\"></a>1. 1 Service Worker</h4><ul>\n<li>Service Worker 工作在浏览器的worker进程中，API设计是纯异步的。所以同步的API在不能在其上面调用和使用。</li>\n<li>Service worker运行在worker上下文，因此它不能访问DOM。</li>\n<li>Service workers只能由HTTPS承载。（开发环境认可： localhost or 127.0.0.1）</li>\n<li>使用前，需要确认兼容性。（<a href=\"https://caniuse.com/?search=Service%20Worker%EF%BC%89\">https://caniuse.com/?search=Service%20Worker）</a></li>\n</ul>\n<h4 id=\"1-2-PWA-（Progressive-Web-App）\"><a href=\"#1-2-PWA-（Progressive-Web-App）\" class=\"headerlink\" title=\"1.2 PWA （Progressive Web App）\"></a>1.2 PWA （Progressive Web App）</h4><ul>\n<li><p>用户端存储：Cache、IndexedDB，但是使用前要注意不同浏览器厂商对应的存储大小是有限的。溢出的话容易造成I/O失败。</p>\n</li>\n<li><p>关注 ： <a href=\"https://web.dev/pwa-checklist/#exemplary\">https://web.dev/pwa-checklist/#exemplary</a> 详细列举了 PWA 有哪些优势。</p>\n</li>\n<li><p>请搞清楚如下几个 Manifest</p>\n<table>\n<thead>\n<tr>\n<th><code>html</code>标签的<code>manifest</code>属性: <a href=\"https://link.segmentfault.com/?enc=30FUPA+0OF6S8jcR+tiy6w==.HQfRYNa7bCuePN0A7niiqhgM5Puuf2cpEO2DOXmUdx/GMnuhEc2LPlRxvzCBpKmCqUoecRqV9Djwdtd5VlSsJt4E+PM+V68ZFZgexgB0NbI=\">离线缓存</a>（目前已被废弃）</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><a href=\"https://link.segmentfault.com/?enc=3uYS+FS2GnqcfbLMGXI4jg==.cMqJMTrtQpDJhGjKLO68V2f2C6jpt9ducPhvcYmscQYNzA8h9A3rCsbYm/io9UTuBfUZ7YEKEINj2xE1H/GrLw==\">PWA</a>: 将Web应用程序安装到设备的主屏幕</td>\n</tr>\n<tr>\n<td>webpack中<a href=\"https://link.segmentfault.com/?enc=l3XiYvyvmeI3JdAAqzzvrQ==.ktTdDfXIuLCHOKl+vDPi3HXlUrXH6l3xGk3y264UcPN0ekiR4P98WtlW0t5lJ7msjmZn/eTAbFkIItR0D1ckfQ==\">webpack-manifest-plugin</a>插件打包出来的<code>manifest.json</code>文件，用来生成一份资源清单，为后端渲染服务</td>\n</tr>\n<tr>\n<td>webpack中<a href=\"https://link.segmentfault.com/?enc=nlZhAFjfVIrvKisyS/szGw==.qMADE2SbyN1uREswaprW7SqyrlrjoMTHAc1WCZ/xSK0N/qkOOtFKTraF21YFUjvI\">DLL</a>打包时,输出的<code>manifest.json</code>文件，用来分析已经打包过的文件，优化打包速度和大小</td>\n</tr>\n<tr>\n<td>webpack中<a href=\"https://link.segmentfault.com/?enc=mA6r/dGrhlWqzosrYJc5eQ==.89YiF+uDET6nLBPORl39UYZmPdk2eFLyTMgNVeWjOWd4m8fmUR2s/YJ1oyMZnkYP\">manifest</a>运行时代码</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>下面是 PWA 中 manifest 的编写示例：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">  <span class=\"attr\">&quot;name&quot;</span> : <span class=\"string\">&quot;Minimal PWA&quot;</span> , </span><br><span class=\"line\">  <span class=\"attr\">&quot;short_name&quot;</span> : <span class=\"string\">&quot;PWA Demo&quot;</span> , </span><br><span class=\"line\">  <span class=\"attr\">&quot;display&quot;</span> : <span class=\"string\">&quot;standalone&quot;</span> , </span><br><span class=\"line\">  <span class=\"attr\">&quot;start_url&quot;</span> : <span class=\"string\">&quot;/&quot;</span> , </span><br><span class=\"line\">  <span class=\"attr\">&quot;theme_color&quot;</span> : <span class=\"string\">&quot;#313131&quot;</span> , </span><br><span class=\"line\">  <span class=\"attr\">&quot;background_color&quot;</span> : <span class=\"string\">&quot;#313131&quot;</span> , </span><br><span class=\"line\">  <span class=\"attr\">&quot;icons&quot;</span> : [ </span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;src&quot;</span>: <span class=\"string\">&quot;images/touch/homescreen48.png&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;sizes&quot;</span>: <span class=\"string\">&quot;48x48&quot;</span>,</span><br><span class=\"line\">      <span class=\"attr\">&quot;type&quot;</span>: <span class=\"string\">&quot;image/png&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   ] </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"1-3-workbox\"><a href=\"#1-3-workbox\" class=\"headerlink\" title=\"1.3 workbox\"></a>1.3 workbox</h4><p>Workbox 是一组库，可以为 Progressive Web App 提供生产就绪的 Service Worker。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxmvvbunp3j31l40kmq4o.jpg\" alt=\"image-20211222202841855\"></p>\n"},{"title":"TypeScript 使用","_content":"\n# TypeScript 使用\n\n### 数组\n```javscript\ntype arrT = number[]\ntype arrT = Array<number>\nconst arr: arrT = [1,2,3];\n```\n### string number boolean\n```javascript\nconst a: string = \"1\"\nconst a: number = 1\nconst a: boolean = false\n```\n### 函数参数 & 返回值\n```javascript\nfunction greet(name: string): void {}\n```\n### 对象\n```javascript\nfunction printCoord(pt: { x: number; y: number }) {\n  console.log(\"The coordinate's x value is \" + pt.x);\n  console.log(\"The coordinate's y value is \" + pt.y);\n}\n\n// 可选属性\nfunction printName(obj: { first: string; last?: string }) {\n  // ...\n}\n```\n### 联合类型\n```javascript\nfunction printId(id: number | string) {\n  console.log(\"Your ID is: \" + id);\n}\n// OK\nprintId(101);\n// OK\nprintId(\"202\");\n// Error\nprintId({ myID: 22342 });\n```\n### 接口\n```javascript\ninterface Point {\n  x: number;\n  y: number;\n}\n\nfunction printCoord(pt: Point) {\n  console.log(\"The coordinate's x value is \" + pt.x);\n  console.log(\"The coordinate's y value is \" + pt.y);\n}\n\nprintCoord({ x: 100, y: 100 });\n```\n### 类型别名\n```javascript\ntype UserInputSanitizedString = string;\n\nfunction sanitizeInput(str: string): UserInputSanitizedString {\n  return sanitize(str);\n}\n```\n\n**别名：在于不能重新打开类型**\n\n**接口：可以添加​​新属性并且始终可扩展**\n\n### 类型断言\n```javascript\nconst myCanvas = document.getElementById(\"main_canvas\") as HTMLCanvasElement;\n```\n\n### null & undefined\n\n* `strictNullChecks` === off 可以null或undefined仍然可以正常访问的值。\n* `strictNullChecks` === on 当值为null or undefined，您需要在对该值使用方法或属性之前测试这些值。\n\n### 非空断言\n```javascript\nfunction liveDangerously(x?: number | null) {\n  console.log(x!.toFixed());\n}\n```\n### typeof 类型守卫\n```javascript\nfunction printAll(strs: string | string[] | null) {\n  if (typeof strs === \"object\") {\n    for (const s of strs) {\n      console.log(s);\n    }\n  } else if (typeof strs === \"string\") {\n    console.log(strs);\n  } else {\n    // do nothing\n  }\n}\n```\n### 类型谓词\n```javascript\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n```\n### keyof\n```javascript\ntype Person = {\n  name: string;\n  age: number;\n}\ntype PersonKey = keyof Person;  // PersonKey得到的类型为 'name' | 'age'\n```\n### 泛型工具\n#### 1. 将泛型中全部属性变为可选的\n```javascript\ntype Partial<T> = {\n    [P in keyof T]?: T[P]\n}\n```\n#### 2. 将 K 中所有属性值转化为 T 类型，我们常用它来申明一个普通 object 对象\n```javascript\ntype Record<K extends keyof any, T> = {\n    [key in K]: T\n}\n```\n#### 3. 将 T 类型中的 K 键列表提取出来，生成新的子键值对类型\n```javascript\ntype Pick<T, K extends keyof T> = {\n    [P in K]: T[P]\n}\n```\n#### 4. 在 T 类型中，去除 T 类型和 U 类型的交集，返回剩余的部分\n```javascript\ntype Exclude<T, U> = T extends U ? never : T\n```\n#### 5. 适用于键值对对象的 Exclude，它会去除类型 T 中包含 K 的键值对\n```javascript\n// Exclude<keyof T, K> 返回的是 T/K 之间的交集\n// 并把不是交集的部分提取出来\ntype Omit = Pick<T, Exclude<keyof T, K>>\n```\n#### 6. 此工具就是获取 T 类型(函数)对应的返回值类型\n```javascript\n// infer 推断返回值类型\ntype ReturnType<T extends (...args: any) => any>\n  = T extends (...args: any) => infer R ? R : any;\n// 举例\nfunction foo(x: string | number): string | number { /*..*/ }\ntype FooType = ReturnType<foo>;  // string | number\n```\n#### 7. 将类型 T 中所有的属性变为必选项\n```javascript\n// -? 理解为就是 TS 中把?可选属性减去的意思\ntype Required<T> = {\n  [P in keyof T]-?: T[P]\n}\n```\n","source":"_posts/TypeScript 使用.md","raw":"---\ntitle: TypeScript 使用\ntags: js\n---\n\n# TypeScript 使用\n\n### 数组\n```javscript\ntype arrT = number[]\ntype arrT = Array<number>\nconst arr: arrT = [1,2,3];\n```\n### string number boolean\n```javascript\nconst a: string = \"1\"\nconst a: number = 1\nconst a: boolean = false\n```\n### 函数参数 & 返回值\n```javascript\nfunction greet(name: string): void {}\n```\n### 对象\n```javascript\nfunction printCoord(pt: { x: number; y: number }) {\n  console.log(\"The coordinate's x value is \" + pt.x);\n  console.log(\"The coordinate's y value is \" + pt.y);\n}\n\n// 可选属性\nfunction printName(obj: { first: string; last?: string }) {\n  // ...\n}\n```\n### 联合类型\n```javascript\nfunction printId(id: number | string) {\n  console.log(\"Your ID is: \" + id);\n}\n// OK\nprintId(101);\n// OK\nprintId(\"202\");\n// Error\nprintId({ myID: 22342 });\n```\n### 接口\n```javascript\ninterface Point {\n  x: number;\n  y: number;\n}\n\nfunction printCoord(pt: Point) {\n  console.log(\"The coordinate's x value is \" + pt.x);\n  console.log(\"The coordinate's y value is \" + pt.y);\n}\n\nprintCoord({ x: 100, y: 100 });\n```\n### 类型别名\n```javascript\ntype UserInputSanitizedString = string;\n\nfunction sanitizeInput(str: string): UserInputSanitizedString {\n  return sanitize(str);\n}\n```\n\n**别名：在于不能重新打开类型**\n\n**接口：可以添加​​新属性并且始终可扩展**\n\n### 类型断言\n```javascript\nconst myCanvas = document.getElementById(\"main_canvas\") as HTMLCanvasElement;\n```\n\n### null & undefined\n\n* `strictNullChecks` === off 可以null或undefined仍然可以正常访问的值。\n* `strictNullChecks` === on 当值为null or undefined，您需要在对该值使用方法或属性之前测试这些值。\n\n### 非空断言\n```javascript\nfunction liveDangerously(x?: number | null) {\n  console.log(x!.toFixed());\n}\n```\n### typeof 类型守卫\n```javascript\nfunction printAll(strs: string | string[] | null) {\n  if (typeof strs === \"object\") {\n    for (const s of strs) {\n      console.log(s);\n    }\n  } else if (typeof strs === \"string\") {\n    console.log(strs);\n  } else {\n    // do nothing\n  }\n}\n```\n### 类型谓词\n```javascript\nfunction isFish(pet: Fish | Bird): pet is Fish {\n  return (pet as Fish).swim !== undefined;\n}\n```\n### keyof\n```javascript\ntype Person = {\n  name: string;\n  age: number;\n}\ntype PersonKey = keyof Person;  // PersonKey得到的类型为 'name' | 'age'\n```\n### 泛型工具\n#### 1. 将泛型中全部属性变为可选的\n```javascript\ntype Partial<T> = {\n    [P in keyof T]?: T[P]\n}\n```\n#### 2. 将 K 中所有属性值转化为 T 类型，我们常用它来申明一个普通 object 对象\n```javascript\ntype Record<K extends keyof any, T> = {\n    [key in K]: T\n}\n```\n#### 3. 将 T 类型中的 K 键列表提取出来，生成新的子键值对类型\n```javascript\ntype Pick<T, K extends keyof T> = {\n    [P in K]: T[P]\n}\n```\n#### 4. 在 T 类型中，去除 T 类型和 U 类型的交集，返回剩余的部分\n```javascript\ntype Exclude<T, U> = T extends U ? never : T\n```\n#### 5. 适用于键值对对象的 Exclude，它会去除类型 T 中包含 K 的键值对\n```javascript\n// Exclude<keyof T, K> 返回的是 T/K 之间的交集\n// 并把不是交集的部分提取出来\ntype Omit = Pick<T, Exclude<keyof T, K>>\n```\n#### 6. 此工具就是获取 T 类型(函数)对应的返回值类型\n```javascript\n// infer 推断返回值类型\ntype ReturnType<T extends (...args: any) => any>\n  = T extends (...args: any) => infer R ? R : any;\n// 举例\nfunction foo(x: string | number): string | number { /*..*/ }\ntype FooType = ReturnType<foo>;  // string | number\n```\n#### 7. 将类型 T 中所有的属性变为必选项\n```javascript\n// -? 理解为就是 TS 中把?可选属性减去的意思\ntype Required<T> = {\n  [P in keyof T]-?: T[P]\n}\n```\n","slug":"TypeScript 使用","published":1,"date":"2021-07-13T08:27:37.885Z","updated":"2021-12-28T02:05:30.964Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxph7qmg000j1op728rc0dfb","content":"<h1 id=\"TypeScript-使用\"><a href=\"#TypeScript-使用\" class=\"headerlink\" title=\"TypeScript 使用\"></a>TypeScript 使用</h1><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type arrT = number[]</span><br><span class=\"line\">type arrT = Array&lt;number&gt;</span><br><span class=\"line\">const arr: arrT = [1,2,3];</span><br></pre></td></tr></table></figure>\n<h3 id=\"string-number-boolean\"><a href=\"#string-number-boolean\" class=\"headerlink\" title=\"string number boolean\"></a>string number boolean</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a: string = <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a: number = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a: boolean = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"函数参数-amp-返回值\"><a href=\"#函数参数-amp-返回值\" class=\"headerlink\" title=\"函数参数 &amp; 返回值\"></a>函数参数 &amp; 返回值</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greet</span>(<span class=\"params\">name: string</span>): <span class=\"title\">void</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printCoord</span>(<span class=\"params\">pt: &#123; x: number; y: number &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;The coordinate&#x27;s x value is &quot;</span> + pt.x);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;The coordinate&#x27;s y value is &quot;</span> + pt.y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可选属性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printName</span>(<span class=\"params\">obj: &#123; first: string; last?: string &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printId</span>(<span class=\"params\">id: number | string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Your ID is: &quot;</span> + id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// OK</span></span><br><span class=\"line\">printId(<span class=\"number\">101</span>);</span><br><span class=\"line\"><span class=\"comment\">// OK</span></span><br><span class=\"line\">printId(<span class=\"string\">&quot;202&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// Error</span></span><br><span class=\"line\">printId(&#123; <span class=\"attr\">myID</span>: <span class=\"number\">22342</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Point &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: number;</span><br><span class=\"line\">  y: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printCoord</span>(<span class=\"params\">pt: Point</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;The coordinate&#x27;s x value is &quot;</span> + pt.x);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;The coordinate&#x27;s y value is &quot;</span> + pt.y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">printCoord(&#123; <span class=\"attr\">x</span>: <span class=\"number\">100</span>, <span class=\"attr\">y</span>: <span class=\"number\">100</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type UserInputSanitizedString = string;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sanitizeInput</span>(<span class=\"params\">str: string</span>): <span class=\"title\">UserInputSanitizedString</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sanitize(str);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>别名：在于不能重新打开类型</strong></p>\n<p><strong>接口：可以添加​​新属性并且始终可扩展</strong></p>\n<h3 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myCanvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;main_canvas&quot;</span>) <span class=\"keyword\">as</span> HTMLCanvasElement;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"null-amp-undefined\"><a href=\"#null-amp-undefined\" class=\"headerlink\" title=\"null &amp; undefined\"></a>null &amp; undefined</h3><ul>\n<li><code>strictNullChecks</code> === off 可以null或undefined仍然可以正常访问的值。</li>\n<li><code>strictNullChecks</code> === on 当值为null or undefined，您需要在对该值使用方法或属性之前测试这些值。</li>\n</ul>\n<h3 id=\"非空断言\"><a href=\"#非空断言\" class=\"headerlink\" title=\"非空断言\"></a>非空断言</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">liveDangerously</span>(<span class=\"params\">x?: number | <span class=\"literal\">null</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x!.toFixed());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"typeof-类型守卫\"><a href=\"#typeof-类型守卫\" class=\"headerlink\" title=\"typeof 类型守卫\"></a>typeof 类型守卫</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printAll</span>(<span class=\"params\">strs: string | string[] | <span class=\"literal\">null</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> s <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(strs);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do nothing</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"类型谓词\"><a href=\"#类型谓词\" class=\"headerlink\" title=\"类型谓词\"></a>类型谓词</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFish</span>(<span class=\"params\">pet: Fish | Bird</span>): <span class=\"title\">pet</span> <span class=\"title\">is</span> <span class=\"title\">Fish</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (pet <span class=\"keyword\">as</span> Fish).swim !== <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"keyof\"><a href=\"#keyof\" class=\"headerlink\" title=\"keyof\"></a>keyof</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: string;</span><br><span class=\"line\">  age: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">type PersonKey = keyof Person;  <span class=\"comment\">// PersonKey得到的类型为 &#x27;name&#x27; | &#x27;age&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"泛型工具\"><a href=\"#泛型工具\" class=\"headerlink\" title=\"泛型工具\"></a>泛型工具</h3><h4 id=\"1-将泛型中全部属性变为可选的\"><a href=\"#1-将泛型中全部属性变为可选的\" class=\"headerlink\" title=\"1. 将泛型中全部属性变为可选的\"></a>1. 将泛型中全部属性变为可选的</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Partial&lt;T&gt; = &#123;</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> keyof T]?: T[P]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-将-K-中所有属性值转化为-T-类型，我们常用它来申明一个普通-object-对象\"><a href=\"#2-将-K-中所有属性值转化为-T-类型，我们常用它来申明一个普通-object-对象\" class=\"headerlink\" title=\"2. 将 K 中所有属性值转化为 T 类型，我们常用它来申明一个普通 object 对象\"></a>2. 将 K 中所有属性值转化为 T 类型，我们常用它来申明一个普通 object 对象</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Record&lt;K <span class=\"keyword\">extends</span> keyof any, T&gt; = &#123;</span><br><span class=\"line\">    [key <span class=\"keyword\">in</span> K]: T</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-将-T-类型中的-K-键列表提取出来，生成新的子键值对类型\"><a href=\"#3-将-T-类型中的-K-键列表提取出来，生成新的子键值对类型\" class=\"headerlink\" title=\"3. 将 T 类型中的 K 键列表提取出来，生成新的子键值对类型\"></a>3. 将 T 类型中的 K 键列表提取出来，生成新的子键值对类型</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Pick&lt;T, K <span class=\"keyword\">extends</span> keyof T&gt; = &#123;</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> K]: T[P]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-在-T-类型中，去除-T-类型和-U-类型的交集，返回剩余的部分\"><a href=\"#4-在-T-类型中，去除-T-类型和-U-类型的交集，返回剩余的部分\" class=\"headerlink\" title=\"4. 在 T 类型中，去除 T 类型和 U 类型的交集，返回剩余的部分\"></a>4. 在 T 类型中，去除 T 类型和 U 类型的交集，返回剩余的部分</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Exclude&lt;T, U&gt; = T <span class=\"keyword\">extends</span> U ? never : T</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-适用于键值对对象的-Exclude，它会去除类型-T-中包含-K-的键值对\"><a href=\"#5-适用于键值对对象的-Exclude，它会去除类型-T-中包含-K-的键值对\" class=\"headerlink\" title=\"5. 适用于键值对对象的 Exclude，它会去除类型 T 中包含 K 的键值对\"></a>5. 适用于键值对对象的 Exclude，它会去除类型 T 中包含 K 的键值对</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Exclude&lt;keyof T, K&gt; 返回的是 T/K 之间的交集</span></span><br><span class=\"line\"><span class=\"comment\">// 并把不是交集的部分提取出来</span></span><br><span class=\"line\">type Omit = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-此工具就是获取-T-类型-函数-对应的返回值类型\"><a href=\"#6-此工具就是获取-T-类型-函数-对应的返回值类型\" class=\"headerlink\" title=\"6. 此工具就是获取 T 类型(函数)对应的返回值类型\"></a>6. 此工具就是获取 T 类型(函数)对应的返回值类型</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// infer 推断返回值类型</span></span><br><span class=\"line\">type ReturnType&lt;T <span class=\"keyword\">extends</span> (...args: any) =&gt; any&gt;</span><br><span class=\"line\">  = T <span class=\"keyword\">extends</span> (...args: any) =&gt; infer R ? R : any;</span><br><span class=\"line\"><span class=\"comment\">// 举例</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x: string | number</span>): <span class=\"title\">string</span> | <span class=\"title\">number</span> </span>&#123; <span class=\"comment\">/*..*/</span> &#125;</span><br><span class=\"line\">type FooType = ReturnType&lt;foo&gt;;  <span class=\"comment\">// string | number</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"7-将类型-T-中所有的属性变为必选项\"><a href=\"#7-将类型-T-中所有的属性变为必选项\" class=\"headerlink\" title=\"7. 将类型 T 中所有的属性变为必选项\"></a>7. 将类型 T 中所有的属性变为必选项</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// -? 理解为就是 TS 中把?可选属性减去的意思</span></span><br><span class=\"line\">type Required&lt;T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> keyof T]-?: T[P]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"TypeScript-使用\"><a href=\"#TypeScript-使用\" class=\"headerlink\" title=\"TypeScript 使用\"></a>TypeScript 使用</h1><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type arrT = number[]</span><br><span class=\"line\">type arrT = Array&lt;number&gt;</span><br><span class=\"line\">const arr: arrT = [1,2,3];</span><br></pre></td></tr></table></figure>\n<h3 id=\"string-number-boolean\"><a href=\"#string-number-boolean\" class=\"headerlink\" title=\"string number boolean\"></a>string number boolean</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a: string = <span class=\"string\">&quot;1&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a: number = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> a: boolean = <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"函数参数-amp-返回值\"><a href=\"#函数参数-amp-返回值\" class=\"headerlink\" title=\"函数参数 &amp; 返回值\"></a>函数参数 &amp; 返回值</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">greet</span>(<span class=\"params\">name: string</span>): <span class=\"title\">void</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printCoord</span>(<span class=\"params\">pt: &#123; x: number; y: number &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;The coordinate&#x27;s x value is &quot;</span> + pt.x);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;The coordinate&#x27;s y value is &quot;</span> + pt.y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可选属性</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printName</span>(<span class=\"params\">obj: &#123; first: string; last?: string &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"联合类型\"><a href=\"#联合类型\" class=\"headerlink\" title=\"联合类型\"></a>联合类型</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printId</span>(<span class=\"params\">id: number | string</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;Your ID is: &quot;</span> + id);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// OK</span></span><br><span class=\"line\">printId(<span class=\"number\">101</span>);</span><br><span class=\"line\"><span class=\"comment\">// OK</span></span><br><span class=\"line\">printId(<span class=\"string\">&quot;202&quot;</span>);</span><br><span class=\"line\"><span class=\"comment\">// Error</span></span><br><span class=\"line\">printId(&#123; <span class=\"attr\">myID</span>: <span class=\"number\">22342</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Point &#123;</span><br><span class=\"line\">  <span class=\"attr\">x</span>: number;</span><br><span class=\"line\">  y: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printCoord</span>(<span class=\"params\">pt: Point</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;The coordinate&#x27;s x value is &quot;</span> + pt.x);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;The coordinate&#x27;s y value is &quot;</span> + pt.y);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">printCoord(&#123; <span class=\"attr\">x</span>: <span class=\"number\">100</span>, <span class=\"attr\">y</span>: <span class=\"number\">100</span> &#125;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"类型别名\"><a href=\"#类型别名\" class=\"headerlink\" title=\"类型别名\"></a>类型别名</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type UserInputSanitizedString = string;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sanitizeInput</span>(<span class=\"params\">str: string</span>): <span class=\"title\">UserInputSanitizedString</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> sanitize(str);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>别名：在于不能重新打开类型</strong></p>\n<p><strong>接口：可以添加​​新属性并且始终可扩展</strong></p>\n<h3 id=\"类型断言\"><a href=\"#类型断言\" class=\"headerlink\" title=\"类型断言\"></a>类型断言</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myCanvas = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&quot;main_canvas&quot;</span>) <span class=\"keyword\">as</span> HTMLCanvasElement;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"null-amp-undefined\"><a href=\"#null-amp-undefined\" class=\"headerlink\" title=\"null &amp; undefined\"></a>null &amp; undefined</h3><ul>\n<li><code>strictNullChecks</code> === off 可以null或undefined仍然可以正常访问的值。</li>\n<li><code>strictNullChecks</code> === on 当值为null or undefined，您需要在对该值使用方法或属性之前测试这些值。</li>\n</ul>\n<h3 id=\"非空断言\"><a href=\"#非空断言\" class=\"headerlink\" title=\"非空断言\"></a>非空断言</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">liveDangerously</span>(<span class=\"params\">x?: number | <span class=\"literal\">null</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x!.toFixed());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"typeof-类型守卫\"><a href=\"#typeof-类型守卫\" class=\"headerlink\" title=\"typeof 类型守卫\"></a>typeof 类型守卫</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">printAll</span>(<span class=\"params\">strs: string | string[] | <span class=\"literal\">null</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> s <span class=\"keyword\">of</span> strs) &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> strs === <span class=\"string\">&quot;string&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(strs);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// do nothing</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"类型谓词\"><a href=\"#类型谓词\" class=\"headerlink\" title=\"类型谓词\"></a>类型谓词</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isFish</span>(<span class=\"params\">pet: Fish | Bird</span>): <span class=\"title\">pet</span> <span class=\"title\">is</span> <span class=\"title\">Fish</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (pet <span class=\"keyword\">as</span> Fish).swim !== <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"keyof\"><a href=\"#keyof\" class=\"headerlink\" title=\"keyof\"></a>keyof</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Person = &#123;</span><br><span class=\"line\">  <span class=\"attr\">name</span>: string;</span><br><span class=\"line\">  age: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">type PersonKey = keyof Person;  <span class=\"comment\">// PersonKey得到的类型为 &#x27;name&#x27; | &#x27;age&#x27;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"泛型工具\"><a href=\"#泛型工具\" class=\"headerlink\" title=\"泛型工具\"></a>泛型工具</h3><h4 id=\"1-将泛型中全部属性变为可选的\"><a href=\"#1-将泛型中全部属性变为可选的\" class=\"headerlink\" title=\"1. 将泛型中全部属性变为可选的\"></a>1. 将泛型中全部属性变为可选的</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Partial&lt;T&gt; = &#123;</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> keyof T]?: T[P]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-将-K-中所有属性值转化为-T-类型，我们常用它来申明一个普通-object-对象\"><a href=\"#2-将-K-中所有属性值转化为-T-类型，我们常用它来申明一个普通-object-对象\" class=\"headerlink\" title=\"2. 将 K 中所有属性值转化为 T 类型，我们常用它来申明一个普通 object 对象\"></a>2. 将 K 中所有属性值转化为 T 类型，我们常用它来申明一个普通 object 对象</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Record&lt;K <span class=\"keyword\">extends</span> keyof any, T&gt; = &#123;</span><br><span class=\"line\">    [key <span class=\"keyword\">in</span> K]: T</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-将-T-类型中的-K-键列表提取出来，生成新的子键值对类型\"><a href=\"#3-将-T-类型中的-K-键列表提取出来，生成新的子键值对类型\" class=\"headerlink\" title=\"3. 将 T 类型中的 K 键列表提取出来，生成新的子键值对类型\"></a>3. 将 T 类型中的 K 键列表提取出来，生成新的子键值对类型</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Pick&lt;T, K <span class=\"keyword\">extends</span> keyof T&gt; = &#123;</span><br><span class=\"line\">    [P <span class=\"keyword\">in</span> K]: T[P]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-在-T-类型中，去除-T-类型和-U-类型的交集，返回剩余的部分\"><a href=\"#4-在-T-类型中，去除-T-类型和-U-类型的交集，返回剩余的部分\" class=\"headerlink\" title=\"4. 在 T 类型中，去除 T 类型和 U 类型的交集，返回剩余的部分\"></a>4. 在 T 类型中，去除 T 类型和 U 类型的交集，返回剩余的部分</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type Exclude&lt;T, U&gt; = T <span class=\"keyword\">extends</span> U ? never : T</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-适用于键值对对象的-Exclude，它会去除类型-T-中包含-K-的键值对\"><a href=\"#5-适用于键值对对象的-Exclude，它会去除类型-T-中包含-K-的键值对\" class=\"headerlink\" title=\"5. 适用于键值对对象的 Exclude，它会去除类型 T 中包含 K 的键值对\"></a>5. 适用于键值对对象的 Exclude，它会去除类型 T 中包含 K 的键值对</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Exclude&lt;keyof T, K&gt; 返回的是 T/K 之间的交集</span></span><br><span class=\"line\"><span class=\"comment\">// 并把不是交集的部分提取出来</span></span><br><span class=\"line\">type Omit = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-此工具就是获取-T-类型-函数-对应的返回值类型\"><a href=\"#6-此工具就是获取-T-类型-函数-对应的返回值类型\" class=\"headerlink\" title=\"6. 此工具就是获取 T 类型(函数)对应的返回值类型\"></a>6. 此工具就是获取 T 类型(函数)对应的返回值类型</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// infer 推断返回值类型</span></span><br><span class=\"line\">type ReturnType&lt;T <span class=\"keyword\">extends</span> (...args: any) =&gt; any&gt;</span><br><span class=\"line\">  = T <span class=\"keyword\">extends</span> (...args: any) =&gt; infer R ? R : any;</span><br><span class=\"line\"><span class=\"comment\">// 举例</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">x: string | number</span>): <span class=\"title\">string</span> | <span class=\"title\">number</span> </span>&#123; <span class=\"comment\">/*..*/</span> &#125;</span><br><span class=\"line\">type FooType = ReturnType&lt;foo&gt;;  <span class=\"comment\">// string | number</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"7-将类型-T-中所有的属性变为必选项\"><a href=\"#7-将类型-T-中所有的属性变为必选项\" class=\"headerlink\" title=\"7. 将类型 T 中所有的属性变为必选项\"></a>7. 将类型 T 中所有的属性变为必选项</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// -? 理解为就是 TS 中把?可选属性减去的意思</span></span><br><span class=\"line\">type Required&lt;T&gt; = &#123;</span><br><span class=\"line\">  [P <span class=\"keyword\">in</span> keyof T]-?: T[P]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"Vue-Loader Hot Reload","_content":"\n# Vue-Loader Hot Reload\n\n### Hot Reload 触发时机\n\n```javascript\nconst needsHotReload = (\n    !isServer &&\n    !isProduction &&\n    (descriptor.script || descriptor.template) &&\n    options.hotReload !== false\n)\n```\n\n* **isServer**  判断当前是浏览器环境还是Node环境；\n* **isProduction** 判断只有是开发环境才进行HMR；\n* **descriptor** 对象从 **@vue/component-compiler-utils** 提供的 **parse** 函数处理所得。\n* **options** 从 **loader-utils** 返回值中所得。\n\n### Loader-utils\n\n![image-20211227185740127](https://tva1.sinaimg.cn/large/008i3skNly1gxslc4bkbbj31700hmwfv.jpg)\n\n**loader-utils** 本身是**webpack**提供的插理解是**webpack**本身提供的一些工具方法。\n\n![image-20211227185750549](https://tva1.sinaimg.cn/large/008i3skNly1gxslcawdxoj31kg0modjf.jpg)\n\n不难看出，**loaderUtils.getOptions** 方法本质是序列化 **webpack** 运行时的上下文。\n\n### vue-hot-reload-api \n\n#### 调用链路分析\n\n![image-20211227185804203](https://tva1.sinaimg.cn/large/008i3skNly1gxslcja4d3j30u30u0god.jpg)\n\n通过 Debug 可以宏观意义上的去体会 **vue-hot-reload-api** 提供的能力。\n\n![image-20211227185816016](https://tva1.sinaimg.cn/large/008i3skNly1gxslcqtt1ij31i40s243n.jpg)\n\n#### 钩子 API 汇总\n\n| 名称 | 类型 | 作用 |\n| :--- | :--- | :--- |\n| compatible | Boolen | vue-hot-reload-api 只作用于 vue 2.x 版本 |\n| createRecord | Function | 以模块ID为key， |\n| install | Function | 将 vue 注册到 vue-hot-reload-api  |\n| isRecorded | Function | 判断当前修改的文件是否曾经被修改过 |\n| reload | Function | 组件重新加载options |\n| rerender | Function | 修改后的components 重新 render |\n\n#### 实现存储\n\n```javascript\nconst map = Object.create(null)\nif (typeof window !== 'undefined') {\n  window.__VUE_HOT_MAP__ = map\n}\n```\n\n源码中，hot-reload 会缓存在一个对象中。并且对外暴露了更新组件时对象内部的结构。如下如所示：\n\n![image-20211227185833373](https://tva1.sinaimg.cn/large/008i3skNly1gxsld1j6eij31k60f6mzw.jpg)\n\n### 答疑解惑\n\n#### 1. module.hot.accept 做了什么？\n\n```javascript\n// dep: ./src/components/HelloWorld.vue?vue&type=template&id=469af010&scoped=true&\nconst hot = {\n\t_acceptedDependencies: {}\n}\nfunction(dep, callback) {\n\tif (dep === undefined) {\n\t\thot._selfAccepted = true;\n\t}\n\telse if (typeof dep === \"function\") {\n\t\thot._selfAccepted = dep;\n\t}\n\telse if (typeof dep === \"object\") {\n\t\tfor (var i = 0; i < dep.length; i++) {\n\t\t\thot._acceptedDependencies[dep[i]] = callback || function() {};\n\t\t}\n\t}\n\telse {\n\t\thot._acceptedDependencies[dep] = callback || function() {};\n\t}\n},\n```\n\n从上面代码中可以体会到，\\*.vue 一旦发生改变，vue文件在这里是被看成是 module 。module.hot.accept 只是单方面去存储每一次 \\*.vue 文件的修改的回调函数。试想，当同一个文件被多次修改后，最后一次修改完成后的内容，才对我们有意义。所以当一次 HMR 过程中，vue 会将文件的请求路径作为KEY，对应修改的 render 回调函数作为 value 。\n\n#### 3. vue-hot-reload-api rerender 做了什么？\n\n![image-20211227185846460](https://tva1.sinaimg.cn/large/008i3skNly1gxslda074aj30z20jeq4w.jpg)\n\nrerender 底层是区分 function 组件或者是  options 组件的，阅读代码可知，当我们修改一个文件的时候，如果这个组件是没有options的话，意味着这个组件是一个纯静态的UI组件。那么我们修改 template 中的文案时，只需要通知到相应的组件，进行 forceUpdate 就可以了。当存在options 时候，就需要我们覆盖重置组件内的options，并且执行 forceUpdate。\n\n### 总结：\n\nwebpack + vue-loader 提供了解析模板的能力，在开发阶段，帮我们顺利定位到了我们修改的是那个组件，并且完美的解析了我们修改的组件形成DSL。那么推动vue组件重新渲染的，是 vue 中 forceUpdate 的功劳。\n\n\n\n","source":"_posts/Vue-Loader Hot Reload.md","raw":"---\ntitle: Vue-Loader Hot Reload\ntags: vue\n---\n\n# Vue-Loader Hot Reload\n\n### Hot Reload 触发时机\n\n```javascript\nconst needsHotReload = (\n    !isServer &&\n    !isProduction &&\n    (descriptor.script || descriptor.template) &&\n    options.hotReload !== false\n)\n```\n\n* **isServer**  判断当前是浏览器环境还是Node环境；\n* **isProduction** 判断只有是开发环境才进行HMR；\n* **descriptor** 对象从 **@vue/component-compiler-utils** 提供的 **parse** 函数处理所得。\n* **options** 从 **loader-utils** 返回值中所得。\n\n### Loader-utils\n\n![image-20211227185740127](https://tva1.sinaimg.cn/large/008i3skNly1gxslc4bkbbj31700hmwfv.jpg)\n\n**loader-utils** 本身是**webpack**提供的插理解是**webpack**本身提供的一些工具方法。\n\n![image-20211227185750549](https://tva1.sinaimg.cn/large/008i3skNly1gxslcawdxoj31kg0modjf.jpg)\n\n不难看出，**loaderUtils.getOptions** 方法本质是序列化 **webpack** 运行时的上下文。\n\n### vue-hot-reload-api \n\n#### 调用链路分析\n\n![image-20211227185804203](https://tva1.sinaimg.cn/large/008i3skNly1gxslcja4d3j30u30u0god.jpg)\n\n通过 Debug 可以宏观意义上的去体会 **vue-hot-reload-api** 提供的能力。\n\n![image-20211227185816016](https://tva1.sinaimg.cn/large/008i3skNly1gxslcqtt1ij31i40s243n.jpg)\n\n#### 钩子 API 汇总\n\n| 名称 | 类型 | 作用 |\n| :--- | :--- | :--- |\n| compatible | Boolen | vue-hot-reload-api 只作用于 vue 2.x 版本 |\n| createRecord | Function | 以模块ID为key， |\n| install | Function | 将 vue 注册到 vue-hot-reload-api  |\n| isRecorded | Function | 判断当前修改的文件是否曾经被修改过 |\n| reload | Function | 组件重新加载options |\n| rerender | Function | 修改后的components 重新 render |\n\n#### 实现存储\n\n```javascript\nconst map = Object.create(null)\nif (typeof window !== 'undefined') {\n  window.__VUE_HOT_MAP__ = map\n}\n```\n\n源码中，hot-reload 会缓存在一个对象中。并且对外暴露了更新组件时对象内部的结构。如下如所示：\n\n![image-20211227185833373](https://tva1.sinaimg.cn/large/008i3skNly1gxsld1j6eij31k60f6mzw.jpg)\n\n### 答疑解惑\n\n#### 1. module.hot.accept 做了什么？\n\n```javascript\n// dep: ./src/components/HelloWorld.vue?vue&type=template&id=469af010&scoped=true&\nconst hot = {\n\t_acceptedDependencies: {}\n}\nfunction(dep, callback) {\n\tif (dep === undefined) {\n\t\thot._selfAccepted = true;\n\t}\n\telse if (typeof dep === \"function\") {\n\t\thot._selfAccepted = dep;\n\t}\n\telse if (typeof dep === \"object\") {\n\t\tfor (var i = 0; i < dep.length; i++) {\n\t\t\thot._acceptedDependencies[dep[i]] = callback || function() {};\n\t\t}\n\t}\n\telse {\n\t\thot._acceptedDependencies[dep] = callback || function() {};\n\t}\n},\n```\n\n从上面代码中可以体会到，\\*.vue 一旦发生改变，vue文件在这里是被看成是 module 。module.hot.accept 只是单方面去存储每一次 \\*.vue 文件的修改的回调函数。试想，当同一个文件被多次修改后，最后一次修改完成后的内容，才对我们有意义。所以当一次 HMR 过程中，vue 会将文件的请求路径作为KEY，对应修改的 render 回调函数作为 value 。\n\n#### 3. vue-hot-reload-api rerender 做了什么？\n\n![image-20211227185846460](https://tva1.sinaimg.cn/large/008i3skNly1gxslda074aj30z20jeq4w.jpg)\n\nrerender 底层是区分 function 组件或者是  options 组件的，阅读代码可知，当我们修改一个文件的时候，如果这个组件是没有options的话，意味着这个组件是一个纯静态的UI组件。那么我们修改 template 中的文案时，只需要通知到相应的组件，进行 forceUpdate 就可以了。当存在options 时候，就需要我们覆盖重置组件内的options，并且执行 forceUpdate。\n\n### 总结：\n\nwebpack + vue-loader 提供了解析模板的能力，在开发阶段，帮我们顺利定位到了我们修改的是那个组件，并且完美的解析了我们修改的组件形成DSL。那么推动vue组件重新渲染的，是 vue 中 forceUpdate 的功劳。\n\n\n\n","slug":"Vue-Loader Hot Reload","published":1,"date":"2021-05-28T09:42:21.179Z","updated":"2021-12-28T02:07:49.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxph7qmh000l1op759j4dxor","content":"<h1 id=\"Vue-Loader-Hot-Reload\"><a href=\"#Vue-Loader-Hot-Reload\" class=\"headerlink\" title=\"Vue-Loader Hot Reload\"></a>Vue-Loader Hot Reload</h1><h3 id=\"Hot-Reload-触发时机\"><a href=\"#Hot-Reload-触发时机\" class=\"headerlink\" title=\"Hot Reload 触发时机\"></a>Hot Reload 触发时机</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> needsHotReload = (</span><br><span class=\"line\">    !isServer &amp;&amp;</span><br><span class=\"line\">    !isProduction &amp;&amp;</span><br><span class=\"line\">    (descriptor.script || descriptor.template) &amp;&amp;</span><br><span class=\"line\">    options.hotReload !== <span class=\"literal\">false</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>isServer</strong>  判断当前是浏览器环境还是Node环境；</li>\n<li><strong>isProduction</strong> 判断只有是开发环境才进行HMR；</li>\n<li><strong>descriptor</strong> 对象从 <strong>@vue/component-compiler-utils</strong> 提供的 <strong>parse</strong> 函数处理所得。</li>\n<li><strong>options</strong> 从 <strong>loader-utils</strong> 返回值中所得。</li>\n</ul>\n<h3 id=\"Loader-utils\"><a href=\"#Loader-utils\" class=\"headerlink\" title=\"Loader-utils\"></a>Loader-utils</h3><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxslc4bkbbj31700hmwfv.jpg\" alt=\"image-20211227185740127\"></p>\n<p><strong>loader-utils</strong> 本身是<strong>webpack</strong>提供的插理解是<strong>webpack</strong>本身提供的一些工具方法。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxslcawdxoj31kg0modjf.jpg\" alt=\"image-20211227185750549\"></p>\n<p>不难看出，<strong>loaderUtils.getOptions</strong> 方法本质是序列化 <strong>webpack</strong> 运行时的上下文。</p>\n<h3 id=\"vue-hot-reload-api\"><a href=\"#vue-hot-reload-api\" class=\"headerlink\" title=\"vue-hot-reload-api\"></a>vue-hot-reload-api</h3><h4 id=\"调用链路分析\"><a href=\"#调用链路分析\" class=\"headerlink\" title=\"调用链路分析\"></a>调用链路分析</h4><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxslcja4d3j30u30u0god.jpg\" alt=\"image-20211227185804203\"></p>\n<p>通过 Debug 可以宏观意义上的去体会 <strong>vue-hot-reload-api</strong> 提供的能力。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxslcqtt1ij31i40s243n.jpg\" alt=\"image-20211227185816016\"></p>\n<h4 id=\"钩子-API-汇总\"><a href=\"#钩子-API-汇总\" class=\"headerlink\" title=\"钩子 API 汇总\"></a>钩子 API 汇总</h4><table>\n<thead>\n<tr>\n<th align=\"left\">名称</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">compatible</td>\n<td align=\"left\">Boolen</td>\n<td align=\"left\">vue-hot-reload-api 只作用于 vue 2.x 版本</td>\n</tr>\n<tr>\n<td align=\"left\">createRecord</td>\n<td align=\"left\">Function</td>\n<td align=\"left\">以模块ID为key，</td>\n</tr>\n<tr>\n<td align=\"left\">install</td>\n<td align=\"left\">Function</td>\n<td align=\"left\">将 vue 注册到 vue-hot-reload-api</td>\n</tr>\n<tr>\n<td align=\"left\">isRecorded</td>\n<td align=\"left\">Function</td>\n<td align=\"left\">判断当前修改的文件是否曾经被修改过</td>\n</tr>\n<tr>\n<td align=\"left\">reload</td>\n<td align=\"left\">Function</td>\n<td align=\"left\">组件重新加载options</td>\n</tr>\n<tr>\n<td align=\"left\">rerender</td>\n<td align=\"left\">Function</td>\n<td align=\"left\">修改后的components 重新 render</td>\n</tr>\n</tbody></table>\n<h4 id=\"实现存储\"><a href=\"#实现存储\" class=\"headerlink\" title=\"实现存储\"></a>实现存储</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">&#x27;undefined&#x27;</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.__VUE_HOT_MAP__ = map</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>源码中，hot-reload 会缓存在一个对象中。并且对外暴露了更新组件时对象内部的结构。如下如所示：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsld1j6eij31k60f6mzw.jpg\" alt=\"image-20211227185833373\"></p>\n<h3 id=\"答疑解惑\"><a href=\"#答疑解惑\" class=\"headerlink\" title=\"答疑解惑\"></a>答疑解惑</h3><h4 id=\"1-module-hot-accept-做了什么？\"><a href=\"#1-module-hot-accept-做了什么？\" class=\"headerlink\" title=\"1. module.hot.accept 做了什么？\"></a>1. module.hot.accept 做了什么？</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dep: ./src/components/HelloWorld.vue?vue&amp;type=template&amp;id=469af010&amp;scoped=true&amp;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> hot = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">_acceptedDependencies</span>: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dep, callback</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dep === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">\t\thot._selfAccepted = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> dep === <span class=\"string\">&quot;function&quot;</span>) &#123;</span><br><span class=\"line\">\t\thot._selfAccepted = dep;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> dep === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; dep.length; i++) &#123;</span><br><span class=\"line\">\t\t\thot._acceptedDependencies[dep[i]] = callback || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\thot._acceptedDependencies[dep] = callback || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>从上面代码中可以体会到，*.vue 一旦发生改变，vue文件在这里是被看成是 module 。module.hot.accept 只是单方面去存储每一次 *.vue 文件的修改的回调函数。试想，当同一个文件被多次修改后，最后一次修改完成后的内容，才对我们有意义。所以当一次 HMR 过程中，vue 会将文件的请求路径作为KEY，对应修改的 render 回调函数作为 value 。</p>\n<h4 id=\"3-vue-hot-reload-api-rerender-做了什么？\"><a href=\"#3-vue-hot-reload-api-rerender-做了什么？\" class=\"headerlink\" title=\"3. vue-hot-reload-api rerender 做了什么？\"></a>3. vue-hot-reload-api rerender 做了什么？</h4><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxslda074aj30z20jeq4w.jpg\" alt=\"image-20211227185846460\"></p>\n<p>rerender 底层是区分 function 组件或者是  options 组件的，阅读代码可知，当我们修改一个文件的时候，如果这个组件是没有options的话，意味着这个组件是一个纯静态的UI组件。那么我们修改 template 中的文案时，只需要通知到相应的组件，进行 forceUpdate 就可以了。当存在options 时候，就需要我们覆盖重置组件内的options，并且执行 forceUpdate。</p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>webpack + vue-loader 提供了解析模板的能力，在开发阶段，帮我们顺利定位到了我们修改的是那个组件，并且完美的解析了我们修改的组件形成DSL。那么推动vue组件重新渲染的，是 vue 中 forceUpdate 的功劳。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Vue-Loader-Hot-Reload\"><a href=\"#Vue-Loader-Hot-Reload\" class=\"headerlink\" title=\"Vue-Loader Hot Reload\"></a>Vue-Loader Hot Reload</h1><h3 id=\"Hot-Reload-触发时机\"><a href=\"#Hot-Reload-触发时机\" class=\"headerlink\" title=\"Hot Reload 触发时机\"></a>Hot Reload 触发时机</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> needsHotReload = (</span><br><span class=\"line\">    !isServer &amp;&amp;</span><br><span class=\"line\">    !isProduction &amp;&amp;</span><br><span class=\"line\">    (descriptor.script || descriptor.template) &amp;&amp;</span><br><span class=\"line\">    options.hotReload !== <span class=\"literal\">false</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>isServer</strong>  判断当前是浏览器环境还是Node环境；</li>\n<li><strong>isProduction</strong> 判断只有是开发环境才进行HMR；</li>\n<li><strong>descriptor</strong> 对象从 <strong>@vue/component-compiler-utils</strong> 提供的 <strong>parse</strong> 函数处理所得。</li>\n<li><strong>options</strong> 从 <strong>loader-utils</strong> 返回值中所得。</li>\n</ul>\n<h3 id=\"Loader-utils\"><a href=\"#Loader-utils\" class=\"headerlink\" title=\"Loader-utils\"></a>Loader-utils</h3><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxslc4bkbbj31700hmwfv.jpg\" alt=\"image-20211227185740127\"></p>\n<p><strong>loader-utils</strong> 本身是<strong>webpack</strong>提供的插理解是<strong>webpack</strong>本身提供的一些工具方法。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxslcawdxoj31kg0modjf.jpg\" alt=\"image-20211227185750549\"></p>\n<p>不难看出，<strong>loaderUtils.getOptions</strong> 方法本质是序列化 <strong>webpack</strong> 运行时的上下文。</p>\n<h3 id=\"vue-hot-reload-api\"><a href=\"#vue-hot-reload-api\" class=\"headerlink\" title=\"vue-hot-reload-api\"></a>vue-hot-reload-api</h3><h4 id=\"调用链路分析\"><a href=\"#调用链路分析\" class=\"headerlink\" title=\"调用链路分析\"></a>调用链路分析</h4><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxslcja4d3j30u30u0god.jpg\" alt=\"image-20211227185804203\"></p>\n<p>通过 Debug 可以宏观意义上的去体会 <strong>vue-hot-reload-api</strong> 提供的能力。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxslcqtt1ij31i40s243n.jpg\" alt=\"image-20211227185816016\"></p>\n<h4 id=\"钩子-API-汇总\"><a href=\"#钩子-API-汇总\" class=\"headerlink\" title=\"钩子 API 汇总\"></a>钩子 API 汇总</h4><table>\n<thead>\n<tr>\n<th align=\"left\">名称</th>\n<th align=\"left\">类型</th>\n<th align=\"left\">作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">compatible</td>\n<td align=\"left\">Boolen</td>\n<td align=\"left\">vue-hot-reload-api 只作用于 vue 2.x 版本</td>\n</tr>\n<tr>\n<td align=\"left\">createRecord</td>\n<td align=\"left\">Function</td>\n<td align=\"left\">以模块ID为key，</td>\n</tr>\n<tr>\n<td align=\"left\">install</td>\n<td align=\"left\">Function</td>\n<td align=\"left\">将 vue 注册到 vue-hot-reload-api</td>\n</tr>\n<tr>\n<td align=\"left\">isRecorded</td>\n<td align=\"left\">Function</td>\n<td align=\"left\">判断当前修改的文件是否曾经被修改过</td>\n</tr>\n<tr>\n<td align=\"left\">reload</td>\n<td align=\"left\">Function</td>\n<td align=\"left\">组件重新加载options</td>\n</tr>\n<tr>\n<td align=\"left\">rerender</td>\n<td align=\"left\">Function</td>\n<td align=\"left\">修改后的components 重新 render</td>\n</tr>\n</tbody></table>\n<h4 id=\"实现存储\"><a href=\"#实现存储\" class=\"headerlink\" title=\"实现存储\"></a>实现存储</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> !== <span class=\"string\">&#x27;undefined&#x27;</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.__VUE_HOT_MAP__ = map</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>源码中，hot-reload 会缓存在一个对象中。并且对外暴露了更新组件时对象内部的结构。如下如所示：</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsld1j6eij31k60f6mzw.jpg\" alt=\"image-20211227185833373\"></p>\n<h3 id=\"答疑解惑\"><a href=\"#答疑解惑\" class=\"headerlink\" title=\"答疑解惑\"></a>答疑解惑</h3><h4 id=\"1-module-hot-accept-做了什么？\"><a href=\"#1-module-hot-accept-做了什么？\" class=\"headerlink\" title=\"1. module.hot.accept 做了什么？\"></a>1. module.hot.accept 做了什么？</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// dep: ./src/components/HelloWorld.vue?vue&amp;type=template&amp;id=469af010&amp;scoped=true&amp;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> hot = &#123;</span><br><span class=\"line\">\t<span class=\"attr\">_acceptedDependencies</span>: &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">dep, callback</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (dep === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">\t\thot._selfAccepted = <span class=\"literal\">true</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> dep === <span class=\"string\">&quot;function&quot;</span>) &#123;</span><br><span class=\"line\">\t\thot._selfAccepted = dep;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> dep === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; dep.length; i++) &#123;</span><br><span class=\"line\">\t\t\thot._acceptedDependencies[dep[i]] = callback || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">\t\thot._acceptedDependencies[dep] = callback || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n\n<p>从上面代码中可以体会到，*.vue 一旦发生改变，vue文件在这里是被看成是 module 。module.hot.accept 只是单方面去存储每一次 *.vue 文件的修改的回调函数。试想，当同一个文件被多次修改后，最后一次修改完成后的内容，才对我们有意义。所以当一次 HMR 过程中，vue 会将文件的请求路径作为KEY，对应修改的 render 回调函数作为 value 。</p>\n<h4 id=\"3-vue-hot-reload-api-rerender-做了什么？\"><a href=\"#3-vue-hot-reload-api-rerender-做了什么？\" class=\"headerlink\" title=\"3. vue-hot-reload-api rerender 做了什么？\"></a>3. vue-hot-reload-api rerender 做了什么？</h4><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxslda074aj30z20jeq4w.jpg\" alt=\"image-20211227185846460\"></p>\n<p>rerender 底层是区分 function 组件或者是  options 组件的，阅读代码可知，当我们修改一个文件的时候，如果这个组件是没有options的话，意味着这个组件是一个纯静态的UI组件。那么我们修改 template 中的文案时，只需要通知到相应的组件，进行 forceUpdate 就可以了。当存在options 时候，就需要我们覆盖重置组件内的options，并且执行 forceUpdate。</p>\n<h3 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h3><p>webpack + vue-loader 提供了解析模板的能力，在开发阶段，帮我们顺利定位到了我们修改的是那个组件，并且完美的解析了我们修改的组件形成DSL。那么推动vue组件重新渲染的，是 vue 中 forceUpdate 的功劳。</p>\n"},{"title":"Webpack Chunk","_content":"\n# Webpack Chunk\n\n### 起源\n\n| 名称 | 版本 |\n| :--- | :--- |\n| CommonsChunkPlugin | webpack 3 |\n| optimization.splitChunks | webpack 4+概念 |\n\n### Chunk  vs Bundle\n\nChunk是过程中的代码块，Bundle是结果的代码块。\n\n### 产生Chunk的三种途径\n\n#### 1. entry\n\n```javascript\n{\n    entry: './src/js/main.js',\n}\n{\n    entry: ['./src/js/main.js','./src/js/other.js'],\n}\n```\n\n这种情况也只会产生一个Chunk。Webpack会将数组里的源代码，最终都打包到一个Bundle里，原因就是只生成了一个Chunk。\n\n#### 2. 异步\n\n```javascript\nconst myModel = r => require.ensure([], () => r(require('./myVue.vue')), 'myModel')\n```\n\nchunkFilename字段就派上用场了，为异步加载的Chunk命名。\n\n#### 3. 代码分隔\n\n**hash**\n\n* 基于build\n* 所有chunk文件使用相同的hash。\n* 项目中任一文件内容发生变化都会影响所有chunk文件hash\n\n**chunkhash**\n\n* 基于 webpack 的 `entry point`\n* 任意文件改变只会影响其所属的chunk，不会影响其它chunk。\n\n**contenthash**\n\n* 基于文件内容产生hash\n* 影响范围只限与本文件，多用于 CSS文件。当我们JS文件引入CSS时，由于利用了 css extract-text-webpack-plugin \n\n**总结： hash、chunkhash、contenthash 实际上是对我们重复打包编译之后，对外部用户群体的一种优化手段。**\n\n初始化最简易的项目，记录每一个chunk名称和chunk size\n\n![image-20211227203350894](https://tva1.sinaimg.cn/large/008i3skNly1gxso47dcuxj31lm0bq41g.jpg)\n\n当 test.js 中引入了我们所谓的第三方插件库\n\n![image-20211227203400531](https://tva1.sinaimg.cn/large/008i3skNly1gxso4cw6s0j31l40hsq54.jpg)\n\n如图可知，require 引入的模块，是不会被 Webpack Tree Shaking 掉的。\n\n```javascript\nconst path = require('path');\nconst webpack = require('webpack');\nmodule.exports = {\n  mode: \"production\",\n  entry: {\n      index: path.resolve(__dirname, 'src') + '/index.js',\n      test: path.resolve(__dirname, 'src') + '/test.js',\n      vendor: [\"react\", \"react-dom\"],\n  },\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: '[name].js'\n  },\n};\n```\n\n![image-20211227203412445](https://tva1.sinaimg.cn/large/008i3skNly1gxso4kg63hj31li0kwwlz.jpg)\n\n\n\n","source":"_posts/Webpack Chunk.md","raw":"---\ntitle: Webpack Chunk\ntags: 性能优化\n---\n\n# Webpack Chunk\n\n### 起源\n\n| 名称 | 版本 |\n| :--- | :--- |\n| CommonsChunkPlugin | webpack 3 |\n| optimization.splitChunks | webpack 4+概念 |\n\n### Chunk  vs Bundle\n\nChunk是过程中的代码块，Bundle是结果的代码块。\n\n### 产生Chunk的三种途径\n\n#### 1. entry\n\n```javascript\n{\n    entry: './src/js/main.js',\n}\n{\n    entry: ['./src/js/main.js','./src/js/other.js'],\n}\n```\n\n这种情况也只会产生一个Chunk。Webpack会将数组里的源代码，最终都打包到一个Bundle里，原因就是只生成了一个Chunk。\n\n#### 2. 异步\n\n```javascript\nconst myModel = r => require.ensure([], () => r(require('./myVue.vue')), 'myModel')\n```\n\nchunkFilename字段就派上用场了，为异步加载的Chunk命名。\n\n#### 3. 代码分隔\n\n**hash**\n\n* 基于build\n* 所有chunk文件使用相同的hash。\n* 项目中任一文件内容发生变化都会影响所有chunk文件hash\n\n**chunkhash**\n\n* 基于 webpack 的 `entry point`\n* 任意文件改变只会影响其所属的chunk，不会影响其它chunk。\n\n**contenthash**\n\n* 基于文件内容产生hash\n* 影响范围只限与本文件，多用于 CSS文件。当我们JS文件引入CSS时，由于利用了 css extract-text-webpack-plugin \n\n**总结： hash、chunkhash、contenthash 实际上是对我们重复打包编译之后，对外部用户群体的一种优化手段。**\n\n初始化最简易的项目，记录每一个chunk名称和chunk size\n\n![image-20211227203350894](https://tva1.sinaimg.cn/large/008i3skNly1gxso47dcuxj31lm0bq41g.jpg)\n\n当 test.js 中引入了我们所谓的第三方插件库\n\n![image-20211227203400531](https://tva1.sinaimg.cn/large/008i3skNly1gxso4cw6s0j31l40hsq54.jpg)\n\n如图可知，require 引入的模块，是不会被 Webpack Tree Shaking 掉的。\n\n```javascript\nconst path = require('path');\nconst webpack = require('webpack');\nmodule.exports = {\n  mode: \"production\",\n  entry: {\n      index: path.resolve(__dirname, 'src') + '/index.js',\n      test: path.resolve(__dirname, 'src') + '/test.js',\n      vendor: [\"react\", \"react-dom\"],\n  },\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: '[name].js'\n  },\n};\n```\n\n![image-20211227203412445](https://tva1.sinaimg.cn/large/008i3skNly1gxso4kg63hj31li0kwwlz.jpg)\n\n\n\n","slug":"Webpack Chunk","published":1,"date":"2021-05-28T09:41:10.630Z","updated":"2021-12-28T02:10:52.277Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxph7qmj000n1op76xhk361g","content":"<h1 id=\"Webpack-Chunk\"><a href=\"#Webpack-Chunk\" class=\"headerlink\" title=\"Webpack Chunk\"></a>Webpack Chunk</h1><h3 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h3><table>\n<thead>\n<tr>\n<th align=\"left\">名称</th>\n<th align=\"left\">版本</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">CommonsChunkPlugin</td>\n<td align=\"left\">webpack 3</td>\n</tr>\n<tr>\n<td align=\"left\">optimization.splitChunks</td>\n<td align=\"left\">webpack 4+概念</td>\n</tr>\n</tbody></table>\n<h3 id=\"Chunk-vs-Bundle\"><a href=\"#Chunk-vs-Bundle\" class=\"headerlink\" title=\"Chunk  vs Bundle\"></a>Chunk  vs Bundle</h3><p>Chunk是过程中的代码块，Bundle是结果的代码块。</p>\n<h3 id=\"产生Chunk的三种途径\"><a href=\"#产生Chunk的三种途径\" class=\"headerlink\" title=\"产生Chunk的三种途径\"></a>产生Chunk的三种途径</h3><h4 id=\"1-entry\"><a href=\"#1-entry\" class=\"headerlink\" title=\"1. entry\"></a>1. entry</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">entry</span>: <span class=\"string\">&#x27;./src/js/main.js&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">entry</span>: [<span class=\"string\">&#x27;./src/js/main.js&#x27;</span>,<span class=\"string\">&#x27;./src/js/other.js&#x27;</span>],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种情况也只会产生一个Chunk。Webpack会将数组里的源代码，最终都打包到一个Bundle里，原因就是只生成了一个Chunk。</p>\n<h4 id=\"2-异步\"><a href=\"#2-异步\" class=\"headerlink\" title=\"2. 异步\"></a>2. 异步</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myModel = <span class=\"function\"><span class=\"params\">r</span> =&gt;</span> <span class=\"built_in\">require</span>.ensure([], <span class=\"function\">() =&gt;</span> r(<span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./myVue.vue&#x27;</span>)), <span class=\"string\">&#x27;myModel&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>chunkFilename字段就派上用场了，为异步加载的Chunk命名。</p>\n<h4 id=\"3-代码分隔\"><a href=\"#3-代码分隔\" class=\"headerlink\" title=\"3. 代码分隔\"></a>3. 代码分隔</h4><p><strong>hash</strong></p>\n<ul>\n<li>基于build</li>\n<li>所有chunk文件使用相同的hash。</li>\n<li>项目中任一文件内容发生变化都会影响所有chunk文件hash</li>\n</ul>\n<p><strong>chunkhash</strong></p>\n<ul>\n<li>基于 webpack 的 <code>entry point</code></li>\n<li>任意文件改变只会影响其所属的chunk，不会影响其它chunk。</li>\n</ul>\n<p><strong>contenthash</strong></p>\n<ul>\n<li>基于文件内容产生hash</li>\n<li>影响范围只限与本文件，多用于 CSS文件。当我们JS文件引入CSS时，由于利用了 css extract-text-webpack-plugin </li>\n</ul>\n<p><strong>总结： hash、chunkhash、contenthash 实际上是对我们重复打包编译之后，对外部用户群体的一种优化手段。</strong></p>\n<p>初始化最简易的项目，记录每一个chunk名称和chunk size</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso47dcuxj31lm0bq41g.jpg\" alt=\"image-20211227203350894\"></p>\n<p>当 test.js 中引入了我们所谓的第三方插件库</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso4cw6s0j31l40hsq54.jpg\" alt=\"image-20211227203400531\"></p>\n<p>如图可知，require 引入的模块，是不会被 Webpack Tree Shaking 掉的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;webpack&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"attr\">mode</span>: <span class=\"string\">&quot;production&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">entry</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">index</span>: path.resolve(__dirname, <span class=\"string\">&#x27;src&#x27;</span>) + <span class=\"string\">&#x27;/index.js&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">test</span>: path.resolve(__dirname, <span class=\"string\">&#x27;src&#x27;</span>) + <span class=\"string\">&#x27;/test.js&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">vendor</span>: [<span class=\"string\">&quot;react&quot;</span>, <span class=\"string\">&quot;react-dom&quot;</span>],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">path</span>: path.resolve(__dirname, <span class=\"string\">&#x27;./dist&#x27;</span>),</span><br><span class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;[name].js&#x27;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso4kg63hj31li0kwwlz.jpg\" alt=\"image-20211227203412445\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Webpack-Chunk\"><a href=\"#Webpack-Chunk\" class=\"headerlink\" title=\"Webpack Chunk\"></a>Webpack Chunk</h1><h3 id=\"起源\"><a href=\"#起源\" class=\"headerlink\" title=\"起源\"></a>起源</h3><table>\n<thead>\n<tr>\n<th align=\"left\">名称</th>\n<th align=\"left\">版本</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">CommonsChunkPlugin</td>\n<td align=\"left\">webpack 3</td>\n</tr>\n<tr>\n<td align=\"left\">optimization.splitChunks</td>\n<td align=\"left\">webpack 4+概念</td>\n</tr>\n</tbody></table>\n<h3 id=\"Chunk-vs-Bundle\"><a href=\"#Chunk-vs-Bundle\" class=\"headerlink\" title=\"Chunk  vs Bundle\"></a>Chunk  vs Bundle</h3><p>Chunk是过程中的代码块，Bundle是结果的代码块。</p>\n<h3 id=\"产生Chunk的三种途径\"><a href=\"#产生Chunk的三种途径\" class=\"headerlink\" title=\"产生Chunk的三种途径\"></a>产生Chunk的三种途径</h3><h4 id=\"1-entry\"><a href=\"#1-entry\" class=\"headerlink\" title=\"1. entry\"></a>1. entry</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">entry</span>: <span class=\"string\">&#x27;./src/js/main.js&#x27;</span>,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">entry</span>: [<span class=\"string\">&#x27;./src/js/main.js&#x27;</span>,<span class=\"string\">&#x27;./src/js/other.js&#x27;</span>],</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种情况也只会产生一个Chunk。Webpack会将数组里的源代码，最终都打包到一个Bundle里，原因就是只生成了一个Chunk。</p>\n<h4 id=\"2-异步\"><a href=\"#2-异步\" class=\"headerlink\" title=\"2. 异步\"></a>2. 异步</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myModel = <span class=\"function\"><span class=\"params\">r</span> =&gt;</span> <span class=\"built_in\">require</span>.ensure([], <span class=\"function\">() =&gt;</span> r(<span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./myVue.vue&#x27;</span>)), <span class=\"string\">&#x27;myModel&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>chunkFilename字段就派上用场了，为异步加载的Chunk命名。</p>\n<h4 id=\"3-代码分隔\"><a href=\"#3-代码分隔\" class=\"headerlink\" title=\"3. 代码分隔\"></a>3. 代码分隔</h4><p><strong>hash</strong></p>\n<ul>\n<li>基于build</li>\n<li>所有chunk文件使用相同的hash。</li>\n<li>项目中任一文件内容发生变化都会影响所有chunk文件hash</li>\n</ul>\n<p><strong>chunkhash</strong></p>\n<ul>\n<li>基于 webpack 的 <code>entry point</code></li>\n<li>任意文件改变只会影响其所属的chunk，不会影响其它chunk。</li>\n</ul>\n<p><strong>contenthash</strong></p>\n<ul>\n<li>基于文件内容产生hash</li>\n<li>影响范围只限与本文件，多用于 CSS文件。当我们JS文件引入CSS时，由于利用了 css extract-text-webpack-plugin </li>\n</ul>\n<p><strong>总结： hash、chunkhash、contenthash 实际上是对我们重复打包编译之后，对外部用户群体的一种优化手段。</strong></p>\n<p>初始化最简易的项目，记录每一个chunk名称和chunk size</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso47dcuxj31lm0bq41g.jpg\" alt=\"image-20211227203350894\"></p>\n<p>当 test.js 中引入了我们所谓的第三方插件库</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso4cw6s0j31l40hsq54.jpg\" alt=\"image-20211227203400531\"></p>\n<p>如图可知，require 引入的模块，是不会被 Webpack Tree Shaking 掉的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;webpack&#x27;</span>);</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  <span class=\"attr\">mode</span>: <span class=\"string\">&quot;production&quot;</span>,</span><br><span class=\"line\">  <span class=\"attr\">entry</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">index</span>: path.resolve(__dirname, <span class=\"string\">&#x27;src&#x27;</span>) + <span class=\"string\">&#x27;/index.js&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">test</span>: path.resolve(__dirname, <span class=\"string\">&#x27;src&#x27;</span>) + <span class=\"string\">&#x27;/test.js&#x27;</span>,</span><br><span class=\"line\">      <span class=\"attr\">vendor</span>: [<span class=\"string\">&quot;react&quot;</span>, <span class=\"string\">&quot;react-dom&quot;</span>],</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">output</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">path</span>: path.resolve(__dirname, <span class=\"string\">&#x27;./dist&#x27;</span>),</span><br><span class=\"line\">    <span class=\"attr\">filename</span>: <span class=\"string\">&#x27;[name].js&#x27;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso4kg63hj31li0kwwlz.jpg\" alt=\"image-20211227203412445\"></p>\n"},{"title":"css 盒模型","_content":"\n# css 盒模型\n\n![image-20211227175419846](https://tva1.sinaimg.cn/large/008i3skNly1gxsji7tfbrj30ms0h3mxv.jpg)\n\n## 基础知识\n```css\n<!--标准模式-->\nbox-sizing: content-box;\n\n<!--怪异模式（又称IE模式）-->\nbox-sizing: border-box;\n```\n## 考点\n### 1. 标准模型和IE模型的区别\n```css\n<!--\n    预设：\n        width: 200px;\n        height: 200px;\n        padding: 20px;\n        border: 10px solid red;\n        margin: 30px;\n        background: red;\n-->\n```\n标准模式: 占用width = 260, 其中 20（padding） * 2 + 10(border) * 2, 内容区： 200\n\n怪异模式: 占用width = 200, 其中 20（padding）* 2 + 10(border) * 2， 内容区：140\n\n### 2. js如何设置获取盒模型对应的宽和高\n- dom.style.width/height 只能取到行内样式的宽和高，style标签中和link外链的样式取不到。\n![image-20211227185408809](https://tva1.sinaimg.cn/large/008i3skNly1gxsl8hme9vj30ow08kglw.jpg)\n![image-20211227185418024](https://tva1.sinaimg.cn/large/008i3skNly1gxsl8mbwlhj30tb069wep.jpg)\n![image-20211227185432330](https://tva1.sinaimg.cn/large/008i3skNly1gxsl8v6zcgj30rj06nweq.jpg)\n![image-20211227185440657](https://tva1.sinaimg.cn/large/008i3skNly1gxsl90bz8xj30t005z0t1.jpg)\n\n- window.getComputedStyle(dom).width/height 同（2）但是多浏览器支持，IE9以上支持。\n![image-20211227185449949](https://tva1.sinaimg.cn/large/008i3skNly1gxsl961gwkj30sv0f475f.jpg)\n![image-20211227185500342](https://tva1.sinaimg.cn/large/008i3skNly1gxsl9cn316j30s007o0sz.jpg)\n\n![image-20211227185535832](https://tva1.sinaimg.cn/large/008i3skNly1gxsl9z6mz9j30tx0miad6.jpg)\n- dom.getBoundingClientRect().width/height 也是得到渲染后的宽和高，大多浏览器支持。IE9以上支持，除此外还可以取到相对于视窗的上下左右的距离。\n![image-20211227185548299](https://tva1.sinaimg.cn/large/008i3skNly1gxsla6hhzvj30sd09s3za.jpg)\n![image-20211227185559844](https://tva1.sinaimg.cn/large/008i3skNly1gxsladjd60j30sa090mxo.jpg)\n\n反思：在动态生成骨架屏的过程中，可以参考如上 API 分析页面元素位置。","source":"_posts/css.md","raw":"---\ntitle: css 盒模型\ntags: css\n---\n\n# css 盒模型\n\n![image-20211227175419846](https://tva1.sinaimg.cn/large/008i3skNly1gxsji7tfbrj30ms0h3mxv.jpg)\n\n## 基础知识\n```css\n<!--标准模式-->\nbox-sizing: content-box;\n\n<!--怪异模式（又称IE模式）-->\nbox-sizing: border-box;\n```\n## 考点\n### 1. 标准模型和IE模型的区别\n```css\n<!--\n    预设：\n        width: 200px;\n        height: 200px;\n        padding: 20px;\n        border: 10px solid red;\n        margin: 30px;\n        background: red;\n-->\n```\n标准模式: 占用width = 260, 其中 20（padding） * 2 + 10(border) * 2, 内容区： 200\n\n怪异模式: 占用width = 200, 其中 20（padding）* 2 + 10(border) * 2， 内容区：140\n\n### 2. js如何设置获取盒模型对应的宽和高\n- dom.style.width/height 只能取到行内样式的宽和高，style标签中和link外链的样式取不到。\n![image-20211227185408809](https://tva1.sinaimg.cn/large/008i3skNly1gxsl8hme9vj30ow08kglw.jpg)\n![image-20211227185418024](https://tva1.sinaimg.cn/large/008i3skNly1gxsl8mbwlhj30tb069wep.jpg)\n![image-20211227185432330](https://tva1.sinaimg.cn/large/008i3skNly1gxsl8v6zcgj30rj06nweq.jpg)\n![image-20211227185440657](https://tva1.sinaimg.cn/large/008i3skNly1gxsl90bz8xj30t005z0t1.jpg)\n\n- window.getComputedStyle(dom).width/height 同（2）但是多浏览器支持，IE9以上支持。\n![image-20211227185449949](https://tva1.sinaimg.cn/large/008i3skNly1gxsl961gwkj30sv0f475f.jpg)\n![image-20211227185500342](https://tva1.sinaimg.cn/large/008i3skNly1gxsl9cn316j30s007o0sz.jpg)\n\n![image-20211227185535832](https://tva1.sinaimg.cn/large/008i3skNly1gxsl9z6mz9j30tx0miad6.jpg)\n- dom.getBoundingClientRect().width/height 也是得到渲染后的宽和高，大多浏览器支持。IE9以上支持，除此外还可以取到相对于视窗的上下左右的距离。\n![image-20211227185548299](https://tva1.sinaimg.cn/large/008i3skNly1gxsla6hhzvj30sd09s3za.jpg)\n![image-20211227185559844](https://tva1.sinaimg.cn/large/008i3skNly1gxsladjd60j30sa090mxo.jpg)\n\n反思：在动态生成骨架屏的过程中，可以参考如上 API 分析页面元素位置。","slug":"css","published":1,"date":"2021-06-02T09:36:54.907Z","updated":"2021-12-28T02:05:07.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxph7qmk000q1op7fdx5b0j5","content":"<h1 id=\"css-盒模型\"><a href=\"#css-盒模型\" class=\"headerlink\" title=\"css 盒模型\"></a>css 盒模型</h1><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsji7tfbrj30ms0h3mxv.jpg\" alt=\"image-20211227175419846\"></p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--标准模式--&gt;</span><br><span class=\"line\"><span class=\"attribute\">box-sizing</span>: content-box;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--怪异模式（又称IE模式）--&gt;</span><br><span class=\"line\"><span class=\"attribute\">box-sizing</span>: border-box;</span><br></pre></td></tr></table></figure>\n<h2 id=\"考点\"><a href=\"#考点\" class=\"headerlink\" title=\"考点\"></a>考点</h2><h3 id=\"1-标准模型和IE模型的区别\"><a href=\"#1-标准模型和IE模型的区别\" class=\"headerlink\" title=\"1. 标准模型和IE模型的区别\"></a>1. 标准模型和IE模型的区别</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--</span><br><span class=\"line\">    预设：</span><br><span class=\"line\">        <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">border</span>: <span class=\"number\">10px</span> solid red;</span><br><span class=\"line\">        <span class=\"attribute\">margin</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">--&gt;</span><br></pre></td></tr></table></figure>\n<p>标准模式: 占用width = 260, 其中 20（padding） * 2 + 10(border) * 2, 内容区： 200</p>\n<p>怪异模式: 占用width = 200, 其中 20（padding）* 2 + 10(border) * 2， 内容区：140</p>\n<h3 id=\"2-js如何设置获取盒模型对应的宽和高\"><a href=\"#2-js如何设置获取盒模型对应的宽和高\" class=\"headerlink\" title=\"2. js如何设置获取盒模型对应的宽和高\"></a>2. js如何设置获取盒模型对应的宽和高</h3><ul>\n<li><p>dom.style.width/height 只能取到行内样式的宽和高，style标签中和link外链的样式取不到。<br><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsl8hme9vj30ow08kglw.jpg\" alt=\"image-20211227185408809\"><br><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsl8mbwlhj30tb069wep.jpg\" alt=\"image-20211227185418024\"><br><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsl8v6zcgj30rj06nweq.jpg\" alt=\"image-20211227185432330\"><br><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsl90bz8xj30t005z0t1.jpg\" alt=\"image-20211227185440657\"></p>\n</li>\n<li><p>window.getComputedStyle(dom).width/height 同（2）但是多浏览器支持，IE9以上支持。<br><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsl961gwkj30sv0f475f.jpg\" alt=\"image-20211227185449949\"><br><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsl9cn316j30s007o0sz.jpg\" alt=\"image-20211227185500342\"></p>\n</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsl9z6mz9j30tx0miad6.jpg\" alt=\"image-20211227185535832\"></p>\n<ul>\n<li>dom.getBoundingClientRect().width/height 也是得到渲染后的宽和高，大多浏览器支持。IE9以上支持，除此外还可以取到相对于视窗的上下左右的距离。<br><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsla6hhzvj30sd09s3za.jpg\" alt=\"image-20211227185548299\"><br><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsladjd60j30sa090mxo.jpg\" alt=\"image-20211227185559844\"></li>\n</ul>\n<p>反思：在动态生成骨架屏的过程中，可以参考如上 API 分析页面元素位置。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"css-盒模型\"><a href=\"#css-盒模型\" class=\"headerlink\" title=\"css 盒模型\"></a>css 盒模型</h1><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsji7tfbrj30ms0h3mxv.jpg\" alt=\"image-20211227175419846\"></p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--标准模式--&gt;</span><br><span class=\"line\"><span class=\"attribute\">box-sizing</span>: content-box;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;!--怪异模式（又称IE模式）--&gt;</span><br><span class=\"line\"><span class=\"attribute\">box-sizing</span>: border-box;</span><br></pre></td></tr></table></figure>\n<h2 id=\"考点\"><a href=\"#考点\" class=\"headerlink\" title=\"考点\"></a>考点</h2><h3 id=\"1-标准模型和IE模型的区别\"><a href=\"#1-标准模型和IE模型的区别\" class=\"headerlink\" title=\"1. 标准模型和IE模型的区别\"></a>1. 标准模型和IE模型的区别</h3><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!--</span><br><span class=\"line\">    预设：</span><br><span class=\"line\">        <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">border</span>: <span class=\"number\">10px</span> solid red;</span><br><span class=\"line\">        <span class=\"attribute\">margin</span>: <span class=\"number\">30px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">background</span>: red;</span><br><span class=\"line\">--&gt;</span><br></pre></td></tr></table></figure>\n<p>标准模式: 占用width = 260, 其中 20（padding） * 2 + 10(border) * 2, 内容区： 200</p>\n<p>怪异模式: 占用width = 200, 其中 20（padding）* 2 + 10(border) * 2， 内容区：140</p>\n<h3 id=\"2-js如何设置获取盒模型对应的宽和高\"><a href=\"#2-js如何设置获取盒模型对应的宽和高\" class=\"headerlink\" title=\"2. js如何设置获取盒模型对应的宽和高\"></a>2. js如何设置获取盒模型对应的宽和高</h3><ul>\n<li><p>dom.style.width/height 只能取到行内样式的宽和高，style标签中和link外链的样式取不到。<br><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsl8hme9vj30ow08kglw.jpg\" alt=\"image-20211227185408809\"><br><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsl8mbwlhj30tb069wep.jpg\" alt=\"image-20211227185418024\"><br><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsl8v6zcgj30rj06nweq.jpg\" alt=\"image-20211227185432330\"><br><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsl90bz8xj30t005z0t1.jpg\" alt=\"image-20211227185440657\"></p>\n</li>\n<li><p>window.getComputedStyle(dom).width/height 同（2）但是多浏览器支持，IE9以上支持。<br><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsl961gwkj30sv0f475f.jpg\" alt=\"image-20211227185449949\"><br><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsl9cn316j30s007o0sz.jpg\" alt=\"image-20211227185500342\"></p>\n</li>\n</ul>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsl9z6mz9j30tx0miad6.jpg\" alt=\"image-20211227185535832\"></p>\n<ul>\n<li>dom.getBoundingClientRect().width/height 也是得到渲染后的宽和高，大多浏览器支持。IE9以上支持，除此外还可以取到相对于视窗的上下左右的距离。<br><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsla6hhzvj30sd09s3za.jpg\" alt=\"image-20211227185548299\"><br><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxsladjd60j30sa090mxo.jpg\" alt=\"image-20211227185559844\"></li>\n</ul>\n<p>反思：在动态生成骨架屏的过程中，可以参考如上 API 分析页面元素位置。</p>\n"},{"title":"HTTP/2 知识点梳理","_content":"\n## HTTP/2 知识点梳理\n\n\n\n### 1. **知识点**\n\n**HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。**\n\n-  **帧：**HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。\n\n- **流：**存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID。\n\n#### **多路复用**：\n\n 代替原来的序列和阻塞机制。所有就是请求的都是通过一个 TCP连接并发完成。 HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。\n\n\n\n#### **服务器推送**\n\n服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。\n\n服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。\n\n\n\n![image-20211217174305422](https://tva1.sinaimg.cn/large/008i3skNly1gxgyzfzh45j31740mg75n.jpg)\n\n\n\n```javascript\nconst http2 = require('http2');\nconst fs = require('fs');\nconst path = require('path')\n\nconst server = http2.createSecureServer({\n  key: fs.readFileSync(path.resolve('../../Documents/keys/localhost-privkey.pem')),\n  cert: fs.readFileSync(path.resolve('../../Documents/keys/localhost-cert.pem'))\n});\nserver.on('error', (err) => console.error(err));\n\nserver.on('stream', (stream, headers) => {\n  // 流是双工的\n  stream.respond({\n    'content-type': 'text/html; charset=utf-8',\n    ':status': 200\n  });\n  stream.pushStream({ ':path': '/index.css' }, (err, pushStream, headers) => {\n    if (err) throw err\n    pushStream.respond({ ':status': 200 , 'content-type': 'application/json'});\n    pushStream.end(fs.readFileSync('./index.css'))\n  })\n  stream.end(fs.readFileSync('./index.html'));\n});\n\nserver.listen(8080);\n```\n\n\n\n![image-20211217175216824](https://tva1.sinaimg.cn/large/008i3skNly1gxgz9043lzj31oi0dsju4.jpg)\n\n\n\n### 2. Node 启动 HTTP/2\n\n\n\n```bash\n# 本地生成证书&秘钥\nopenssl req -x509 -newkey rsa:2048 -nodes -sha256 -subj '/CN=localhost' \\\n  -keyout localhost-privkey.pem -out localhost-cert.pem\n```\n\n\n\n```javascript\nconst http2 = require('http2');\nconst fs = require('fs');\nconst path = require('path')\n\nconst server = http2.createSecureServer({\n  key: fs.readFileSync(path.resolve('../../Documents/keys/localhost-privkey.pem')),\n  cert: fs.readFileSync(path.resolve('../../Documents/keys/localhost-cert.pem'))\n});\nserver.on('error', (err) => console.error(err));\n\nserver.on('stream', (stream, headers) => {\n  // 流是双工的\n  stream.respond({\n    'content-type': 'text/html; charset=utf-8',\n    ':status': 200\n  });\n  stream.end('<h1>Hello World</h1>');\n});\n\nserver.listen(8080);\n```\n\n![image-20211217172158431](https://tva1.sinaimg.cn/large/008i3skNly1gxgydh6hzfj31je0tk0vg.jpg)\n\n### 3. 注意：\n\n- HTTP/2 客户端浏览器基于 SSL/TLS 之上，所以实现 HTTP/2的 Web 浏览器都只支持加密。但是针对 RPC 通讯，并没有特殊的限制，例如：gRPC框架的实现就是基于 HTTP/2 建立在TCP层上通讯的。\n\n","source":"_posts/http2.md","raw":"---\ntitle: HTTP/2 知识点梳理\ntags: 浏览器\n---\n\n## HTTP/2 知识点梳理\n\n\n\n### 1. **知识点**\n\n**HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。**\n\n-  **帧：**HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。\n\n- **流：**存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID。\n\n#### **多路复用**：\n\n 代替原来的序列和阻塞机制。所有就是请求的都是通过一个 TCP连接并发完成。 HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。\n\n\n\n#### **服务器推送**\n\n服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。\n\n服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。\n\n\n\n![image-20211217174305422](https://tva1.sinaimg.cn/large/008i3skNly1gxgyzfzh45j31740mg75n.jpg)\n\n\n\n```javascript\nconst http2 = require('http2');\nconst fs = require('fs');\nconst path = require('path')\n\nconst server = http2.createSecureServer({\n  key: fs.readFileSync(path.resolve('../../Documents/keys/localhost-privkey.pem')),\n  cert: fs.readFileSync(path.resolve('../../Documents/keys/localhost-cert.pem'))\n});\nserver.on('error', (err) => console.error(err));\n\nserver.on('stream', (stream, headers) => {\n  // 流是双工的\n  stream.respond({\n    'content-type': 'text/html; charset=utf-8',\n    ':status': 200\n  });\n  stream.pushStream({ ':path': '/index.css' }, (err, pushStream, headers) => {\n    if (err) throw err\n    pushStream.respond({ ':status': 200 , 'content-type': 'application/json'});\n    pushStream.end(fs.readFileSync('./index.css'))\n  })\n  stream.end(fs.readFileSync('./index.html'));\n});\n\nserver.listen(8080);\n```\n\n\n\n![image-20211217175216824](https://tva1.sinaimg.cn/large/008i3skNly1gxgz9043lzj31oi0dsju4.jpg)\n\n\n\n### 2. Node 启动 HTTP/2\n\n\n\n```bash\n# 本地生成证书&秘钥\nopenssl req -x509 -newkey rsa:2048 -nodes -sha256 -subj '/CN=localhost' \\\n  -keyout localhost-privkey.pem -out localhost-cert.pem\n```\n\n\n\n```javascript\nconst http2 = require('http2');\nconst fs = require('fs');\nconst path = require('path')\n\nconst server = http2.createSecureServer({\n  key: fs.readFileSync(path.resolve('../../Documents/keys/localhost-privkey.pem')),\n  cert: fs.readFileSync(path.resolve('../../Documents/keys/localhost-cert.pem'))\n});\nserver.on('error', (err) => console.error(err));\n\nserver.on('stream', (stream, headers) => {\n  // 流是双工的\n  stream.respond({\n    'content-type': 'text/html; charset=utf-8',\n    ':status': 200\n  });\n  stream.end('<h1>Hello World</h1>');\n});\n\nserver.listen(8080);\n```\n\n![image-20211217172158431](https://tva1.sinaimg.cn/large/008i3skNly1gxgydh6hzfj31je0tk0vg.jpg)\n\n### 3. 注意：\n\n- HTTP/2 客户端浏览器基于 SSL/TLS 之上，所以实现 HTTP/2的 Web 浏览器都只支持加密。但是针对 RPC 通讯，并没有特殊的限制，例如：gRPC框架的实现就是基于 HTTP/2 建立在TCP层上通讯的。\n\n","slug":"http2","published":1,"date":"2021-12-17T08:58:17.496Z","updated":"2021-12-28T02:17:24.579Z","_id":"ckxph7qml000s1op715gzfr0i","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"HTTP-2-知识点梳理\"><a href=\"#HTTP-2-知识点梳理\" class=\"headerlink\" title=\"HTTP/2 知识点梳理\"></a>HTTP/2 知识点梳理</h2><h3 id=\"1-知识点\"><a href=\"#1-知识点\" class=\"headerlink\" title=\"1. 知识点\"></a>1. <strong>知识点</strong></h3><p><strong>HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。</strong></p>\n<ul>\n<li><p> <strong>帧：</strong>HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。</p>\n</li>\n<li><p><strong>流：</strong>存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID。</p>\n</li>\n</ul>\n<h4 id=\"多路复用：\"><a href=\"#多路复用：\" class=\"headerlink\" title=\"多路复用：\"></a><strong>多路复用</strong>：</h4><p> 代替原来的序列和阻塞机制。所有就是请求的都是通过一个 TCP连接并发完成。 HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。</p>\n<h4 id=\"服务器推送\"><a href=\"#服务器推送\" class=\"headerlink\" title=\"服务器推送\"></a><strong>服务器推送</strong></h4><p>服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。</p>\n<p>服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxgyzfzh45j31740mg75n.jpg\" alt=\"image-20211217174305422\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> http2 = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http2&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = http2.createSecureServer(&#123;</span><br><span class=\"line\">  <span class=\"attr\">key</span>: fs.readFileSync(path.resolve(<span class=\"string\">&#x27;../../Documents/keys/localhost-privkey.pem&#x27;</span>)),</span><br><span class=\"line\">  <span class=\"attr\">cert</span>: fs.readFileSync(path.resolve(<span class=\"string\">&#x27;../../Documents/keys/localhost-cert.pem&#x27;</span>))</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">server.on(<span class=\"string\">&#x27;error&#x27;</span>, <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> <span class=\"built_in\">console</span>.error(err));</span><br><span class=\"line\"></span><br><span class=\"line\">server.on(<span class=\"string\">&#x27;stream&#x27;</span>, <span class=\"function\">(<span class=\"params\">stream, headers</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 流是双工的</span></span><br><span class=\"line\">  stream.respond(&#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;content-type&#x27;</span>: <span class=\"string\">&#x27;text/html; charset=utf-8&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;:status&#x27;</span>: <span class=\"number\">200</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  stream.pushStream(&#123; <span class=\"string\">&#x27;:path&#x27;</span>: <span class=\"string\">&#x27;/index.css&#x27;</span> &#125;, <span class=\"function\">(<span class=\"params\">err, pushStream, headers</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">    pushStream.respond(&#123; <span class=\"string\">&#x27;:status&#x27;</span>: <span class=\"number\">200</span> , <span class=\"string\">&#x27;content-type&#x27;</span>: <span class=\"string\">&#x27;application/json&#x27;</span>&#125;);</span><br><span class=\"line\">    pushStream.end(fs.readFileSync(<span class=\"string\">&#x27;./index.css&#x27;</span>))</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  stream.end(fs.readFileSync(<span class=\"string\">&#x27;./index.html&#x27;</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxgz9043lzj31oi0dsju4.jpg\" alt=\"image-20211217175216824\"></p>\n<h3 id=\"2-Node-启动-HTTP-2\"><a href=\"#2-Node-启动-HTTP-2\" class=\"headerlink\" title=\"2. Node 启动 HTTP/2\"></a>2. Node 启动 HTTP/2</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 本地生成证书&amp;秘钥</span></span><br><span class=\"line\">openssl req -x509 -newkey rsa:2048 -nodes -sha256 -subj <span class=\"string\">&#x27;/CN=localhost&#x27;</span> \\</span><br><span class=\"line\">  -keyout localhost-privkey.pem -out localhost-cert.pem</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> http2 = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http2&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = http2.createSecureServer(&#123;</span><br><span class=\"line\">  <span class=\"attr\">key</span>: fs.readFileSync(path.resolve(<span class=\"string\">&#x27;../../Documents/keys/localhost-privkey.pem&#x27;</span>)),</span><br><span class=\"line\">  <span class=\"attr\">cert</span>: fs.readFileSync(path.resolve(<span class=\"string\">&#x27;../../Documents/keys/localhost-cert.pem&#x27;</span>))</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">server.on(<span class=\"string\">&#x27;error&#x27;</span>, <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> <span class=\"built_in\">console</span>.error(err));</span><br><span class=\"line\"></span><br><span class=\"line\">server.on(<span class=\"string\">&#x27;stream&#x27;</span>, <span class=\"function\">(<span class=\"params\">stream, headers</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 流是双工的</span></span><br><span class=\"line\">  stream.respond(&#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;content-type&#x27;</span>: <span class=\"string\">&#x27;text/html; charset=utf-8&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;:status&#x27;</span>: <span class=\"number\">200</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  stream.end(<span class=\"string\">&#x27;&lt;h1&gt;Hello World&lt;/h1&gt;&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxgydh6hzfj31je0tk0vg.jpg\" alt=\"image-20211217172158431\"></p>\n<h3 id=\"3-注意：\"><a href=\"#3-注意：\" class=\"headerlink\" title=\"3. 注意：\"></a>3. 注意：</h3><ul>\n<li>HTTP/2 客户端浏览器基于 SSL/TLS 之上，所以实现 HTTP/2的 Web 浏览器都只支持加密。但是针对 RPC 通讯，并没有特殊的限制，例如：gRPC框架的实现就是基于 HTTP/2 建立在TCP层上通讯的。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"HTTP-2-知识点梳理\"><a href=\"#HTTP-2-知识点梳理\" class=\"headerlink\" title=\"HTTP/2 知识点梳理\"></a>HTTP/2 知识点梳理</h2><h3 id=\"1-知识点\"><a href=\"#1-知识点\" class=\"headerlink\" title=\"1. 知识点\"></a>1. <strong>知识点</strong></h3><p><strong>HTTP/2 中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流。</strong></p>\n<ul>\n<li><p> <strong>帧：</strong>HTTP/2 数据通信的最小单位消息：指 HTTP/2 中逻辑上的 HTTP 消息。例如请求和响应等，消息由一个或多个帧组成。</p>\n</li>\n<li><p><strong>流：</strong>存在于连接中的一个虚拟通道。流可以承载双向消息，每个流都有一个唯一的整数ID。</p>\n</li>\n</ul>\n<h4 id=\"多路复用：\"><a href=\"#多路复用：\" class=\"headerlink\" title=\"多路复用：\"></a><strong>多路复用</strong>：</h4><p> 代替原来的序列和阻塞机制。所有就是请求的都是通过一个 TCP连接并发完成。 HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。</p>\n<h4 id=\"服务器推送\"><a href=\"#服务器推送\" class=\"headerlink\" title=\"服务器推送\"></a><strong>服务器推送</strong></h4><p>服务端可以在发送页面HTML时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应。例如服务端可以主动把JS和CSS文件推送给客户端，而不需要客户端解析HTML时再发送这些请求。</p>\n<p>服务端可以主动推送，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送RST_STREAM帧来拒收。主动推送也遵守同源策略，服务器不会随便推送第三方资源给客户端。</p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxgyzfzh45j31740mg75n.jpg\" alt=\"image-20211217174305422\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> http2 = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http2&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = http2.createSecureServer(&#123;</span><br><span class=\"line\">  <span class=\"attr\">key</span>: fs.readFileSync(path.resolve(<span class=\"string\">&#x27;../../Documents/keys/localhost-privkey.pem&#x27;</span>)),</span><br><span class=\"line\">  <span class=\"attr\">cert</span>: fs.readFileSync(path.resolve(<span class=\"string\">&#x27;../../Documents/keys/localhost-cert.pem&#x27;</span>))</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">server.on(<span class=\"string\">&#x27;error&#x27;</span>, <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> <span class=\"built_in\">console</span>.error(err));</span><br><span class=\"line\"></span><br><span class=\"line\">server.on(<span class=\"string\">&#x27;stream&#x27;</span>, <span class=\"function\">(<span class=\"params\">stream, headers</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 流是双工的</span></span><br><span class=\"line\">  stream.respond(&#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;content-type&#x27;</span>: <span class=\"string\">&#x27;text/html; charset=utf-8&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;:status&#x27;</span>: <span class=\"number\">200</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  stream.pushStream(&#123; <span class=\"string\">&#x27;:path&#x27;</span>: <span class=\"string\">&#x27;/index.css&#x27;</span> &#125;, <span class=\"function\">(<span class=\"params\">err, pushStream, headers</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err</span><br><span class=\"line\">    pushStream.respond(&#123; <span class=\"string\">&#x27;:status&#x27;</span>: <span class=\"number\">200</span> , <span class=\"string\">&#x27;content-type&#x27;</span>: <span class=\"string\">&#x27;application/json&#x27;</span>&#125;);</span><br><span class=\"line\">    pushStream.end(fs.readFileSync(<span class=\"string\">&#x27;./index.css&#x27;</span>))</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  stream.end(fs.readFileSync(<span class=\"string\">&#x27;./index.html&#x27;</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxgz9043lzj31oi0dsju4.jpg\" alt=\"image-20211217175216824\"></p>\n<h3 id=\"2-Node-启动-HTTP-2\"><a href=\"#2-Node-启动-HTTP-2\" class=\"headerlink\" title=\"2. Node 启动 HTTP/2\"></a>2. Node 启动 HTTP/2</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 本地生成证书&amp;秘钥</span></span><br><span class=\"line\">openssl req -x509 -newkey rsa:2048 -nodes -sha256 -subj <span class=\"string\">&#x27;/CN=localhost&#x27;</span> \\</span><br><span class=\"line\">  -keyout localhost-privkey.pem -out localhost-cert.pem</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> http2 = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;http2&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;fs&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;path&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = http2.createSecureServer(&#123;</span><br><span class=\"line\">  <span class=\"attr\">key</span>: fs.readFileSync(path.resolve(<span class=\"string\">&#x27;../../Documents/keys/localhost-privkey.pem&#x27;</span>)),</span><br><span class=\"line\">  <span class=\"attr\">cert</span>: fs.readFileSync(path.resolve(<span class=\"string\">&#x27;../../Documents/keys/localhost-cert.pem&#x27;</span>))</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">server.on(<span class=\"string\">&#x27;error&#x27;</span>, <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> <span class=\"built_in\">console</span>.error(err));</span><br><span class=\"line\"></span><br><span class=\"line\">server.on(<span class=\"string\">&#x27;stream&#x27;</span>, <span class=\"function\">(<span class=\"params\">stream, headers</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 流是双工的</span></span><br><span class=\"line\">  stream.respond(&#123;</span><br><span class=\"line\">    <span class=\"string\">&#x27;content-type&#x27;</span>: <span class=\"string\">&#x27;text/html; charset=utf-8&#x27;</span>,</span><br><span class=\"line\">    <span class=\"string\">&#x27;:status&#x27;</span>: <span class=\"number\">200</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  stream.end(<span class=\"string\">&#x27;&lt;h1&gt;Hello World&lt;/h1&gt;&#x27;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">server.listen(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxgydh6hzfj31je0tk0vg.jpg\" alt=\"image-20211217172158431\"></p>\n<h3 id=\"3-注意：\"><a href=\"#3-注意：\" class=\"headerlink\" title=\"3. 注意：\"></a>3. 注意：</h3><ul>\n<li>HTTP/2 客户端浏览器基于 SSL/TLS 之上，所以实现 HTTP/2的 Web 浏览器都只支持加密。但是针对 RPC 通讯，并没有特殊的限制，例如：gRPC框架的实现就是基于 HTTP/2 建立在TCP层上通讯的。</li>\n</ul>\n"},{"title":"Nginx爬坑之旅 proxy_set_header","_content":"\n\n## Nginx爬坑之旅 proxy_set_header\n\n\n\n原文链接： http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header\n\n\n\n```bash\nSyntax:\tproxy_set_header field value;\nDefault:\t\nproxy_set_header Host $proxy_host;\nproxy_set_header Connection close;\nContext:\thttp, server, location\n```\n\n\n\n允许重新定义或附加字段到传递给代理服务器的请求头。值可以包含文本、变量及其组合。当且仅当当前级别上没有定义proxy_set_header指令时，这些指令从以前的配置级别继承。默认情况下，只有两个字段被重新定义:\n\n\n\n```bash\nproxy_set_header Host       $proxy_host;\nproxy_set_header Connection close;\n```\n\n\n\n如果启用了缓存，原始请求的报头字段**If- modified- since**，**If- unmodified - since**，**If- none - match**，**If- match**，**Range**和**If-Range**不会被传递到代理服务器。\n\n未更改的**Host**请求报头字段可以这样传递。\n\n```bash\nproxy_set_header Host       $http_host;\n```\n\n\n\n但是，如果这个字段没有出现在客户端请求头中，那么什么也不会被传递。在这种情况下，最好使用 **$host** 变量——它的值等于**host**请求报头字段中的服务器名，如果该字段不存在，则等于主服务器名:\n\n```bash\nproxy_set_header Host       $host;\n```\n\n\n\n另外，服务器名可以和被代理服务器的端口一起传递:\n\n```bash\nproxy_set_header Host       $host:$proxy_port;\n```\n\n\n\n如果报头字段的值是空字符串，那么该字段将不会被传递给代理服务器:\n\n\n\n```bash\nproxy_set_header Accept-Encoding \"\";\n```\n\n","source":"_posts/proxy_set_header.md","raw":"---\ntitle: Nginx爬坑之旅 proxy_set_header\ntags: 运维\n---\n\n\n## Nginx爬坑之旅 proxy_set_header\n\n\n\n原文链接： http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header\n\n\n\n```bash\nSyntax:\tproxy_set_header field value;\nDefault:\t\nproxy_set_header Host $proxy_host;\nproxy_set_header Connection close;\nContext:\thttp, server, location\n```\n\n\n\n允许重新定义或附加字段到传递给代理服务器的请求头。值可以包含文本、变量及其组合。当且仅当当前级别上没有定义proxy_set_header指令时，这些指令从以前的配置级别继承。默认情况下，只有两个字段被重新定义:\n\n\n\n```bash\nproxy_set_header Host       $proxy_host;\nproxy_set_header Connection close;\n```\n\n\n\n如果启用了缓存，原始请求的报头字段**If- modified- since**，**If- unmodified - since**，**If- none - match**，**If- match**，**Range**和**If-Range**不会被传递到代理服务器。\n\n未更改的**Host**请求报头字段可以这样传递。\n\n```bash\nproxy_set_header Host       $http_host;\n```\n\n\n\n但是，如果这个字段没有出现在客户端请求头中，那么什么也不会被传递。在这种情况下，最好使用 **$host** 变量——它的值等于**host**请求报头字段中的服务器名，如果该字段不存在，则等于主服务器名:\n\n```bash\nproxy_set_header Host       $host;\n```\n\n\n\n另外，服务器名可以和被代理服务器的端口一起传递:\n\n```bash\nproxy_set_header Host       $host:$proxy_port;\n```\n\n\n\n如果报头字段的值是空字符串，那么该字段将不会被传递给代理服务器:\n\n\n\n```bash\nproxy_set_header Accept-Encoding \"\";\n```\n\n","slug":"proxy_set_header","published":1,"date":"2021-09-07T13:00:49.614Z","updated":"2021-12-28T02:10:24.511Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxph7qmm000t1op79sds2sz5","content":"<h2 id=\"Nginx爬坑之旅-proxy-set-header\"><a href=\"#Nginx爬坑之旅-proxy-set-header\" class=\"headerlink\" title=\"Nginx爬坑之旅 proxy_set_header\"></a>Nginx爬坑之旅 proxy_set_header</h2><p>原文链接： <a href=\"http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header\">http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Syntax:\tproxy_set_header field value;</span><br><span class=\"line\">Default:\t</span><br><span class=\"line\">proxy_set_header Host <span class=\"variable\">$proxy_host</span>;</span><br><span class=\"line\">proxy_set_header Connection close;</span><br><span class=\"line\">Context:\thttp, server, location</span><br></pre></td></tr></table></figure>\n\n\n\n<p>允许重新定义或附加字段到传递给代理服务器的请求头。值可以包含文本、变量及其组合。当且仅当当前级别上没有定义proxy_set_header指令时，这些指令从以前的配置级别继承。默认情况下，只有两个字段被重新定义:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxy_set_header Host       <span class=\"variable\">$proxy_host</span>;</span><br><span class=\"line\">proxy_set_header Connection close;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果启用了缓存，原始请求的报头字段<strong>If- modified- since</strong>，<strong>If- unmodified - since</strong>，<strong>If- none - match</strong>，<strong>If- match</strong>，<strong>Range</strong>和<strong>If-Range</strong>不会被传递到代理服务器。</p>\n<p>未更改的<strong>Host</strong>请求报头字段可以这样传递。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxy_set_header Host       <span class=\"variable\">$http_host</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>但是，如果这个字段没有出现在客户端请求头中，那么什么也不会被传递。在这种情况下，最好使用 <strong>$host</strong> 变量——它的值等于<strong>host</strong>请求报头字段中的服务器名，如果该字段不存在，则等于主服务器名:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxy_set_header Host       <span class=\"variable\">$host</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>另外，服务器名可以和被代理服务器的端口一起传递:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxy_set_header Host       <span class=\"variable\">$host</span>:<span class=\"variable\">$proxy_port</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果报头字段的值是空字符串，那么该字段将不会被传递给代理服务器:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxy_set_header Accept-Encoding <span class=\"string\">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Nginx爬坑之旅-proxy-set-header\"><a href=\"#Nginx爬坑之旅-proxy-set-header\" class=\"headerlink\" title=\"Nginx爬坑之旅 proxy_set_header\"></a>Nginx爬坑之旅 proxy_set_header</h2><p>原文链接： <a href=\"http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header\">http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_set_header</a></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Syntax:\tproxy_set_header field value;</span><br><span class=\"line\">Default:\t</span><br><span class=\"line\">proxy_set_header Host <span class=\"variable\">$proxy_host</span>;</span><br><span class=\"line\">proxy_set_header Connection close;</span><br><span class=\"line\">Context:\thttp, server, location</span><br></pre></td></tr></table></figure>\n\n\n\n<p>允许重新定义或附加字段到传递给代理服务器的请求头。值可以包含文本、变量及其组合。当且仅当当前级别上没有定义proxy_set_header指令时，这些指令从以前的配置级别继承。默认情况下，只有两个字段被重新定义:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxy_set_header Host       <span class=\"variable\">$proxy_host</span>;</span><br><span class=\"line\">proxy_set_header Connection close;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果启用了缓存，原始请求的报头字段<strong>If- modified- since</strong>，<strong>If- unmodified - since</strong>，<strong>If- none - match</strong>，<strong>If- match</strong>，<strong>Range</strong>和<strong>If-Range</strong>不会被传递到代理服务器。</p>\n<p>未更改的<strong>Host</strong>请求报头字段可以这样传递。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxy_set_header Host       <span class=\"variable\">$http_host</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>但是，如果这个字段没有出现在客户端请求头中，那么什么也不会被传递。在这种情况下，最好使用 <strong>$host</strong> 变量——它的值等于<strong>host</strong>请求报头字段中的服务器名，如果该字段不存在，则等于主服务器名:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxy_set_header Host       <span class=\"variable\">$host</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>另外，服务器名可以和被代理服务器的端口一起传递:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxy_set_header Host       <span class=\"variable\">$host</span>:<span class=\"variable\">$proxy_port</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果报头字段的值是空字符串，那么该字段将不会被传递给代理服务器:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">proxy_set_header Accept-Encoding <span class=\"string\">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"RPC框架  - Thrift","_content":"\n\n## RPC框架  - Thrift\n\n\n\n### 一.  Thrift 安装\n\n1. 安装thrift\n\n```bash\n# 主要还是针对 linux 和 macOS系统\nbrew install thrift\n```\n\n2. 编写一个 IDL 文件\n\n````thrift\nstruct TAccountRpcDTO {\n    1: i64 uid,\n    2: string name,\n}\n\nservice TAccountService {\n    // 创建一个账号\n    void createAccount(1: TAccountRpcDTO tAccountRpcDTO);\n\n    // 获取某个账号\n    TAccountRpcDTO getAccount(1: i64 uid);\n}\n````\n\n3. 创建server端\n\n```javascript\nconst thrift = require('thrift');\n\n// 引入生成的struct和service方法\nconst TAccountService = require('./gen-nodejs/TAccountService')\n\n// 模拟数据库，本地创建一个对象，用作存储account\nconst accounts = {};\n\n// 开启rpc server\nconst server = thrift.createServer(TAccountService, {\n\tcreateAccount(account, result) {\n\t\tconsole.log('server createAccount:', account.uid);\n\n\t\taccounts[account.uid] = account;\n\t\tresult(null);\n\t},\n\n\tgetAccount(uid, result) {\n\t\tconsole.log('server getAccount:', uid);\n\n\t\tresult(null, accounts[uid]);\n\t},\n});\n\n// 监听3030端口\nserver.listen(3030);\n```\n\n4. 创建client\n\n```java\nconst thrift = require('thrift');\n\n// 引入生成的struct和service方法\nconst TAccountService = require('./gen-nodejs/TAccountService')\nconst TAccountTypes = require('./gen-nodejs/hello_types')\n\n// 建立连接和初始化client\nconst connection = thrift.createConnection('127.0.0.1', 3030, {\n    connect_timeout: 100,\n    max_attempts: 2 \n});\n\nconst client = thrift.createClient(TAccountService, connection);\n\n// 定义一个新的accountDto对象，用作测试\nconst account = new TAccountTypes.TAccountRpcDTO({\n\tuid: 1,\n\tname: 'Hello World',\n});\n\n// 监听error事件，node的NodeJS.EventEmitter类的on方法\nconnection.on('error', err => {\n\tconsole.error(err);\n});\n\n// 调用server端的createAccount方法\nclient.createAccount(account, err => {\n\tif (err) {\n\t\tconsole.error(err);\n\t\treturn;\n\t}\n\n\tconsole.log('client createAccount:', account.uid);\n\n\t// 获取刚刚”新建“的account\n\tclient.getAccount(account.uid, (err, resp) => {\n\t\tif (err) {\n\t\t\tconsole.error(err);\n\t\t\treturn;\n\t\t}\n\n\t\tconsole.log(`client getAccount: uid=${resp.uid}, name=${resp.name}`);\n\t\tconnection.end();\n\t});\n});\n```\n\n5. 启动服务\n\n```bash\n# 启动服务\nnode server.js\n# 启动客户端\nnode client.js\n```\n\n6. 打印结果\n\n![image-20211227203145631](https://tva1.sinaimg.cn/large/008i3skNly1gxso2130axj31m20ji426.jpg)\n\n### 二. IDL 编写\n\n1. 基本类型\n\n| 类型   | 含义    |\n| ------ | ------- |\n| bool   | Boolean |\n| Byte   | Btye    |\n| i16    | Short   |\n| I32    | Int     |\n| I64    | Long    |\n| double | double  |\n| String | String  |\n| binary | Byte[]  |\n\n2. struct 结构体\n\n```java\nstruct User {\n  1: required string name, //改字段必须填写\n  2: optional i32 age = 0; //默认值\n  3: bool gender //默认字段类型为optional\n}\n```\n\n- struct不能继承，但是可以嵌套，不能嵌套自己。\n- 其成员都是有明确类型\n- 成员是被正整数编号过的，其中的编号使不能重复的，这个是为了在传输过程中编码使用。\n- 成员分割符可以是逗号（,）或是分号（;），而且可以混用\n- 字段会有optional和required之分和protobuf一样，但是如果不指定则为无类型–可以不填充该值，但是在序列化传输的时候也会序列化进去，optional是不填充则部序列化，required是必须填充也必须序列化。\n- 每个字段可以设置默认值\n- 同一文件可以定义多个struct，也可以定义在不同的文件，进行include引入。\n\n\n\n3. Container 容器\n\n   ```java\n   struct Test {\n     1: map<string, User> usermap,\n     2: set<i32> intset,\n     3: list<double> doublelist\n   }\n   ```\n\n   - list: 元素类型为t的有序表，容许元素重复。对应c++的vector，java的ArrayList或javascript的数组\n   - set: 元素类型为t的无序表，不容许元素重复。对应c++中的set，java中的HashSet,python中的set，php中没有set，则转换为list类型了\n   - map<t, t>: 键类型为t，值类型为t的kv对，键不容许重复。对用c++中的map, Java的HashMap, PHP 对应 array, Python/Ruby 的dictionary\n\n4. Enum 枚举\n\n   ```java\n   enum HttpStatus {\n     OK = 200,\n     NOTFOUND=404\n   }\n   ```\n\n   - 编译器默认从0开始赋值\n   - 可以赋予某个常量某个整数\n   - 允许常量是十六进制整数\n   - 末尾没有分号\n   - 给常量赋缺省值时，使用常量的全称\n\n5. Service 服务定义类型\n\n   ```java\n   service HelloService {\n       i32 sayInt(1:i32 param)\n       string sayString(1:string param)\n       bool sayBoolean(1:bool param)\n       void sayVoid()\n   }\n   ```\n\n6. Namespace (名字空间)\n\n```java\nnamespace java com.example.test\n// 转义后\npackage com.example.test\n```\n\n\n\n### 3 . gRPC 与 thrift 框架对比\n\n![image-20211227203202798](https://tva1.sinaimg.cn/large/008i3skNly1gxso2btb2sj31fq0u0n06.jpg)\n\n![image-20211227203210073](https://tva1.sinaimg.cn/large/008i3skNly1gxso2g67iuj31ne0kkn0m.jpg)\n","source":"_posts/rpc.md","raw":"---\ntitle: RPC框架  - Thrift\ntags: node\n---\n\n\n## RPC框架  - Thrift\n\n\n\n### 一.  Thrift 安装\n\n1. 安装thrift\n\n```bash\n# 主要还是针对 linux 和 macOS系统\nbrew install thrift\n```\n\n2. 编写一个 IDL 文件\n\n````thrift\nstruct TAccountRpcDTO {\n    1: i64 uid,\n    2: string name,\n}\n\nservice TAccountService {\n    // 创建一个账号\n    void createAccount(1: TAccountRpcDTO tAccountRpcDTO);\n\n    // 获取某个账号\n    TAccountRpcDTO getAccount(1: i64 uid);\n}\n````\n\n3. 创建server端\n\n```javascript\nconst thrift = require('thrift');\n\n// 引入生成的struct和service方法\nconst TAccountService = require('./gen-nodejs/TAccountService')\n\n// 模拟数据库，本地创建一个对象，用作存储account\nconst accounts = {};\n\n// 开启rpc server\nconst server = thrift.createServer(TAccountService, {\n\tcreateAccount(account, result) {\n\t\tconsole.log('server createAccount:', account.uid);\n\n\t\taccounts[account.uid] = account;\n\t\tresult(null);\n\t},\n\n\tgetAccount(uid, result) {\n\t\tconsole.log('server getAccount:', uid);\n\n\t\tresult(null, accounts[uid]);\n\t},\n});\n\n// 监听3030端口\nserver.listen(3030);\n```\n\n4. 创建client\n\n```java\nconst thrift = require('thrift');\n\n// 引入生成的struct和service方法\nconst TAccountService = require('./gen-nodejs/TAccountService')\nconst TAccountTypes = require('./gen-nodejs/hello_types')\n\n// 建立连接和初始化client\nconst connection = thrift.createConnection('127.0.0.1', 3030, {\n    connect_timeout: 100,\n    max_attempts: 2 \n});\n\nconst client = thrift.createClient(TAccountService, connection);\n\n// 定义一个新的accountDto对象，用作测试\nconst account = new TAccountTypes.TAccountRpcDTO({\n\tuid: 1,\n\tname: 'Hello World',\n});\n\n// 监听error事件，node的NodeJS.EventEmitter类的on方法\nconnection.on('error', err => {\n\tconsole.error(err);\n});\n\n// 调用server端的createAccount方法\nclient.createAccount(account, err => {\n\tif (err) {\n\t\tconsole.error(err);\n\t\treturn;\n\t}\n\n\tconsole.log('client createAccount:', account.uid);\n\n\t// 获取刚刚”新建“的account\n\tclient.getAccount(account.uid, (err, resp) => {\n\t\tif (err) {\n\t\t\tconsole.error(err);\n\t\t\treturn;\n\t\t}\n\n\t\tconsole.log(`client getAccount: uid=${resp.uid}, name=${resp.name}`);\n\t\tconnection.end();\n\t});\n});\n```\n\n5. 启动服务\n\n```bash\n# 启动服务\nnode server.js\n# 启动客户端\nnode client.js\n```\n\n6. 打印结果\n\n![image-20211227203145631](https://tva1.sinaimg.cn/large/008i3skNly1gxso2130axj31m20ji426.jpg)\n\n### 二. IDL 编写\n\n1. 基本类型\n\n| 类型   | 含义    |\n| ------ | ------- |\n| bool   | Boolean |\n| Byte   | Btye    |\n| i16    | Short   |\n| I32    | Int     |\n| I64    | Long    |\n| double | double  |\n| String | String  |\n| binary | Byte[]  |\n\n2. struct 结构体\n\n```java\nstruct User {\n  1: required string name, //改字段必须填写\n  2: optional i32 age = 0; //默认值\n  3: bool gender //默认字段类型为optional\n}\n```\n\n- struct不能继承，但是可以嵌套，不能嵌套自己。\n- 其成员都是有明确类型\n- 成员是被正整数编号过的，其中的编号使不能重复的，这个是为了在传输过程中编码使用。\n- 成员分割符可以是逗号（,）或是分号（;），而且可以混用\n- 字段会有optional和required之分和protobuf一样，但是如果不指定则为无类型–可以不填充该值，但是在序列化传输的时候也会序列化进去，optional是不填充则部序列化，required是必须填充也必须序列化。\n- 每个字段可以设置默认值\n- 同一文件可以定义多个struct，也可以定义在不同的文件，进行include引入。\n\n\n\n3. Container 容器\n\n   ```java\n   struct Test {\n     1: map<string, User> usermap,\n     2: set<i32> intset,\n     3: list<double> doublelist\n   }\n   ```\n\n   - list: 元素类型为t的有序表，容许元素重复。对应c++的vector，java的ArrayList或javascript的数组\n   - set: 元素类型为t的无序表，不容许元素重复。对应c++中的set，java中的HashSet,python中的set，php中没有set，则转换为list类型了\n   - map<t, t>: 键类型为t，值类型为t的kv对，键不容许重复。对用c++中的map, Java的HashMap, PHP 对应 array, Python/Ruby 的dictionary\n\n4. Enum 枚举\n\n   ```java\n   enum HttpStatus {\n     OK = 200,\n     NOTFOUND=404\n   }\n   ```\n\n   - 编译器默认从0开始赋值\n   - 可以赋予某个常量某个整数\n   - 允许常量是十六进制整数\n   - 末尾没有分号\n   - 给常量赋缺省值时，使用常量的全称\n\n5. Service 服务定义类型\n\n   ```java\n   service HelloService {\n       i32 sayInt(1:i32 param)\n       string sayString(1:string param)\n       bool sayBoolean(1:bool param)\n       void sayVoid()\n   }\n   ```\n\n6. Namespace (名字空间)\n\n```java\nnamespace java com.example.test\n// 转义后\npackage com.example.test\n```\n\n\n\n### 3 . gRPC 与 thrift 框架对比\n\n![image-20211227203202798](https://tva1.sinaimg.cn/large/008i3skNly1gxso2btb2sj31fq0u0n06.jpg)\n\n![image-20211227203210073](https://tva1.sinaimg.cn/large/008i3skNly1gxso2g67iuj31ne0kkn0m.jpg)\n","slug":"rpc","published":1,"date":"2021-12-12T13:26:43.075Z","updated":"2021-12-28T02:09:42.468Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxph7qmn000w1op7afvm9ez3","content":"<h2 id=\"RPC框架-Thrift\"><a href=\"#RPC框架-Thrift\" class=\"headerlink\" title=\"RPC框架  - Thrift\"></a>RPC框架  - Thrift</h2><h3 id=\"一-Thrift-安装\"><a href=\"#一-Thrift-安装\" class=\"headerlink\" title=\"一.  Thrift 安装\"></a>一.  Thrift 安装</h3><ol>\n<li>安装thrift</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 主要还是针对 linux 和 macOS系统</span></span><br><span class=\"line\">brew install thrift</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>编写一个 IDL 文件</li>\n</ol>\n<figure class=\"highlight thrift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TAccountRpcDTO</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"number\">1</span>: <span class=\"built_in\">i64</span> uid,</span><br><span class=\"line\">    <span class=\"number\">2</span>: <span class=\"built_in\">string</span> name,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">service</span> <span class=\"title\">TAccountService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个账号</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> createAccount(<span class=\"number\">1</span>: TAccountRpcDTO tAccountRpcDTO);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取某个账号</span></span><br><span class=\"line\">    TAccountRpcDTO getAccount(<span class=\"number\">1</span>: <span class=\"built_in\">i64</span> uid);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>创建server端</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> thrift = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;thrift&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引入生成的struct和service方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> TAccountService = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./gen-nodejs/TAccountService&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模拟数据库，本地创建一个对象，用作存储account</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> accounts = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开启rpc server</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = thrift.createServer(TAccountService, &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">createAccount</span>(<span class=\"params\">account, result</span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;server createAccount:&#x27;</span>, account.uid);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\taccounts[account.uid] = account;</span><br><span class=\"line\">\t\tresult(<span class=\"literal\">null</span>);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">getAccount</span>(<span class=\"params\">uid, result</span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;server getAccount:&#x27;</span>, uid);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tresult(<span class=\"literal\">null</span>, accounts[uid]);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听3030端口</span></span><br><span class=\"line\">server.listen(<span class=\"number\">3030</span>);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>创建client</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> thrift = require(<span class=\"string\">&#x27;thrift&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引入生成的struct和service方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> TAccountService = require(<span class=\"string\">&#x27;./gen-nodejs/TAccountService&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> TAccountTypes = require(<span class=\"string\">&#x27;./gen-nodejs/hello_types&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 建立连接和初始化client</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> connection = thrift.createConnection(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">3030</span>, &#123;</span><br><span class=\"line\">    connect_timeout: <span class=\"number\">100</span>,</span><br><span class=\"line\">    max_attempts: <span class=\"number\">2</span> </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> client = thrift.createClient(TAccountService, connection);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个新的accountDto对象，用作测试</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> account = <span class=\"keyword\">new</span> TAccountTypes.TAccountRpcDTO(&#123;</span><br><span class=\"line\">\tuid: <span class=\"number\">1</span>,</span><br><span class=\"line\">\tname: <span class=\"string\">&#x27;Hello World&#x27;</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听error事件，node的NodeJS.EventEmitter类的on方法</span></span><br><span class=\"line\">connection.on(<span class=\"string\">&#x27;error&#x27;</span>, err =&gt; &#123;</span><br><span class=\"line\">\tconsole.error(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用server端的createAccount方法</span></span><br><span class=\"line\">client.createAccount(account, err =&gt; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">\t\tconsole.error(err);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tconsole.log(<span class=\"string\">&#x27;client createAccount:&#x27;</span>, account.uid);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 获取刚刚”新建“的account</span></span><br><span class=\"line\">\tclient.getAccount(account.uid, (err, resp) =&gt; &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">\t\t\tconsole.error(err);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tconsole.log(`client getAccount: uid=$&#123;resp.uid&#125;, name=$&#123;resp.name&#125;`);</span><br><span class=\"line\">\t\tconnection.end();</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>启动服务</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动服务</span></span><br><span class=\"line\">node server.js</span><br><span class=\"line\"><span class=\"comment\"># 启动客户端</span></span><br><span class=\"line\">node client.js</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>打印结果</li>\n</ol>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso2130axj31m20ji426.jpg\" alt=\"image-20211227203145631\"></p>\n<h3 id=\"二-IDL-编写\"><a href=\"#二-IDL-编写\" class=\"headerlink\" title=\"二. IDL 编写\"></a>二. IDL 编写</h3><ol>\n<li>基本类型</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bool</td>\n<td>Boolean</td>\n</tr>\n<tr>\n<td>Byte</td>\n<td>Btye</td>\n</tr>\n<tr>\n<td>i16</td>\n<td>Short</td>\n</tr>\n<tr>\n<td>I32</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>I64</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr>\n<td>String</td>\n<td>String</td>\n</tr>\n<tr>\n<td>binary</td>\n<td>Byte[]</td>\n</tr>\n</tbody></table>\n<ol start=\"2\">\n<li>struct 结构体</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct User &#123;</span><br><span class=\"line\">  <span class=\"number\">1</span>: required string name, <span class=\"comment\">//改字段必须填写</span></span><br><span class=\"line\">  <span class=\"number\">2</span>: optional i32 age = <span class=\"number\">0</span>; <span class=\"comment\">//默认值</span></span><br><span class=\"line\">  <span class=\"number\">3</span>: bool gender <span class=\"comment\">//默认字段类型为optional</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>struct不能继承，但是可以嵌套，不能嵌套自己。</li>\n<li>其成员都是有明确类型</li>\n<li>成员是被正整数编号过的，其中的编号使不能重复的，这个是为了在传输过程中编码使用。</li>\n<li>成员分割符可以是逗号（,）或是分号（;），而且可以混用</li>\n<li>字段会有optional和required之分和protobuf一样，但是如果不指定则为无类型–可以不填充该值，但是在序列化传输的时候也会序列化进去，optional是不填充则部序列化，required是必须填充也必须序列化。</li>\n<li>每个字段可以设置默认值</li>\n<li>同一文件可以定义多个struct，也可以定义在不同的文件，进行include引入。</li>\n</ul>\n<ol start=\"3\">\n<li><p>Container 容器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Test &#123;</span><br><span class=\"line\">  <span class=\"number\">1</span>: map&lt;string, User&gt; usermap,</span><br><span class=\"line\">  <span class=\"number\">2</span>: set&lt;i32&gt; intset,</span><br><span class=\"line\">  <span class=\"number\">3</span>: list&lt;<span class=\"keyword\">double</span>&gt; doublelist</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>list: 元素类型为t的有序表，容许元素重复。对应c++的vector，java的ArrayList或javascript的数组</li>\n<li>set: 元素类型为t的无序表，不容许元素重复。对应c++中的set，java中的HashSet,python中的set，php中没有set，则转换为list类型了</li>\n<li>map&lt;t, t&gt;: 键类型为t，值类型为t的kv对，键不容许重复。对用c++中的map, Java的HashMap, PHP 对应 array, Python/Ruby 的dictionary</li>\n</ul>\n</li>\n<li><p>Enum 枚举</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">HttpStatus</span> </span>&#123;</span><br><span class=\"line\">  OK = <span class=\"number\">200</span>,</span><br><span class=\"line\">  NOTFOUND=<span class=\"number\">404</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>编译器默认从0开始赋值</li>\n<li>可以赋予某个常量某个整数</li>\n<li>允许常量是十六进制整数</li>\n<li>末尾没有分号</li>\n<li>给常量赋缺省值时，使用常量的全称</li>\n</ul>\n</li>\n<li><p>Service 服务定义类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service HelloService &#123;</span><br><span class=\"line\">    <span class=\"function\">i32 <span class=\"title\">sayInt</span><span class=\"params\">(<span class=\"number\">1</span>:i32 param)</span></span></span><br><span class=\"line\"><span class=\"function\">    string <span class=\"title\">sayString</span><span class=\"params\">(<span class=\"number\">1</span>:string param)</span></span></span><br><span class=\"line\"><span class=\"function\">    bool <span class=\"title\">sayBoolean</span><span class=\"params\">(<span class=\"number\">1</span>:bool param)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">void</span> <span class=\"title\">sayVoid</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li><p>Namespace (名字空间)</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace java com.example.test</span><br><span class=\"line\"><span class=\"comment\">// 转义后</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.example.test</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-gRPC-与-thrift-框架对比\"><a href=\"#3-gRPC-与-thrift-框架对比\" class=\"headerlink\" title=\"3 . gRPC 与 thrift 框架对比\"></a>3 . gRPC 与 thrift 框架对比</h3><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso2btb2sj31fq0u0n06.jpg\" alt=\"image-20211227203202798\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso2g67iuj31ne0kkn0m.jpg\" alt=\"image-20211227203210073\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"RPC框架-Thrift\"><a href=\"#RPC框架-Thrift\" class=\"headerlink\" title=\"RPC框架  - Thrift\"></a>RPC框架  - Thrift</h2><h3 id=\"一-Thrift-安装\"><a href=\"#一-Thrift-安装\" class=\"headerlink\" title=\"一.  Thrift 安装\"></a>一.  Thrift 安装</h3><ol>\n<li>安装thrift</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 主要还是针对 linux 和 macOS系统</span></span><br><span class=\"line\">brew install thrift</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>编写一个 IDL 文件</li>\n</ol>\n<figure class=\"highlight thrift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">TAccountRpcDTO</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"number\">1</span>: <span class=\"built_in\">i64</span> uid,</span><br><span class=\"line\">    <span class=\"number\">2</span>: <span class=\"built_in\">string</span> name,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">service</span> <span class=\"title\">TAccountService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建一个账号</span></span><br><span class=\"line\">    <span class=\"keyword\">void</span> createAccount(<span class=\"number\">1</span>: TAccountRpcDTO tAccountRpcDTO);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取某个账号</span></span><br><span class=\"line\">    TAccountRpcDTO getAccount(<span class=\"number\">1</span>: <span class=\"built_in\">i64</span> uid);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>创建server端</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> thrift = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;thrift&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引入生成的struct和service方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> TAccountService = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;./gen-nodejs/TAccountService&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 模拟数据库，本地创建一个对象，用作存储account</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> accounts = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 开启rpc server</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> server = thrift.createServer(TAccountService, &#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">createAccount</span>(<span class=\"params\">account, result</span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;server createAccount:&#x27;</span>, account.uid);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\taccounts[account.uid] = account;</span><br><span class=\"line\">\t\tresult(<span class=\"literal\">null</span>);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"title\">getAccount</span>(<span class=\"params\">uid, result</span>)</span> &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;server getAccount:&#x27;</span>, uid);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tresult(<span class=\"literal\">null</span>, accounts[uid]);</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听3030端口</span></span><br><span class=\"line\">server.listen(<span class=\"number\">3030</span>);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>创建client</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> thrift = require(<span class=\"string\">&#x27;thrift&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 引入生成的struct和service方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> TAccountService = require(<span class=\"string\">&#x27;./gen-nodejs/TAccountService&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> TAccountTypes = require(<span class=\"string\">&#x27;./gen-nodejs/hello_types&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 建立连接和初始化client</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> connection = thrift.createConnection(<span class=\"string\">&#x27;127.0.0.1&#x27;</span>, <span class=\"number\">3030</span>, &#123;</span><br><span class=\"line\">    connect_timeout: <span class=\"number\">100</span>,</span><br><span class=\"line\">    max_attempts: <span class=\"number\">2</span> </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> client = thrift.createClient(TAccountService, connection);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义一个新的accountDto对象，用作测试</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> account = <span class=\"keyword\">new</span> TAccountTypes.TAccountRpcDTO(&#123;</span><br><span class=\"line\">\tuid: <span class=\"number\">1</span>,</span><br><span class=\"line\">\tname: <span class=\"string\">&#x27;Hello World&#x27;</span>,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 监听error事件，node的NodeJS.EventEmitter类的on方法</span></span><br><span class=\"line\">connection.on(<span class=\"string\">&#x27;error&#x27;</span>, err =&gt; &#123;</span><br><span class=\"line\">\tconsole.error(err);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用server端的createAccount方法</span></span><br><span class=\"line\">client.createAccount(account, err =&gt; &#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">\t\tconsole.error(err);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\tconsole.log(<span class=\"string\">&#x27;client createAccount:&#x27;</span>, account.uid);</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">// 获取刚刚”新建“的account</span></span><br><span class=\"line\">\tclient.getAccount(account.uid, (err, resp) =&gt; &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">\t\t\tconsole.error(err);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tconsole.log(`client getAccount: uid=$&#123;resp.uid&#125;, name=$&#123;resp.name&#125;`);</span><br><span class=\"line\">\t\tconnection.end();</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>启动服务</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 启动服务</span></span><br><span class=\"line\">node server.js</span><br><span class=\"line\"><span class=\"comment\"># 启动客户端</span></span><br><span class=\"line\">node client.js</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>打印结果</li>\n</ol>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso2130axj31m20ji426.jpg\" alt=\"image-20211227203145631\"></p>\n<h3 id=\"二-IDL-编写\"><a href=\"#二-IDL-编写\" class=\"headerlink\" title=\"二. IDL 编写\"></a>二. IDL 编写</h3><ol>\n<li>基本类型</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>bool</td>\n<td>Boolean</td>\n</tr>\n<tr>\n<td>Byte</td>\n<td>Btye</td>\n</tr>\n<tr>\n<td>i16</td>\n<td>Short</td>\n</tr>\n<tr>\n<td>I32</td>\n<td>Int</td>\n</tr>\n<tr>\n<td>I64</td>\n<td>Long</td>\n</tr>\n<tr>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr>\n<td>String</td>\n<td>String</td>\n</tr>\n<tr>\n<td>binary</td>\n<td>Byte[]</td>\n</tr>\n</tbody></table>\n<ol start=\"2\">\n<li>struct 结构体</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct User &#123;</span><br><span class=\"line\">  <span class=\"number\">1</span>: required string name, <span class=\"comment\">//改字段必须填写</span></span><br><span class=\"line\">  <span class=\"number\">2</span>: optional i32 age = <span class=\"number\">0</span>; <span class=\"comment\">//默认值</span></span><br><span class=\"line\">  <span class=\"number\">3</span>: bool gender <span class=\"comment\">//默认字段类型为optional</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>struct不能继承，但是可以嵌套，不能嵌套自己。</li>\n<li>其成员都是有明确类型</li>\n<li>成员是被正整数编号过的，其中的编号使不能重复的，这个是为了在传输过程中编码使用。</li>\n<li>成员分割符可以是逗号（,）或是分号（;），而且可以混用</li>\n<li>字段会有optional和required之分和protobuf一样，但是如果不指定则为无类型–可以不填充该值，但是在序列化传输的时候也会序列化进去，optional是不填充则部序列化，required是必须填充也必须序列化。</li>\n<li>每个字段可以设置默认值</li>\n<li>同一文件可以定义多个struct，也可以定义在不同的文件，进行include引入。</li>\n</ul>\n<ol start=\"3\">\n<li><p>Container 容器</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct Test &#123;</span><br><span class=\"line\">  <span class=\"number\">1</span>: map&lt;string, User&gt; usermap,</span><br><span class=\"line\">  <span class=\"number\">2</span>: set&lt;i32&gt; intset,</span><br><span class=\"line\">  <span class=\"number\">3</span>: list&lt;<span class=\"keyword\">double</span>&gt; doublelist</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>list: 元素类型为t的有序表，容许元素重复。对应c++的vector，java的ArrayList或javascript的数组</li>\n<li>set: 元素类型为t的无序表，不容许元素重复。对应c++中的set，java中的HashSet,python中的set，php中没有set，则转换为list类型了</li>\n<li>map&lt;t, t&gt;: 键类型为t，值类型为t的kv对，键不容许重复。对用c++中的map, Java的HashMap, PHP 对应 array, Python/Ruby 的dictionary</li>\n</ul>\n</li>\n<li><p>Enum 枚举</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">enum</span> <span class=\"title\">HttpStatus</span> </span>&#123;</span><br><span class=\"line\">  OK = <span class=\"number\">200</span>,</span><br><span class=\"line\">  NOTFOUND=<span class=\"number\">404</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>编译器默认从0开始赋值</li>\n<li>可以赋予某个常量某个整数</li>\n<li>允许常量是十六进制整数</li>\n<li>末尾没有分号</li>\n<li>给常量赋缺省值时，使用常量的全称</li>\n</ul>\n</li>\n<li><p>Service 服务定义类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">service HelloService &#123;</span><br><span class=\"line\">    <span class=\"function\">i32 <span class=\"title\">sayInt</span><span class=\"params\">(<span class=\"number\">1</span>:i32 param)</span></span></span><br><span class=\"line\"><span class=\"function\">    string <span class=\"title\">sayString</span><span class=\"params\">(<span class=\"number\">1</span>:string param)</span></span></span><br><span class=\"line\"><span class=\"function\">    bool <span class=\"title\">sayBoolean</span><span class=\"params\">(<span class=\"number\">1</span>:bool param)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">void</span> <span class=\"title\">sayVoid</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li><p>Namespace (名字空间)</p>\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">namespace java com.example.test</span><br><span class=\"line\"><span class=\"comment\">// 转义后</span></span><br><span class=\"line\"><span class=\"keyword\">package</span> com.example.test</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"3-gRPC-与-thrift-框架对比\"><a href=\"#3-gRPC-与-thrift-框架对比\" class=\"headerlink\" title=\"3 . gRPC 与 thrift 框架对比\"></a>3 . gRPC 与 thrift 框架对比</h3><p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso2btb2sj31fq0u0n06.jpg\" alt=\"image-20211227203202798\"></p>\n<p><img src=\"https://tva1.sinaimg.cn/large/008i3skNly1gxso2g67iuj31ne0kkn0m.jpg\" alt=\"image-20211227203210073\"></p>\n"},{"title":"单例 Node.js 可以处理多少请求","_content":"\n# 单例 Node.js 可以处理多少请求\n\n> 原文：https://javascript.plainenglish.io/how-many-requests-can-handle-a-real-world-nodejs-server-side-application-55da7a2f06f3\n\n## 介绍\n\n当我刚接触 Node.js 时，我想知道我的 Node.js 应用程序有多少请求可以在生产中实际处理（作为一个真实的应用程序）。或者我需要多少个服务器实例来处理特定数量的流量。\n\n去年，我在独角兽公司 PicsArt 的一篇文章中读到了一些对我来说非常有趣的东西。他们每秒处理 40K 请求，后端使用 Node.js。\n\n![-w716](media/16279534330189/16279536518753.jpg)\n\n好吧，40K rps 真的很大，除了后端服务器之外，还取决于其他一些因素。但此刻让我们忘记这些因素，只考虑后端硬件和软件，尤其是 Node.js。\n\n**rps** \n\n```\nTPS（RPS）=业务量/单位时间（10*60，以秒为单位）。\n```\n\n## 调研\n\nFastify 开发者做了一个基准测试，它表明 express.js 每秒可以处理约 15K 请求，vanilla HTTP 模块可以处理 70K rps。\n\n![-w722](media/16279534330189/16279544665083.jpg)\n\n我用 Macbook Pro 15\" 2015 试了一下，结果几乎一样。甚至 express.js 的 15K rps 结果听起来也很棒。但是benchmarks 通常是在一个很小的 ​​API 处理程序上进行的，这与现实世界的 API 相去甚远。\n\n那么，怎么让 API 成为“真实世界”？**数据**，**数据传输**，**以及组件之间的交互**。要模拟真实世界的 API，我们必须创建一个与 DB 或其他服务通信的处理程序。\n\n## 实验\n\n这些结果并不重要。在大多数情况下，像 express(15K) 这样经过验证的框架更好，因为，实际上，您不会使用单个实例每秒处理 100K 请求。因此，我为我的基准测试安装了 express.js 并创建了一个具有各种类型操作的小型 API 处理程序，并进行了负载测试。\n\n![](media/16279534330189/16279548399681.jpg)\n\n- 在数据库中写入一个新用户\n- 从数据库中获取 20 个用户\n- 栅格化 20 个用户的数组\n- 将20个用户对象递归转换为camelCase\n- 对 20 个用户的数组进行排序\n- 还有一些轻量级计算和标准输出\n\n响应大小约为 12KB，每个用户对象看起来像这样。\n\n![](media/16279534330189/16279549710040.jpg)\n\n## 用 AWS RDS 在 Heroku 中使用 Node.js\n\n我在 Heroku 中以 25 美元/月的硬件部署了该应用程序。然后我在不增加平均延迟的情况下尽可能多地发送请求。所以，我的 Node.js 实例能够在 60 秒内处理 31K 请求，这意味着平均每秒 515 个请求。\n\n![](media/16279534330189/16279554273375.jpg)\n\n## 使用 AWS RDS 在 Heroku 中使用 Django\n\n然后，我问如果我尝试使用非单线程技术进行同样的操作会发生什么。我使用等效的处理程序为 Django 应用程序创建了完全相同的条件并将其部署到同一台服务器。结果比 Node.js 差一点，我可以在 60 秒内达到 23K 请求，因此，每秒 389 个请求。\n\n![](media/16279534330189/16279555316101.jpg)\n\n## 带有 AWS RDS 的 AWS EB 上的 Node.js（3 个实例）\n\n然后，我问，如果我的 Node.js 应用程序是一个真正的生产应用程序，并且它部署在 AWS 中，针对特定流量启动并运行会怎样。我选择法兰克福(eu-central-1，对我来说它是最近的，大约3000公里😁)地区的DB和后端服务器。在这个测试中，我使用了3个Node.js实例和AWS负载平衡。我的3个实例能够在10秒内处理19K请求，这意味着每秒1858个请求。然后，我持续加载我的应用，我可以在13分钟内达到150万成功请求，这是令人兴奋的😁。\n\n![](media/16279534330189/16279556113510.jpg)\n\n那么，我们用一个实例处理600rps，我们需要什么来处理每秒40K的请求?假设平台的平均API比测试中大两倍。所以，我需要40000 /(600/2)= 133个实例，在世界各地的不同地点，一个全球性的独角兽应用。\n\n它可以大 3 倍，但也可以使用各种缓存技术、基于事件的通信等来赢得每秒更多的请求，所以我认为大 2 倍是准确的衡量标准。\n\n我想用一个有用的列表来结束这篇文章，其中列出了您在使用或将要使用的应用程序中可能会遇到的一些问题。\n\n## 可能的性能问题\n\n有无数因素会减慢我们的 API。我分离了一些我们可以在大多数 Web 服务器端应用程序中看到的与性能相关的部分。\n\n- 存储或从DB中获取的数据大小。特别是当我们谈到关系数据库时，这一点就更加重要了，因为大数据通常意味着数据库管理系统和DB内存磁盘之间的复杂查询或复杂操作。然而，在所有情况下，字节越多，所需的传输时间就越多。我们还应该记住，在DB中保存文件是一种反模式，相反，我们应该考虑使用对象存储。理想情况下，我们的数据大小不应该超过几十kb，通常是1-20kb。\n- 后端服务器与DB服务器之间的物理距离。距离越远，DB接收查询并发送回后台服务器的时间就越长。考虑一个示例，其中我们在美国弗吉尼亚和德国法兰克福有两个后端服务器，但在美国弗吉尼亚只有一个DB服务器。我们的美国用户的请求将被路由到我们的美国后端实例，延迟约为10-40ms，然后从后端(弗吉尼亚)到DB(弗吉尼亚)的延迟为1-5ms。不坏。让我们看看来自德国的用户会发生什么，“用户的设备”-“后台服务器”的延迟将是10 - 20毫秒，但查询数据将需要120 - 130毫秒。如果我们有一个单一的区域应用，理想情况下我们的数据和后端逻辑是相邻的。或者如果我们有一个全球范围的应用程序，我们应该准备好做各种复杂的工程，以获得良好的性能。\n- DB 服务器硬件也有很大的影响。如果我们有一个小应用程序，考虑购买更好的硬件来适应我们的流量，否则——“各种复杂的工程材料”。\n- DB调用的次数。在真实的API中，我们可以有，比如，几十个单独的DB调用来最终完成任务，除此之外，在那个API中我们还可以有服务调用，每个服务都有自己的“几十个DB调用”。我遇到的一个令人印象深刻的例子是很久以前我加入的一个项目，一个银行业的后端API。在云开发环境中有一个响应时间为9秒的API。这个API下的服务处理程序有300行代码，其中我们可以找到大约30个DB调用和大约10个内部服务调用。当我们的方法是“代码优先”而不是“设计优先”时，通常会发生这种情况。根据我们的业务逻辑，有许多解决方案可以帮助避免这种情况。例如，队列和其他异步措施可以让我们在“后台”处理一些DB调用。为了利用这一点，我们需要将大服务分解为小服务。此外，我们还可以加入查询以减少DB调用的数量。\n- hooks。在所有流行的ODM/ orm中，都有一个称为hooks/中间件的特性。有时候，让这个特性处理一些逻辑是非常合适的。有时，特别是在处理批量操作时，我们可能会面临“隐藏的”瓶颈。ODM/ORM插件也需要计算资源，也需要花费时间(例如camelCase/pascal_case转换插件)。挂钩确实很有帮助，但需要仔细考虑我们写的内容和我们写的地方。\n- cpu密集型的任务不仅会减慢服务器的运行速度，而且还会让最终用户等待。在Node.js中，许多cpu密集型任务依赖于线程池。尽管它不会阻塞异步IO，但它会使API变慢。例如，用户单击注册并等待线程池散列他/她的密码，顺便说一下，这需要100毫秒。\n- 事件循环的瓶颈。在Node.js中，代码的执行依赖于事件循环，所以我们的代码的性能对整个应用程序有直接的影响(因为它是在单个线程上运行的)。例如，使用JSON。解析/stringify会降低api的速度。嵌套循环和递归函数也很危险。当忽略Node.js如何工作时，根据数据大小和应用程序流量，我们可能会遇到问题，我们的应用程序可能不可用。\n- 糟糕的基础体系结构。大型基础设施中可能出现的问题不仅仅是单一应用程序中的问题，它们是不同的，有时它们需要复杂的架构解决方案。当我们的基础架构包含许多组件时，糟糕的架构会对我们的api产生巨大的影响，我们的系统将以一种资源效率低下的方式工作，这意味着我们将为原本可以更便宜的东西付出更多。因此，在设计复杂的应用程序时，我们必须考虑特定技术解决的问题，并充分了解备选方案。我们还需要考虑透视图，如果我们在两个月或六个月的时间内，在制作一个特性时，业务需求发生了变化，对每条语句都尽可能地进行猜测。考虑SLA。考虑一下非功能需求，如果流量增加怎么办?随时准备迎接意想不到的高流量，即使有理论说我们必须准备好处理比现在多10倍的流量。\n- 组件/硬件/设置。我们在基础架构中创建的组件可能会降低整个平台的运行速度。假设我们使用RabbitMQ。它像任何技术一样有大量的配置和选项。如果我们一开始就遵循标准，那也没关系。但是，随着时间的推移，如果我们做更多的研究，如果我们深入到一个特定的组件，我们意识到我们可以通过做一些设置审查，或通过重构配置或服务的使用来改进我们的基础设施。此外，我们必须根据使用情况扩展组件，以避免在基础设施中产生瓶颈。\n\n\n\n","source":"_posts/单例 Node.js 可以处理多少请求.md","raw":"---\ntitle: 单例 Node.js 可以处理多少请求\ntags: node\n---\n\n# 单例 Node.js 可以处理多少请求\n\n> 原文：https://javascript.plainenglish.io/how-many-requests-can-handle-a-real-world-nodejs-server-side-application-55da7a2f06f3\n\n## 介绍\n\n当我刚接触 Node.js 时，我想知道我的 Node.js 应用程序有多少请求可以在生产中实际处理（作为一个真实的应用程序）。或者我需要多少个服务器实例来处理特定数量的流量。\n\n去年，我在独角兽公司 PicsArt 的一篇文章中读到了一些对我来说非常有趣的东西。他们每秒处理 40K 请求，后端使用 Node.js。\n\n![-w716](media/16279534330189/16279536518753.jpg)\n\n好吧，40K rps 真的很大，除了后端服务器之外，还取决于其他一些因素。但此刻让我们忘记这些因素，只考虑后端硬件和软件，尤其是 Node.js。\n\n**rps** \n\n```\nTPS（RPS）=业务量/单位时间（10*60，以秒为单位）。\n```\n\n## 调研\n\nFastify 开发者做了一个基准测试，它表明 express.js 每秒可以处理约 15K 请求，vanilla HTTP 模块可以处理 70K rps。\n\n![-w722](media/16279534330189/16279544665083.jpg)\n\n我用 Macbook Pro 15\" 2015 试了一下，结果几乎一样。甚至 express.js 的 15K rps 结果听起来也很棒。但是benchmarks 通常是在一个很小的 ​​API 处理程序上进行的，这与现实世界的 API 相去甚远。\n\n那么，怎么让 API 成为“真实世界”？**数据**，**数据传输**，**以及组件之间的交互**。要模拟真实世界的 API，我们必须创建一个与 DB 或其他服务通信的处理程序。\n\n## 实验\n\n这些结果并不重要。在大多数情况下，像 express(15K) 这样经过验证的框架更好，因为，实际上，您不会使用单个实例每秒处理 100K 请求。因此，我为我的基准测试安装了 express.js 并创建了一个具有各种类型操作的小型 API 处理程序，并进行了负载测试。\n\n![](media/16279534330189/16279548399681.jpg)\n\n- 在数据库中写入一个新用户\n- 从数据库中获取 20 个用户\n- 栅格化 20 个用户的数组\n- 将20个用户对象递归转换为camelCase\n- 对 20 个用户的数组进行排序\n- 还有一些轻量级计算和标准输出\n\n响应大小约为 12KB，每个用户对象看起来像这样。\n\n![](media/16279534330189/16279549710040.jpg)\n\n## 用 AWS RDS 在 Heroku 中使用 Node.js\n\n我在 Heroku 中以 25 美元/月的硬件部署了该应用程序。然后我在不增加平均延迟的情况下尽可能多地发送请求。所以，我的 Node.js 实例能够在 60 秒内处理 31K 请求，这意味着平均每秒 515 个请求。\n\n![](media/16279534330189/16279554273375.jpg)\n\n## 使用 AWS RDS 在 Heroku 中使用 Django\n\n然后，我问如果我尝试使用非单线程技术进行同样的操作会发生什么。我使用等效的处理程序为 Django 应用程序创建了完全相同的条件并将其部署到同一台服务器。结果比 Node.js 差一点，我可以在 60 秒内达到 23K 请求，因此，每秒 389 个请求。\n\n![](media/16279534330189/16279555316101.jpg)\n\n## 带有 AWS RDS 的 AWS EB 上的 Node.js（3 个实例）\n\n然后，我问，如果我的 Node.js 应用程序是一个真正的生产应用程序，并且它部署在 AWS 中，针对特定流量启动并运行会怎样。我选择法兰克福(eu-central-1，对我来说它是最近的，大约3000公里😁)地区的DB和后端服务器。在这个测试中，我使用了3个Node.js实例和AWS负载平衡。我的3个实例能够在10秒内处理19K请求，这意味着每秒1858个请求。然后，我持续加载我的应用，我可以在13分钟内达到150万成功请求，这是令人兴奋的😁。\n\n![](media/16279534330189/16279556113510.jpg)\n\n那么，我们用一个实例处理600rps，我们需要什么来处理每秒40K的请求?假设平台的平均API比测试中大两倍。所以，我需要40000 /(600/2)= 133个实例，在世界各地的不同地点，一个全球性的独角兽应用。\n\n它可以大 3 倍，但也可以使用各种缓存技术、基于事件的通信等来赢得每秒更多的请求，所以我认为大 2 倍是准确的衡量标准。\n\n我想用一个有用的列表来结束这篇文章，其中列出了您在使用或将要使用的应用程序中可能会遇到的一些问题。\n\n## 可能的性能问题\n\n有无数因素会减慢我们的 API。我分离了一些我们可以在大多数 Web 服务器端应用程序中看到的与性能相关的部分。\n\n- 存储或从DB中获取的数据大小。特别是当我们谈到关系数据库时，这一点就更加重要了，因为大数据通常意味着数据库管理系统和DB内存磁盘之间的复杂查询或复杂操作。然而，在所有情况下，字节越多，所需的传输时间就越多。我们还应该记住，在DB中保存文件是一种反模式，相反，我们应该考虑使用对象存储。理想情况下，我们的数据大小不应该超过几十kb，通常是1-20kb。\n- 后端服务器与DB服务器之间的物理距离。距离越远，DB接收查询并发送回后台服务器的时间就越长。考虑一个示例，其中我们在美国弗吉尼亚和德国法兰克福有两个后端服务器，但在美国弗吉尼亚只有一个DB服务器。我们的美国用户的请求将被路由到我们的美国后端实例，延迟约为10-40ms，然后从后端(弗吉尼亚)到DB(弗吉尼亚)的延迟为1-5ms。不坏。让我们看看来自德国的用户会发生什么，“用户的设备”-“后台服务器”的延迟将是10 - 20毫秒，但查询数据将需要120 - 130毫秒。如果我们有一个单一的区域应用，理想情况下我们的数据和后端逻辑是相邻的。或者如果我们有一个全球范围的应用程序，我们应该准备好做各种复杂的工程，以获得良好的性能。\n- DB 服务器硬件也有很大的影响。如果我们有一个小应用程序，考虑购买更好的硬件来适应我们的流量，否则——“各种复杂的工程材料”。\n- DB调用的次数。在真实的API中，我们可以有，比如，几十个单独的DB调用来最终完成任务，除此之外，在那个API中我们还可以有服务调用，每个服务都有自己的“几十个DB调用”。我遇到的一个令人印象深刻的例子是很久以前我加入的一个项目，一个银行业的后端API。在云开发环境中有一个响应时间为9秒的API。这个API下的服务处理程序有300行代码，其中我们可以找到大约30个DB调用和大约10个内部服务调用。当我们的方法是“代码优先”而不是“设计优先”时，通常会发生这种情况。根据我们的业务逻辑，有许多解决方案可以帮助避免这种情况。例如，队列和其他异步措施可以让我们在“后台”处理一些DB调用。为了利用这一点，我们需要将大服务分解为小服务。此外，我们还可以加入查询以减少DB调用的数量。\n- hooks。在所有流行的ODM/ orm中，都有一个称为hooks/中间件的特性。有时候，让这个特性处理一些逻辑是非常合适的。有时，特别是在处理批量操作时，我们可能会面临“隐藏的”瓶颈。ODM/ORM插件也需要计算资源，也需要花费时间(例如camelCase/pascal_case转换插件)。挂钩确实很有帮助，但需要仔细考虑我们写的内容和我们写的地方。\n- cpu密集型的任务不仅会减慢服务器的运行速度，而且还会让最终用户等待。在Node.js中，许多cpu密集型任务依赖于线程池。尽管它不会阻塞异步IO，但它会使API变慢。例如，用户单击注册并等待线程池散列他/她的密码，顺便说一下，这需要100毫秒。\n- 事件循环的瓶颈。在Node.js中，代码的执行依赖于事件循环，所以我们的代码的性能对整个应用程序有直接的影响(因为它是在单个线程上运行的)。例如，使用JSON。解析/stringify会降低api的速度。嵌套循环和递归函数也很危险。当忽略Node.js如何工作时，根据数据大小和应用程序流量，我们可能会遇到问题，我们的应用程序可能不可用。\n- 糟糕的基础体系结构。大型基础设施中可能出现的问题不仅仅是单一应用程序中的问题，它们是不同的，有时它们需要复杂的架构解决方案。当我们的基础架构包含许多组件时，糟糕的架构会对我们的api产生巨大的影响，我们的系统将以一种资源效率低下的方式工作，这意味着我们将为原本可以更便宜的东西付出更多。因此，在设计复杂的应用程序时，我们必须考虑特定技术解决的问题，并充分了解备选方案。我们还需要考虑透视图，如果我们在两个月或六个月的时间内，在制作一个特性时，业务需求发生了变化，对每条语句都尽可能地进行猜测。考虑SLA。考虑一下非功能需求，如果流量增加怎么办?随时准备迎接意想不到的高流量，即使有理论说我们必须准备好处理比现在多10倍的流量。\n- 组件/硬件/设置。我们在基础架构中创建的组件可能会降低整个平台的运行速度。假设我们使用RabbitMQ。它像任何技术一样有大量的配置和选项。如果我们一开始就遵循标准，那也没关系。但是，随着时间的推移，如果我们做更多的研究，如果我们深入到一个特定的组件，我们意识到我们可以通过做一些设置审查，或通过重构配置或服务的使用来改进我们的基础设施。此外，我们必须根据使用情况扩展组件，以避免在基础设施中产生瓶颈。\n\n\n\n","slug":"单例 Node.js 可以处理多少请求","published":1,"date":"2021-08-03T01:17:13.019Z","updated":"2021-12-28T02:08:39.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxph7qmo000x1op7cs0r94vp","content":"<h1 id=\"单例-Node-js-可以处理多少请求\"><a href=\"#单例-Node-js-可以处理多少请求\" class=\"headerlink\" title=\"单例 Node.js 可以处理多少请求\"></a>单例 Node.js 可以处理多少请求</h1><blockquote>\n<p>原文：<a href=\"https://javascript.plainenglish.io/how-many-requests-can-handle-a-real-world-nodejs-server-side-application-55da7a2f06f3\">https://javascript.plainenglish.io/how-many-requests-can-handle-a-real-world-nodejs-server-side-application-55da7a2f06f3</a></p>\n</blockquote>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>当我刚接触 Node.js 时，我想知道我的 Node.js 应用程序有多少请求可以在生产中实际处理（作为一个真实的应用程序）。或者我需要多少个服务器实例来处理特定数量的流量。</p>\n<p>去年，我在独角兽公司 PicsArt 的一篇文章中读到了一些对我来说非常有趣的东西。他们每秒处理 40K 请求，后端使用 Node.js。</p>\n<p><img src=\"media/16279534330189/16279536518753.jpg\" alt=\"-w716\"></p>\n<p>好吧，40K rps 真的很大，除了后端服务器之外，还取决于其他一些因素。但此刻让我们忘记这些因素，只考虑后端硬件和软件，尤其是 Node.js。</p>\n<p><strong>rps</strong> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TPS（RPS）=业务量/单位时间（10*60，以秒为单位）。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"调研\"><a href=\"#调研\" class=\"headerlink\" title=\"调研\"></a>调研</h2><p>Fastify 开发者做了一个基准测试，它表明 express.js 每秒可以处理约 15K 请求，vanilla HTTP 模块可以处理 70K rps。</p>\n<p><img src=\"media/16279534330189/16279544665083.jpg\" alt=\"-w722\"></p>\n<p>我用 Macbook Pro 15” 2015 试了一下，结果几乎一样。甚至 express.js 的 15K rps 结果听起来也很棒。但是benchmarks 通常是在一个很小的 ​​API 处理程序上进行的，这与现实世界的 API 相去甚远。</p>\n<p>那么，怎么让 API 成为“真实世界”？<strong>数据</strong>，<strong>数据传输</strong>，<strong>以及组件之间的交互</strong>。要模拟真实世界的 API，我们必须创建一个与 DB 或其他服务通信的处理程序。</p>\n<h2 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h2><p>这些结果并不重要。在大多数情况下，像 express(15K) 这样经过验证的框架更好，因为，实际上，您不会使用单个实例每秒处理 100K 请求。因此，我为我的基准测试安装了 express.js 并创建了一个具有各种类型操作的小型 API 处理程序，并进行了负载测试。</p>\n<p><img src=\"media/16279534330189/16279548399681.jpg\"></p>\n<ul>\n<li>在数据库中写入一个新用户</li>\n<li>从数据库中获取 20 个用户</li>\n<li>栅格化 20 个用户的数组</li>\n<li>将20个用户对象递归转换为camelCase</li>\n<li>对 20 个用户的数组进行排序</li>\n<li>还有一些轻量级计算和标准输出</li>\n</ul>\n<p>响应大小约为 12KB，每个用户对象看起来像这样。</p>\n<p><img src=\"media/16279534330189/16279549710040.jpg\"></p>\n<h2 id=\"用-AWS-RDS-在-Heroku-中使用-Node-js\"><a href=\"#用-AWS-RDS-在-Heroku-中使用-Node-js\" class=\"headerlink\" title=\"用 AWS RDS 在 Heroku 中使用 Node.js\"></a>用 AWS RDS 在 Heroku 中使用 Node.js</h2><p>我在 Heroku 中以 25 美元/月的硬件部署了该应用程序。然后我在不增加平均延迟的情况下尽可能多地发送请求。所以，我的 Node.js 实例能够在 60 秒内处理 31K 请求，这意味着平均每秒 515 个请求。</p>\n<p><img src=\"media/16279534330189/16279554273375.jpg\"></p>\n<h2 id=\"使用-AWS-RDS-在-Heroku-中使用-Django\"><a href=\"#使用-AWS-RDS-在-Heroku-中使用-Django\" class=\"headerlink\" title=\"使用 AWS RDS 在 Heroku 中使用 Django\"></a>使用 AWS RDS 在 Heroku 中使用 Django</h2><p>然后，我问如果我尝试使用非单线程技术进行同样的操作会发生什么。我使用等效的处理程序为 Django 应用程序创建了完全相同的条件并将其部署到同一台服务器。结果比 Node.js 差一点，我可以在 60 秒内达到 23K 请求，因此，每秒 389 个请求。</p>\n<p><img src=\"media/16279534330189/16279555316101.jpg\"></p>\n<h2 id=\"带有-AWS-RDS-的-AWS-EB-上的-Node-js（3-个实例）\"><a href=\"#带有-AWS-RDS-的-AWS-EB-上的-Node-js（3-个实例）\" class=\"headerlink\" title=\"带有 AWS RDS 的 AWS EB 上的 Node.js（3 个实例）\"></a>带有 AWS RDS 的 AWS EB 上的 Node.js（3 个实例）</h2><p>然后，我问，如果我的 Node.js 应用程序是一个真正的生产应用程序，并且它部署在 AWS 中，针对特定流量启动并运行会怎样。我选择法兰克福(eu-central-1，对我来说它是最近的，大约3000公里😁)地区的DB和后端服务器。在这个测试中，我使用了3个Node.js实例和AWS负载平衡。我的3个实例能够在10秒内处理19K请求，这意味着每秒1858个请求。然后，我持续加载我的应用，我可以在13分钟内达到150万成功请求，这是令人兴奋的😁。</p>\n<p><img src=\"media/16279534330189/16279556113510.jpg\"></p>\n<p>那么，我们用一个实例处理600rps，我们需要什么来处理每秒40K的请求?假设平台的平均API比测试中大两倍。所以，我需要40000 /(600/2)= 133个实例，在世界各地的不同地点，一个全球性的独角兽应用。</p>\n<p>它可以大 3 倍，但也可以使用各种缓存技术、基于事件的通信等来赢得每秒更多的请求，所以我认为大 2 倍是准确的衡量标准。</p>\n<p>我想用一个有用的列表来结束这篇文章，其中列出了您在使用或将要使用的应用程序中可能会遇到的一些问题。</p>\n<h2 id=\"可能的性能问题\"><a href=\"#可能的性能问题\" class=\"headerlink\" title=\"可能的性能问题\"></a>可能的性能问题</h2><p>有无数因素会减慢我们的 API。我分离了一些我们可以在大多数 Web 服务器端应用程序中看到的与性能相关的部分。</p>\n<ul>\n<li>存储或从DB中获取的数据大小。特别是当我们谈到关系数据库时，这一点就更加重要了，因为大数据通常意味着数据库管理系统和DB内存磁盘之间的复杂查询或复杂操作。然而，在所有情况下，字节越多，所需的传输时间就越多。我们还应该记住，在DB中保存文件是一种反模式，相反，我们应该考虑使用对象存储。理想情况下，我们的数据大小不应该超过几十kb，通常是1-20kb。</li>\n<li>后端服务器与DB服务器之间的物理距离。距离越远，DB接收查询并发送回后台服务器的时间就越长。考虑一个示例，其中我们在美国弗吉尼亚和德国法兰克福有两个后端服务器，但在美国弗吉尼亚只有一个DB服务器。我们的美国用户的请求将被路由到我们的美国后端实例，延迟约为10-40ms，然后从后端(弗吉尼亚)到DB(弗吉尼亚)的延迟为1-5ms。不坏。让我们看看来自德国的用户会发生什么，“用户的设备”-“后台服务器”的延迟将是10 - 20毫秒，但查询数据将需要120 - 130毫秒。如果我们有一个单一的区域应用，理想情况下我们的数据和后端逻辑是相邻的。或者如果我们有一个全球范围的应用程序，我们应该准备好做各种复杂的工程，以获得良好的性能。</li>\n<li>DB 服务器硬件也有很大的影响。如果我们有一个小应用程序，考虑购买更好的硬件来适应我们的流量，否则——“各种复杂的工程材料”。</li>\n<li>DB调用的次数。在真实的API中，我们可以有，比如，几十个单独的DB调用来最终完成任务，除此之外，在那个API中我们还可以有服务调用，每个服务都有自己的“几十个DB调用”。我遇到的一个令人印象深刻的例子是很久以前我加入的一个项目，一个银行业的后端API。在云开发环境中有一个响应时间为9秒的API。这个API下的服务处理程序有300行代码，其中我们可以找到大约30个DB调用和大约10个内部服务调用。当我们的方法是“代码优先”而不是“设计优先”时，通常会发生这种情况。根据我们的业务逻辑，有许多解决方案可以帮助避免这种情况。例如，队列和其他异步措施可以让我们在“后台”处理一些DB调用。为了利用这一点，我们需要将大服务分解为小服务。此外，我们还可以加入查询以减少DB调用的数量。</li>\n<li>hooks。在所有流行的ODM/ orm中，都有一个称为hooks/中间件的特性。有时候，让这个特性处理一些逻辑是非常合适的。有时，特别是在处理批量操作时，我们可能会面临“隐藏的”瓶颈。ODM/ORM插件也需要计算资源，也需要花费时间(例如camelCase/pascal_case转换插件)。挂钩确实很有帮助，但需要仔细考虑我们写的内容和我们写的地方。</li>\n<li>cpu密集型的任务不仅会减慢服务器的运行速度，而且还会让最终用户等待。在Node.js中，许多cpu密集型任务依赖于线程池。尽管它不会阻塞异步IO，但它会使API变慢。例如，用户单击注册并等待线程池散列他/她的密码，顺便说一下，这需要100毫秒。</li>\n<li>事件循环的瓶颈。在Node.js中，代码的执行依赖于事件循环，所以我们的代码的性能对整个应用程序有直接的影响(因为它是在单个线程上运行的)。例如，使用JSON。解析/stringify会降低api的速度。嵌套循环和递归函数也很危险。当忽略Node.js如何工作时，根据数据大小和应用程序流量，我们可能会遇到问题，我们的应用程序可能不可用。</li>\n<li>糟糕的基础体系结构。大型基础设施中可能出现的问题不仅仅是单一应用程序中的问题，它们是不同的，有时它们需要复杂的架构解决方案。当我们的基础架构包含许多组件时，糟糕的架构会对我们的api产生巨大的影响，我们的系统将以一种资源效率低下的方式工作，这意味着我们将为原本可以更便宜的东西付出更多。因此，在设计复杂的应用程序时，我们必须考虑特定技术解决的问题，并充分了解备选方案。我们还需要考虑透视图，如果我们在两个月或六个月的时间内，在制作一个特性时，业务需求发生了变化，对每条语句都尽可能地进行猜测。考虑SLA。考虑一下非功能需求，如果流量增加怎么办?随时准备迎接意想不到的高流量，即使有理论说我们必须准备好处理比现在多10倍的流量。</li>\n<li>组件/硬件/设置。我们在基础架构中创建的组件可能会降低整个平台的运行速度。假设我们使用RabbitMQ。它像任何技术一样有大量的配置和选项。如果我们一开始就遵循标准，那也没关系。但是，随着时间的推移，如果我们做更多的研究，如果我们深入到一个特定的组件，我们意识到我们可以通过做一些设置审查，或通过重构配置或服务的使用来改进我们的基础设施。此外，我们必须根据使用情况扩展组件，以避免在基础设施中产生瓶颈。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"单例-Node-js-可以处理多少请求\"><a href=\"#单例-Node-js-可以处理多少请求\" class=\"headerlink\" title=\"单例 Node.js 可以处理多少请求\"></a>单例 Node.js 可以处理多少请求</h1><blockquote>\n<p>原文：<a href=\"https://javascript.plainenglish.io/how-many-requests-can-handle-a-real-world-nodejs-server-side-application-55da7a2f06f3\">https://javascript.plainenglish.io/how-many-requests-can-handle-a-real-world-nodejs-server-side-application-55da7a2f06f3</a></p>\n</blockquote>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p>当我刚接触 Node.js 时，我想知道我的 Node.js 应用程序有多少请求可以在生产中实际处理（作为一个真实的应用程序）。或者我需要多少个服务器实例来处理特定数量的流量。</p>\n<p>去年，我在独角兽公司 PicsArt 的一篇文章中读到了一些对我来说非常有趣的东西。他们每秒处理 40K 请求，后端使用 Node.js。</p>\n<p><img src=\"media/16279534330189/16279536518753.jpg\" alt=\"-w716\"></p>\n<p>好吧，40K rps 真的很大，除了后端服务器之外，还取决于其他一些因素。但此刻让我们忘记这些因素，只考虑后端硬件和软件，尤其是 Node.js。</p>\n<p><strong>rps</strong> </p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">TPS（RPS）=业务量/单位时间（10*60，以秒为单位）。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"调研\"><a href=\"#调研\" class=\"headerlink\" title=\"调研\"></a>调研</h2><p>Fastify 开发者做了一个基准测试，它表明 express.js 每秒可以处理约 15K 请求，vanilla HTTP 模块可以处理 70K rps。</p>\n<p><img src=\"media/16279534330189/16279544665083.jpg\" alt=\"-w722\"></p>\n<p>我用 Macbook Pro 15” 2015 试了一下，结果几乎一样。甚至 express.js 的 15K rps 结果听起来也很棒。但是benchmarks 通常是在一个很小的 ​​API 处理程序上进行的，这与现实世界的 API 相去甚远。</p>\n<p>那么，怎么让 API 成为“真实世界”？<strong>数据</strong>，<strong>数据传输</strong>，<strong>以及组件之间的交互</strong>。要模拟真实世界的 API，我们必须创建一个与 DB 或其他服务通信的处理程序。</p>\n<h2 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h2><p>这些结果并不重要。在大多数情况下，像 express(15K) 这样经过验证的框架更好，因为，实际上，您不会使用单个实例每秒处理 100K 请求。因此，我为我的基准测试安装了 express.js 并创建了一个具有各种类型操作的小型 API 处理程序，并进行了负载测试。</p>\n<p><img src=\"media/16279534330189/16279548399681.jpg\"></p>\n<ul>\n<li>在数据库中写入一个新用户</li>\n<li>从数据库中获取 20 个用户</li>\n<li>栅格化 20 个用户的数组</li>\n<li>将20个用户对象递归转换为camelCase</li>\n<li>对 20 个用户的数组进行排序</li>\n<li>还有一些轻量级计算和标准输出</li>\n</ul>\n<p>响应大小约为 12KB，每个用户对象看起来像这样。</p>\n<p><img src=\"media/16279534330189/16279549710040.jpg\"></p>\n<h2 id=\"用-AWS-RDS-在-Heroku-中使用-Node-js\"><a href=\"#用-AWS-RDS-在-Heroku-中使用-Node-js\" class=\"headerlink\" title=\"用 AWS RDS 在 Heroku 中使用 Node.js\"></a>用 AWS RDS 在 Heroku 中使用 Node.js</h2><p>我在 Heroku 中以 25 美元/月的硬件部署了该应用程序。然后我在不增加平均延迟的情况下尽可能多地发送请求。所以，我的 Node.js 实例能够在 60 秒内处理 31K 请求，这意味着平均每秒 515 个请求。</p>\n<p><img src=\"media/16279534330189/16279554273375.jpg\"></p>\n<h2 id=\"使用-AWS-RDS-在-Heroku-中使用-Django\"><a href=\"#使用-AWS-RDS-在-Heroku-中使用-Django\" class=\"headerlink\" title=\"使用 AWS RDS 在 Heroku 中使用 Django\"></a>使用 AWS RDS 在 Heroku 中使用 Django</h2><p>然后，我问如果我尝试使用非单线程技术进行同样的操作会发生什么。我使用等效的处理程序为 Django 应用程序创建了完全相同的条件并将其部署到同一台服务器。结果比 Node.js 差一点，我可以在 60 秒内达到 23K 请求，因此，每秒 389 个请求。</p>\n<p><img src=\"media/16279534330189/16279555316101.jpg\"></p>\n<h2 id=\"带有-AWS-RDS-的-AWS-EB-上的-Node-js（3-个实例）\"><a href=\"#带有-AWS-RDS-的-AWS-EB-上的-Node-js（3-个实例）\" class=\"headerlink\" title=\"带有 AWS RDS 的 AWS EB 上的 Node.js（3 个实例）\"></a>带有 AWS RDS 的 AWS EB 上的 Node.js（3 个实例）</h2><p>然后，我问，如果我的 Node.js 应用程序是一个真正的生产应用程序，并且它部署在 AWS 中，针对特定流量启动并运行会怎样。我选择法兰克福(eu-central-1，对我来说它是最近的，大约3000公里😁)地区的DB和后端服务器。在这个测试中，我使用了3个Node.js实例和AWS负载平衡。我的3个实例能够在10秒内处理19K请求，这意味着每秒1858个请求。然后，我持续加载我的应用，我可以在13分钟内达到150万成功请求，这是令人兴奋的😁。</p>\n<p><img src=\"media/16279534330189/16279556113510.jpg\"></p>\n<p>那么，我们用一个实例处理600rps，我们需要什么来处理每秒40K的请求?假设平台的平均API比测试中大两倍。所以，我需要40000 /(600/2)= 133个实例，在世界各地的不同地点，一个全球性的独角兽应用。</p>\n<p>它可以大 3 倍，但也可以使用各种缓存技术、基于事件的通信等来赢得每秒更多的请求，所以我认为大 2 倍是准确的衡量标准。</p>\n<p>我想用一个有用的列表来结束这篇文章，其中列出了您在使用或将要使用的应用程序中可能会遇到的一些问题。</p>\n<h2 id=\"可能的性能问题\"><a href=\"#可能的性能问题\" class=\"headerlink\" title=\"可能的性能问题\"></a>可能的性能问题</h2><p>有无数因素会减慢我们的 API。我分离了一些我们可以在大多数 Web 服务器端应用程序中看到的与性能相关的部分。</p>\n<ul>\n<li>存储或从DB中获取的数据大小。特别是当我们谈到关系数据库时，这一点就更加重要了，因为大数据通常意味着数据库管理系统和DB内存磁盘之间的复杂查询或复杂操作。然而，在所有情况下，字节越多，所需的传输时间就越多。我们还应该记住，在DB中保存文件是一种反模式，相反，我们应该考虑使用对象存储。理想情况下，我们的数据大小不应该超过几十kb，通常是1-20kb。</li>\n<li>后端服务器与DB服务器之间的物理距离。距离越远，DB接收查询并发送回后台服务器的时间就越长。考虑一个示例，其中我们在美国弗吉尼亚和德国法兰克福有两个后端服务器，但在美国弗吉尼亚只有一个DB服务器。我们的美国用户的请求将被路由到我们的美国后端实例，延迟约为10-40ms，然后从后端(弗吉尼亚)到DB(弗吉尼亚)的延迟为1-5ms。不坏。让我们看看来自德国的用户会发生什么，“用户的设备”-“后台服务器”的延迟将是10 - 20毫秒，但查询数据将需要120 - 130毫秒。如果我们有一个单一的区域应用，理想情况下我们的数据和后端逻辑是相邻的。或者如果我们有一个全球范围的应用程序，我们应该准备好做各种复杂的工程，以获得良好的性能。</li>\n<li>DB 服务器硬件也有很大的影响。如果我们有一个小应用程序，考虑购买更好的硬件来适应我们的流量，否则——“各种复杂的工程材料”。</li>\n<li>DB调用的次数。在真实的API中，我们可以有，比如，几十个单独的DB调用来最终完成任务，除此之外，在那个API中我们还可以有服务调用，每个服务都有自己的“几十个DB调用”。我遇到的一个令人印象深刻的例子是很久以前我加入的一个项目，一个银行业的后端API。在云开发环境中有一个响应时间为9秒的API。这个API下的服务处理程序有300行代码，其中我们可以找到大约30个DB调用和大约10个内部服务调用。当我们的方法是“代码优先”而不是“设计优先”时，通常会发生这种情况。根据我们的业务逻辑，有许多解决方案可以帮助避免这种情况。例如，队列和其他异步措施可以让我们在“后台”处理一些DB调用。为了利用这一点，我们需要将大服务分解为小服务。此外，我们还可以加入查询以减少DB调用的数量。</li>\n<li>hooks。在所有流行的ODM/ orm中，都有一个称为hooks/中间件的特性。有时候，让这个特性处理一些逻辑是非常合适的。有时，特别是在处理批量操作时，我们可能会面临“隐藏的”瓶颈。ODM/ORM插件也需要计算资源，也需要花费时间(例如camelCase/pascal_case转换插件)。挂钩确实很有帮助，但需要仔细考虑我们写的内容和我们写的地方。</li>\n<li>cpu密集型的任务不仅会减慢服务器的运行速度，而且还会让最终用户等待。在Node.js中，许多cpu密集型任务依赖于线程池。尽管它不会阻塞异步IO，但它会使API变慢。例如，用户单击注册并等待线程池散列他/她的密码，顺便说一下，这需要100毫秒。</li>\n<li>事件循环的瓶颈。在Node.js中，代码的执行依赖于事件循环，所以我们的代码的性能对整个应用程序有直接的影响(因为它是在单个线程上运行的)。例如，使用JSON。解析/stringify会降低api的速度。嵌套循环和递归函数也很危险。当忽略Node.js如何工作时，根据数据大小和应用程序流量，我们可能会遇到问题，我们的应用程序可能不可用。</li>\n<li>糟糕的基础体系结构。大型基础设施中可能出现的问题不仅仅是单一应用程序中的问题，它们是不同的，有时它们需要复杂的架构解决方案。当我们的基础架构包含许多组件时，糟糕的架构会对我们的api产生巨大的影响，我们的系统将以一种资源效率低下的方式工作，这意味着我们将为原本可以更便宜的东西付出更多。因此，在设计复杂的应用程序时，我们必须考虑特定技术解决的问题，并充分了解备选方案。我们还需要考虑透视图，如果我们在两个月或六个月的时间内，在制作一个特性时，业务需求发生了变化，对每条语句都尽可能地进行猜测。考虑SLA。考虑一下非功能需求，如果流量增加怎么办?随时准备迎接意想不到的高流量，即使有理论说我们必须准备好处理比现在多10倍的流量。</li>\n<li>组件/硬件/设置。我们在基础架构中创建的组件可能会降低整个平台的运行速度。假设我们使用RabbitMQ。它像任何技术一样有大量的配置和选项。如果我们一开始就遵循标准，那也没关系。但是，随着时间的推移，如果我们做更多的研究，如果我们深入到一个特定的组件，我们意识到我们可以通过做一些设置审查，或通过重构配置或服务的使用来改进我们的基础设施。此外，我们必须根据使用情况扩展组件，以避免在基础设施中产生瓶颈。</li>\n</ul>\n"},{"title":"高效软件开发人员的 12 个习惯","_content":"\n# 高效软件开发人员的 12 个习惯\n> 原文：https://betterprogramming.pub/the-12-habits-of-highly-effective-software-developers-fffb15dc9b15\n\n\n我曾与许多软件开发人员合作过，其中一些是刚从大学毕业的，另一些是经验丰富的专业人士。这篇文章列出了这些人似乎具有的一些共同特征。\n\n## 1. 你不需要它\n\n不要编写你现在不需要的代码。虽然你认为以后会需要它，但这里的问题是双重的，结论：节省自己的时间，你不会需要它！\n\n- 毕竟你可能不需要它。现在代码就在那里闲置着，没有人敢删除它，因为谁知道如果他们这样做会破坏什么。\n\n- 未使用的代码不会更新。它可能会引入原本不必存在的错误和安全漏洞。\n\n## 2.避免过早优化\n\n过早优化代码也很诱人。这里的风险。\n\n- 你的代码对其他人来说不太清楚。\n- 你会花时间在一个可能不存在的问题上。\n\n下面就这两点进行详细说明：\n\n- 首先，优化代码以提高速度通常会使代码更难理解。\n- 你不是采取明显的、简单的路线，而是在根本不需要的地方实现缓存或循环展开或任何花哨的技术之类的东西。\n- 通常情况下，您会发现代码有多快并不重要。 CPU 周期很便宜；工作时间不是主要问题。您也可以添加更多 CPU 处理能力或等待更长时间以避免复杂性和潜在错误。\n\n## 3. 不必太聪明\n我更喜欢清晰而不是聪明。一些超级酷的单行技巧可能很适合炫耀，但对于将来阅读您的代码的人来说却是一种痛苦。不要成为那个人，可以改为在您的博客中发布很酷的技巧。\n\n我在我的另一篇文章中给出了一个完美的例子。下面是从那篇文章中copy的代码。你能自己弄清楚它是做什么的吗？你花了多长时间？\n\n```python\ntest = [1, 2, 3, 4, 2, 2, 3, 1, 4, 4, 4]\nprint(max(set(test), key = test.count))\n```\n如果将这段代码分成多行，并用一两行注释来解释 max() 函数的参数，则该代码更易于理解。尽可能使您的代码易于理解。假设它需要被另一位急于在一年后修复您的错误的程序员理解。假设另一个程序员可能就是你，因为一年后，你也忘记了那个巧妙的技巧。你该怎么办？**可维护的代码比聪明的代码更重要**。\n\n## 4. 不要重复自己\n\n初学者经常重复代码，做相同或几乎相同的事情。假设您要打开一个文件并读取其内容。您可以写几行并轻松完成。\n\n但是，如果您需要读取另一个文件并获取该文件的内容，请不要编写相同的代码来打开这个不同的文件。或者更糟：复制粘贴它！\n\n相反，您应该意识到您可以创建一个函数。这里有两个显着的优势：\n\n- 更少的代码更容易维护和调试。\n- 小函数易于测试。\n- 命名良好的函数是一种文档形式。\n\n## 5. 创建单元测试\n\n许多人都忽略了单元测试。我也为此感到内疚。我经常发现自己在事后创建单元测试，如果有的话。但即使事后添加，也总比不添加好。\n\n在最极端的形式中，您应用一种称为测试驱动开发 (TDD) 的实践。使用 TDD，您首先创建一个单元测试，然后实现该功能它迫使您测试您创建的每个函数，并仔细考虑该函数需要做什么以及预期的输出是什么。一本涵盖该主题的好书是《测试驱动开发：示例》。\n\n创建单元测试的另一个优点是您或其他人可以更有信心地更改代码。更改后，您运行所有测试。如果没有任何问题，您刚刚创建重大更改的可能性很小。\n\n创建单元测试可帮助您：\n\n- 用更少的错误编写更好的代码。\n- 在以后的coding中更有信心地调整您的代码。\n- 强迫你创建做一件事的更小的函数。\n- 通过提供使用示例来记录您的代码。\n\n## 6.保持简单，愚蠢\n\n这个强大的咒语不仅仅用于软件开发。本质上，它的意思是“不要把事情复杂化”或“尽量想出最简单的解决方案”。Dijkstra 是计算机科学的先驱之一，曾说过：“简单是可靠性的先决条件。”你的解决方案越简单，就越难引入错误。就如此容易。\n\n**简单是可靠性的先决条件**\n\n## 7.坚持固定的代码风格\n坚持编码风格。特别是在团队合作时。例如，有些人更喜欢使用这样：\n\n```\nwhile (true)\n{\n  // do cool stuff\n}\n```\n\n另一部分人喜欢：\n\n```\nwhile (true) {\n  // do cool stuff\n}\n```\n\n两者都有优点和缺点。但无论如何，坚持一个。如果你在一个团队中，这可能意味着你需要坚持一种你不喜欢的编码风格。\n\n在这方面，每种语言都有其工具和事实上的标准。你需要在谷歌上搜索你选择的语言的最佳实践。此外，对于大多数语言，您可以在 IDE 中安装自动格式化程序。它可以为您节省大量时间，因此请务必找到您喜欢的那一款。以下是一些可帮助您入门的链接：\n\n- 谷歌 [styleguide](https://google.github.io/styleguide/)\n- For Python [PEP8](https://www.python.org/dev/peps/pep-0008/)\n- For Java [Checkstyle](https://checkstyle.sourceforge.io/)\n\n## 8. 记录你的代码\n\n记录代码的三种方式：\n\n- 在代码中使用注释。\n- 在单独的文档中编写文档。\n- 编写自文档化代码。\n\n开始稀疏地使用它们。只在需要澄清的地方使用注释，不要陈述显而易见的事情。编写文档可能是有益的。想想所有这些 GitHub 存储库。在项目的根目录中包含 README.md 文件已成为事实上的标准。该文件描述了一些基本内容：\n\n- 这个代码是什么？它解决什么问题？\n- 你如何开始处理这段代码？包括创建开发环境的具体说明（如果有）\n- 最终用户如何使用该软件？\n- 提供相关链接，如更多文档、背景信息等。\n- 人们应该在哪里以及如何寻求帮助?\n\n最重要的是编写记录自身的代码。这也是最难的部分，因为它需要经验和最佳实践。为了更多地说明这一点，这里有一些帮助。\n\n- 使用良好的设计，使您的代码库易于导航和逻辑结构化。\n- 遵循最佳实践，例如 DRY（不要重复自己）、YAGNI（你不需要它）和 KISS（保持简单，愚蠢）。\n- 请使用全名。因此，将其命名为 windowManager 而不是 wm。而不是 rf，将其称为 readFileToString。当其他人——或者你自己，在几个月不看代码之后——试图理解发生了什么时，这个名字会非常有帮助。\n\n## 9. 寻求帮助：正确的方式\n\n专业人士只有在广泛尝试以其他方式寻找答案后才会寻求帮助，在你提问之前。\n\n- 阅读文档 — 也称为 RTFM，是“read the f***ing manual”的缩写。\n- 如果文档不够清楚或不能解决您的问题，请在 Google 上搜索答案。\n\n如果这没有帮助，请考虑首先向何处寻求帮助：\n\n- 错误跟踪器不是提出与（潜在）错误无关的问题的地方。\n- 开发人员邮件组面向从事产品工作的开发人员，而不是使用产品的开发人员。\n- 许多项目都有一个页面，指导您如何以及在何处提问。\n- 有专门针对特定编程语言和技术的大型 Facebook 群组可以询问更一般的问题。根据我的经验，它们可能很乱并且有很多噪音，但通常你会得到答案，所以值得检查一下。\n\n最后，在写下您的问题之前，一般来说，要尊重他人的时间。请记住以下几点：\n\n- 善良，感恩。回答您并尝试帮助您的人通常会在业余时间免费这样做。\n- 尽可能详细。提供上下文：您在做什么，为什么，到目前为止您尝试了什么？\n- 包括错误消息、（部分）日志文件和给出问题的代码。不要转储整个文件。只包括获得适当帮助所需的内容。\n\n## 10. 重构\n\n重构是在不改变其行为的情况下重构您的代码。你到底为什么要这样做？好吧，显然是为了改进您的代码！生活中有一些事实使重构变得必要：\n\n- 您的软件在第一次尝试时永远不会完美。它可能会起作用，当然，但它会很混乱，并且会有重复。\n- 计算机代码在不断发展。即使你从一个完美的代码库开始，它也会很快变得混乱。\n\n在处理新项目时，您最初需要进行重大更改，例如将初始草稿重新排序为类。一旦完成，重构就不会停止。您应该养成每次处理代码时逐步改进的习惯。每次都留下一段比你找到的更好的代码。随着时间的推移，您所做的小改进会形成一个易于阅读和维护的代码库。\n\n不断重构的一个重要影响是你的代码不太可能变成其他人的雷区。\n\n也许你以前见过这样的代码。如果你改变一行，整个事情就会莫名其妙地中断的类型。通过不断重构、重组和改进您的代码，您可以防止它变成雷区。\n\n## 11. 专业\n\n你是专业人士。我们是专业人士。我们在一个需求量很大的专业领域工作。不要让任何人，任何地方，击落你。 IT 人员仍然存在一些不应有的污名，所以让我清楚地说明一下：\n\n- 你不是极客。\n- 你不是书呆子。\n- 你不是“程序猿/程序媛”。\n\n你可能是一名软件工程师、一名数据工程师、一名数据科学家。不管你叫什么，你都是专业人士，就像律师和牙医都是专业人士一样。\n\n你已经学习并努力去做你所做的事情。您拥有几乎每个行业所需的专业知识。表现得像你的专业人士。不要害怕呼吁那些没有以应有的尊重对待我们的职业的人。\n\n## 12. 保持学习\n\n专业人士在其职业生涯中不断学习。 IT 世界中有一个常数，这个常数就是变化。\n\n每年都会引入新的语言。似乎每天都会引入新的 JavaScript 框架。您必须不断学习以保持知识的相关性和最新性。\n\n\n\n\n","source":"_posts/高效软件开发人员的 12 个习惯.md","raw":"---\ntitle: 高效软件开发人员的 12 个习惯\ntags: 趣味杂谈\n---\n\n# 高效软件开发人员的 12 个习惯\n> 原文：https://betterprogramming.pub/the-12-habits-of-highly-effective-software-developers-fffb15dc9b15\n\n\n我曾与许多软件开发人员合作过，其中一些是刚从大学毕业的，另一些是经验丰富的专业人士。这篇文章列出了这些人似乎具有的一些共同特征。\n\n## 1. 你不需要它\n\n不要编写你现在不需要的代码。虽然你认为以后会需要它，但这里的问题是双重的，结论：节省自己的时间，你不会需要它！\n\n- 毕竟你可能不需要它。现在代码就在那里闲置着，没有人敢删除它，因为谁知道如果他们这样做会破坏什么。\n\n- 未使用的代码不会更新。它可能会引入原本不必存在的错误和安全漏洞。\n\n## 2.避免过早优化\n\n过早优化代码也很诱人。这里的风险。\n\n- 你的代码对其他人来说不太清楚。\n- 你会花时间在一个可能不存在的问题上。\n\n下面就这两点进行详细说明：\n\n- 首先，优化代码以提高速度通常会使代码更难理解。\n- 你不是采取明显的、简单的路线，而是在根本不需要的地方实现缓存或循环展开或任何花哨的技术之类的东西。\n- 通常情况下，您会发现代码有多快并不重要。 CPU 周期很便宜；工作时间不是主要问题。您也可以添加更多 CPU 处理能力或等待更长时间以避免复杂性和潜在错误。\n\n## 3. 不必太聪明\n我更喜欢清晰而不是聪明。一些超级酷的单行技巧可能很适合炫耀，但对于将来阅读您的代码的人来说却是一种痛苦。不要成为那个人，可以改为在您的博客中发布很酷的技巧。\n\n我在我的另一篇文章中给出了一个完美的例子。下面是从那篇文章中copy的代码。你能自己弄清楚它是做什么的吗？你花了多长时间？\n\n```python\ntest = [1, 2, 3, 4, 2, 2, 3, 1, 4, 4, 4]\nprint(max(set(test), key = test.count))\n```\n如果将这段代码分成多行，并用一两行注释来解释 max() 函数的参数，则该代码更易于理解。尽可能使您的代码易于理解。假设它需要被另一位急于在一年后修复您的错误的程序员理解。假设另一个程序员可能就是你，因为一年后，你也忘记了那个巧妙的技巧。你该怎么办？**可维护的代码比聪明的代码更重要**。\n\n## 4. 不要重复自己\n\n初学者经常重复代码，做相同或几乎相同的事情。假设您要打开一个文件并读取其内容。您可以写几行并轻松完成。\n\n但是，如果您需要读取另一个文件并获取该文件的内容，请不要编写相同的代码来打开这个不同的文件。或者更糟：复制粘贴它！\n\n相反，您应该意识到您可以创建一个函数。这里有两个显着的优势：\n\n- 更少的代码更容易维护和调试。\n- 小函数易于测试。\n- 命名良好的函数是一种文档形式。\n\n## 5. 创建单元测试\n\n许多人都忽略了单元测试。我也为此感到内疚。我经常发现自己在事后创建单元测试，如果有的话。但即使事后添加，也总比不添加好。\n\n在最极端的形式中，您应用一种称为测试驱动开发 (TDD) 的实践。使用 TDD，您首先创建一个单元测试，然后实现该功能它迫使您测试您创建的每个函数，并仔细考虑该函数需要做什么以及预期的输出是什么。一本涵盖该主题的好书是《测试驱动开发：示例》。\n\n创建单元测试的另一个优点是您或其他人可以更有信心地更改代码。更改后，您运行所有测试。如果没有任何问题，您刚刚创建重大更改的可能性很小。\n\n创建单元测试可帮助您：\n\n- 用更少的错误编写更好的代码。\n- 在以后的coding中更有信心地调整您的代码。\n- 强迫你创建做一件事的更小的函数。\n- 通过提供使用示例来记录您的代码。\n\n## 6.保持简单，愚蠢\n\n这个强大的咒语不仅仅用于软件开发。本质上，它的意思是“不要把事情复杂化”或“尽量想出最简单的解决方案”。Dijkstra 是计算机科学的先驱之一，曾说过：“简单是可靠性的先决条件。”你的解决方案越简单，就越难引入错误。就如此容易。\n\n**简单是可靠性的先决条件**\n\n## 7.坚持固定的代码风格\n坚持编码风格。特别是在团队合作时。例如，有些人更喜欢使用这样：\n\n```\nwhile (true)\n{\n  // do cool stuff\n}\n```\n\n另一部分人喜欢：\n\n```\nwhile (true) {\n  // do cool stuff\n}\n```\n\n两者都有优点和缺点。但无论如何，坚持一个。如果你在一个团队中，这可能意味着你需要坚持一种你不喜欢的编码风格。\n\n在这方面，每种语言都有其工具和事实上的标准。你需要在谷歌上搜索你选择的语言的最佳实践。此外，对于大多数语言，您可以在 IDE 中安装自动格式化程序。它可以为您节省大量时间，因此请务必找到您喜欢的那一款。以下是一些可帮助您入门的链接：\n\n- 谷歌 [styleguide](https://google.github.io/styleguide/)\n- For Python [PEP8](https://www.python.org/dev/peps/pep-0008/)\n- For Java [Checkstyle](https://checkstyle.sourceforge.io/)\n\n## 8. 记录你的代码\n\n记录代码的三种方式：\n\n- 在代码中使用注释。\n- 在单独的文档中编写文档。\n- 编写自文档化代码。\n\n开始稀疏地使用它们。只在需要澄清的地方使用注释，不要陈述显而易见的事情。编写文档可能是有益的。想想所有这些 GitHub 存储库。在项目的根目录中包含 README.md 文件已成为事实上的标准。该文件描述了一些基本内容：\n\n- 这个代码是什么？它解决什么问题？\n- 你如何开始处理这段代码？包括创建开发环境的具体说明（如果有）\n- 最终用户如何使用该软件？\n- 提供相关链接，如更多文档、背景信息等。\n- 人们应该在哪里以及如何寻求帮助?\n\n最重要的是编写记录自身的代码。这也是最难的部分，因为它需要经验和最佳实践。为了更多地说明这一点，这里有一些帮助。\n\n- 使用良好的设计，使您的代码库易于导航和逻辑结构化。\n- 遵循最佳实践，例如 DRY（不要重复自己）、YAGNI（你不需要它）和 KISS（保持简单，愚蠢）。\n- 请使用全名。因此，将其命名为 windowManager 而不是 wm。而不是 rf，将其称为 readFileToString。当其他人——或者你自己，在几个月不看代码之后——试图理解发生了什么时，这个名字会非常有帮助。\n\n## 9. 寻求帮助：正确的方式\n\n专业人士只有在广泛尝试以其他方式寻找答案后才会寻求帮助，在你提问之前。\n\n- 阅读文档 — 也称为 RTFM，是“read the f***ing manual”的缩写。\n- 如果文档不够清楚或不能解决您的问题，请在 Google 上搜索答案。\n\n如果这没有帮助，请考虑首先向何处寻求帮助：\n\n- 错误跟踪器不是提出与（潜在）错误无关的问题的地方。\n- 开发人员邮件组面向从事产品工作的开发人员，而不是使用产品的开发人员。\n- 许多项目都有一个页面，指导您如何以及在何处提问。\n- 有专门针对特定编程语言和技术的大型 Facebook 群组可以询问更一般的问题。根据我的经验，它们可能很乱并且有很多噪音，但通常你会得到答案，所以值得检查一下。\n\n最后，在写下您的问题之前，一般来说，要尊重他人的时间。请记住以下几点：\n\n- 善良，感恩。回答您并尝试帮助您的人通常会在业余时间免费这样做。\n- 尽可能详细。提供上下文：您在做什么，为什么，到目前为止您尝试了什么？\n- 包括错误消息、（部分）日志文件和给出问题的代码。不要转储整个文件。只包括获得适当帮助所需的内容。\n\n## 10. 重构\n\n重构是在不改变其行为的情况下重构您的代码。你到底为什么要这样做？好吧，显然是为了改进您的代码！生活中有一些事实使重构变得必要：\n\n- 您的软件在第一次尝试时永远不会完美。它可能会起作用，当然，但它会很混乱，并且会有重复。\n- 计算机代码在不断发展。即使你从一个完美的代码库开始，它也会很快变得混乱。\n\n在处理新项目时，您最初需要进行重大更改，例如将初始草稿重新排序为类。一旦完成，重构就不会停止。您应该养成每次处理代码时逐步改进的习惯。每次都留下一段比你找到的更好的代码。随着时间的推移，您所做的小改进会形成一个易于阅读和维护的代码库。\n\n不断重构的一个重要影响是你的代码不太可能变成其他人的雷区。\n\n也许你以前见过这样的代码。如果你改变一行，整个事情就会莫名其妙地中断的类型。通过不断重构、重组和改进您的代码，您可以防止它变成雷区。\n\n## 11. 专业\n\n你是专业人士。我们是专业人士。我们在一个需求量很大的专业领域工作。不要让任何人，任何地方，击落你。 IT 人员仍然存在一些不应有的污名，所以让我清楚地说明一下：\n\n- 你不是极客。\n- 你不是书呆子。\n- 你不是“程序猿/程序媛”。\n\n你可能是一名软件工程师、一名数据工程师、一名数据科学家。不管你叫什么，你都是专业人士，就像律师和牙医都是专业人士一样。\n\n你已经学习并努力去做你所做的事情。您拥有几乎每个行业所需的专业知识。表现得像你的专业人士。不要害怕呼吁那些没有以应有的尊重对待我们的职业的人。\n\n## 12. 保持学习\n\n专业人士在其职业生涯中不断学习。 IT 世界中有一个常数，这个常数就是变化。\n\n每年都会引入新的语言。似乎每天都会引入新的 JavaScript 框架。您必须不断学习以保持知识的相关性和最新性。\n\n\n\n\n","slug":"高效软件开发人员的 12 个习惯","published":1,"date":"2021-08-02T05:49:59.193Z","updated":"2021-12-28T02:12:51.057Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckxph7qmp00101op7cu6e4pq1","content":"<h1 id=\"高效软件开发人员的-12-个习惯\"><a href=\"#高效软件开发人员的-12-个习惯\" class=\"headerlink\" title=\"高效软件开发人员的 12 个习惯\"></a>高效软件开发人员的 12 个习惯</h1><blockquote>\n<p>原文：<a href=\"https://betterprogramming.pub/the-12-habits-of-highly-effective-software-developers-fffb15dc9b15\">https://betterprogramming.pub/the-12-habits-of-highly-effective-software-developers-fffb15dc9b15</a></p>\n</blockquote>\n<p>我曾与许多软件开发人员合作过，其中一些是刚从大学毕业的，另一些是经验丰富的专业人士。这篇文章列出了这些人似乎具有的一些共同特征。</p>\n<h2 id=\"1-你不需要它\"><a href=\"#1-你不需要它\" class=\"headerlink\" title=\"1. 你不需要它\"></a>1. 你不需要它</h2><p>不要编写你现在不需要的代码。虽然你认为以后会需要它，但这里的问题是双重的，结论：节省自己的时间，你不会需要它！</p>\n<ul>\n<li><p>毕竟你可能不需要它。现在代码就在那里闲置着，没有人敢删除它，因为谁知道如果他们这样做会破坏什么。</p>\n</li>\n<li><p>未使用的代码不会更新。它可能会引入原本不必存在的错误和安全漏洞。</p>\n</li>\n</ul>\n<h2 id=\"2-避免过早优化\"><a href=\"#2-避免过早优化\" class=\"headerlink\" title=\"2.避免过早优化\"></a>2.避免过早优化</h2><p>过早优化代码也很诱人。这里的风险。</p>\n<ul>\n<li>你的代码对其他人来说不太清楚。</li>\n<li>你会花时间在一个可能不存在的问题上。</li>\n</ul>\n<p>下面就这两点进行详细说明：</p>\n<ul>\n<li>首先，优化代码以提高速度通常会使代码更难理解。</li>\n<li>你不是采取明显的、简单的路线，而是在根本不需要的地方实现缓存或循环展开或任何花哨的技术之类的东西。</li>\n<li>通常情况下，您会发现代码有多快并不重要。 CPU 周期很便宜；工作时间不是主要问题。您也可以添加更多 CPU 处理能力或等待更长时间以避免复杂性和潜在错误。</li>\n</ul>\n<h2 id=\"3-不必太聪明\"><a href=\"#3-不必太聪明\" class=\"headerlink\" title=\"3. 不必太聪明\"></a>3. 不必太聪明</h2><p>我更喜欢清晰而不是聪明。一些超级酷的单行技巧可能很适合炫耀，但对于将来阅读您的代码的人来说却是一种痛苦。不要成为那个人，可以改为在您的博客中发布很酷的技巧。</p>\n<p>我在我的另一篇文章中给出了一个完美的例子。下面是从那篇文章中copy的代码。你能自己弄清楚它是做什么的吗？你花了多长时间？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">max</span>(<span class=\"built_in\">set</span>(test), key = test.count))</span><br></pre></td></tr></table></figure>\n<p>如果将这段代码分成多行，并用一两行注释来解释 max() 函数的参数，则该代码更易于理解。尽可能使您的代码易于理解。假设它需要被另一位急于在一年后修复您的错误的程序员理解。假设另一个程序员可能就是你，因为一年后，你也忘记了那个巧妙的技巧。你该怎么办？<strong>可维护的代码比聪明的代码更重要</strong>。</p>\n<h2 id=\"4-不要重复自己\"><a href=\"#4-不要重复自己\" class=\"headerlink\" title=\"4. 不要重复自己\"></a>4. 不要重复自己</h2><p>初学者经常重复代码，做相同或几乎相同的事情。假设您要打开一个文件并读取其内容。您可以写几行并轻松完成。</p>\n<p>但是，如果您需要读取另一个文件并获取该文件的内容，请不要编写相同的代码来打开这个不同的文件。或者更糟：复制粘贴它！</p>\n<p>相反，您应该意识到您可以创建一个函数。这里有两个显着的优势：</p>\n<ul>\n<li>更少的代码更容易维护和调试。</li>\n<li>小函数易于测试。</li>\n<li>命名良好的函数是一种文档形式。</li>\n</ul>\n<h2 id=\"5-创建单元测试\"><a href=\"#5-创建单元测试\" class=\"headerlink\" title=\"5. 创建单元测试\"></a>5. 创建单元测试</h2><p>许多人都忽略了单元测试。我也为此感到内疚。我经常发现自己在事后创建单元测试，如果有的话。但即使事后添加，也总比不添加好。</p>\n<p>在最极端的形式中，您应用一种称为测试驱动开发 (TDD) 的实践。使用 TDD，您首先创建一个单元测试，然后实现该功能它迫使您测试您创建的每个函数，并仔细考虑该函数需要做什么以及预期的输出是什么。一本涵盖该主题的好书是《测试驱动开发：示例》。</p>\n<p>创建单元测试的另一个优点是您或其他人可以更有信心地更改代码。更改后，您运行所有测试。如果没有任何问题，您刚刚创建重大更改的可能性很小。</p>\n<p>创建单元测试可帮助您：</p>\n<ul>\n<li>用更少的错误编写更好的代码。</li>\n<li>在以后的coding中更有信心地调整您的代码。</li>\n<li>强迫你创建做一件事的更小的函数。</li>\n<li>通过提供使用示例来记录您的代码。</li>\n</ul>\n<h2 id=\"6-保持简单，愚蠢\"><a href=\"#6-保持简单，愚蠢\" class=\"headerlink\" title=\"6.保持简单，愚蠢\"></a>6.保持简单，愚蠢</h2><p>这个强大的咒语不仅仅用于软件开发。本质上，它的意思是“不要把事情复杂化”或“尽量想出最简单的解决方案”。Dijkstra 是计算机科学的先驱之一，曾说过：“简单是可靠性的先决条件。”你的解决方案越简单，就越难引入错误。就如此容易。</p>\n<p><strong>简单是可靠性的先决条件</strong></p>\n<h2 id=\"7-坚持固定的代码风格\"><a href=\"#7-坚持固定的代码风格\" class=\"headerlink\" title=\"7.坚持固定的代码风格\"></a>7.坚持固定的代码风格</h2><p>坚持编码风格。特别是在团队合作时。例如，有些人更喜欢使用这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while (true)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // do cool stuff</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另一部分人喜欢：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while (true) &#123;</span><br><span class=\"line\">  // do cool stuff</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>两者都有优点和缺点。但无论如何，坚持一个。如果你在一个团队中，这可能意味着你需要坚持一种你不喜欢的编码风格。</p>\n<p>在这方面，每种语言都有其工具和事实上的标准。你需要在谷歌上搜索你选择的语言的最佳实践。此外，对于大多数语言，您可以在 IDE 中安装自动格式化程序。它可以为您节省大量时间，因此请务必找到您喜欢的那一款。以下是一些可帮助您入门的链接：</p>\n<ul>\n<li>谷歌 <a href=\"https://google.github.io/styleguide/\">styleguide</a></li>\n<li>For Python <a href=\"https://www.python.org/dev/peps/pep-0008/\">PEP8</a></li>\n<li>For Java <a href=\"https://checkstyle.sourceforge.io/\">Checkstyle</a></li>\n</ul>\n<h2 id=\"8-记录你的代码\"><a href=\"#8-记录你的代码\" class=\"headerlink\" title=\"8. 记录你的代码\"></a>8. 记录你的代码</h2><p>记录代码的三种方式：</p>\n<ul>\n<li>在代码中使用注释。</li>\n<li>在单独的文档中编写文档。</li>\n<li>编写自文档化代码。</li>\n</ul>\n<p>开始稀疏地使用它们。只在需要澄清的地方使用注释，不要陈述显而易见的事情。编写文档可能是有益的。想想所有这些 GitHub 存储库。在项目的根目录中包含 README.md 文件已成为事实上的标准。该文件描述了一些基本内容：</p>\n<ul>\n<li>这个代码是什么？它解决什么问题？</li>\n<li>你如何开始处理这段代码？包括创建开发环境的具体说明（如果有）</li>\n<li>最终用户如何使用该软件？</li>\n<li>提供相关链接，如更多文档、背景信息等。</li>\n<li>人们应该在哪里以及如何寻求帮助?</li>\n</ul>\n<p>最重要的是编写记录自身的代码。这也是最难的部分，因为它需要经验和最佳实践。为了更多地说明这一点，这里有一些帮助。</p>\n<ul>\n<li>使用良好的设计，使您的代码库易于导航和逻辑结构化。</li>\n<li>遵循最佳实践，例如 DRY（不要重复自己）、YAGNI（你不需要它）和 KISS（保持简单，愚蠢）。</li>\n<li>请使用全名。因此，将其命名为 windowManager 而不是 wm。而不是 rf，将其称为 readFileToString。当其他人——或者你自己，在几个月不看代码之后——试图理解发生了什么时，这个名字会非常有帮助。</li>\n</ul>\n<h2 id=\"9-寻求帮助：正确的方式\"><a href=\"#9-寻求帮助：正确的方式\" class=\"headerlink\" title=\"9. 寻求帮助：正确的方式\"></a>9. 寻求帮助：正确的方式</h2><p>专业人士只有在广泛尝试以其他方式寻找答案后才会寻求帮助，在你提问之前。</p>\n<ul>\n<li>阅读文档 — 也称为 RTFM，是“read the f***ing manual”的缩写。</li>\n<li>如果文档不够清楚或不能解决您的问题，请在 Google 上搜索答案。</li>\n</ul>\n<p>如果这没有帮助，请考虑首先向何处寻求帮助：</p>\n<ul>\n<li>错误跟踪器不是提出与（潜在）错误无关的问题的地方。</li>\n<li>开发人员邮件组面向从事产品工作的开发人员，而不是使用产品的开发人员。</li>\n<li>许多项目都有一个页面，指导您如何以及在何处提问。</li>\n<li>有专门针对特定编程语言和技术的大型 Facebook 群组可以询问更一般的问题。根据我的经验，它们可能很乱并且有很多噪音，但通常你会得到答案，所以值得检查一下。</li>\n</ul>\n<p>最后，在写下您的问题之前，一般来说，要尊重他人的时间。请记住以下几点：</p>\n<ul>\n<li>善良，感恩。回答您并尝试帮助您的人通常会在业余时间免费这样做。</li>\n<li>尽可能详细。提供上下文：您在做什么，为什么，到目前为止您尝试了什么？</li>\n<li>包括错误消息、（部分）日志文件和给出问题的代码。不要转储整个文件。只包括获得适当帮助所需的内容。</li>\n</ul>\n<h2 id=\"10-重构\"><a href=\"#10-重构\" class=\"headerlink\" title=\"10. 重构\"></a>10. 重构</h2><p>重构是在不改变其行为的情况下重构您的代码。你到底为什么要这样做？好吧，显然是为了改进您的代码！生活中有一些事实使重构变得必要：</p>\n<ul>\n<li>您的软件在第一次尝试时永远不会完美。它可能会起作用，当然，但它会很混乱，并且会有重复。</li>\n<li>计算机代码在不断发展。即使你从一个完美的代码库开始，它也会很快变得混乱。</li>\n</ul>\n<p>在处理新项目时，您最初需要进行重大更改，例如将初始草稿重新排序为类。一旦完成，重构就不会停止。您应该养成每次处理代码时逐步改进的习惯。每次都留下一段比你找到的更好的代码。随着时间的推移，您所做的小改进会形成一个易于阅读和维护的代码库。</p>\n<p>不断重构的一个重要影响是你的代码不太可能变成其他人的雷区。</p>\n<p>也许你以前见过这样的代码。如果你改变一行，整个事情就会莫名其妙地中断的类型。通过不断重构、重组和改进您的代码，您可以防止它变成雷区。</p>\n<h2 id=\"11-专业\"><a href=\"#11-专业\" class=\"headerlink\" title=\"11. 专业\"></a>11. 专业</h2><p>你是专业人士。我们是专业人士。我们在一个需求量很大的专业领域工作。不要让任何人，任何地方，击落你。 IT 人员仍然存在一些不应有的污名，所以让我清楚地说明一下：</p>\n<ul>\n<li>你不是极客。</li>\n<li>你不是书呆子。</li>\n<li>你不是“程序猿/程序媛”。</li>\n</ul>\n<p>你可能是一名软件工程师、一名数据工程师、一名数据科学家。不管你叫什么，你都是专业人士，就像律师和牙医都是专业人士一样。</p>\n<p>你已经学习并努力去做你所做的事情。您拥有几乎每个行业所需的专业知识。表现得像你的专业人士。不要害怕呼吁那些没有以应有的尊重对待我们的职业的人。</p>\n<h2 id=\"12-保持学习\"><a href=\"#12-保持学习\" class=\"headerlink\" title=\"12. 保持学习\"></a>12. 保持学习</h2><p>专业人士在其职业生涯中不断学习。 IT 世界中有一个常数，这个常数就是变化。</p>\n<p>每年都会引入新的语言。似乎每天都会引入新的 JavaScript 框架。您必须不断学习以保持知识的相关性和最新性。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"高效软件开发人员的-12-个习惯\"><a href=\"#高效软件开发人员的-12-个习惯\" class=\"headerlink\" title=\"高效软件开发人员的 12 个习惯\"></a>高效软件开发人员的 12 个习惯</h1><blockquote>\n<p>原文：<a href=\"https://betterprogramming.pub/the-12-habits-of-highly-effective-software-developers-fffb15dc9b15\">https://betterprogramming.pub/the-12-habits-of-highly-effective-software-developers-fffb15dc9b15</a></p>\n</blockquote>\n<p>我曾与许多软件开发人员合作过，其中一些是刚从大学毕业的，另一些是经验丰富的专业人士。这篇文章列出了这些人似乎具有的一些共同特征。</p>\n<h2 id=\"1-你不需要它\"><a href=\"#1-你不需要它\" class=\"headerlink\" title=\"1. 你不需要它\"></a>1. 你不需要它</h2><p>不要编写你现在不需要的代码。虽然你认为以后会需要它，但这里的问题是双重的，结论：节省自己的时间，你不会需要它！</p>\n<ul>\n<li><p>毕竟你可能不需要它。现在代码就在那里闲置着，没有人敢删除它，因为谁知道如果他们这样做会破坏什么。</p>\n</li>\n<li><p>未使用的代码不会更新。它可能会引入原本不必存在的错误和安全漏洞。</p>\n</li>\n</ul>\n<h2 id=\"2-避免过早优化\"><a href=\"#2-避免过早优化\" class=\"headerlink\" title=\"2.避免过早优化\"></a>2.避免过早优化</h2><p>过早优化代码也很诱人。这里的风险。</p>\n<ul>\n<li>你的代码对其他人来说不太清楚。</li>\n<li>你会花时间在一个可能不存在的问题上。</li>\n</ul>\n<p>下面就这两点进行详细说明：</p>\n<ul>\n<li>首先，优化代码以提高速度通常会使代码更难理解。</li>\n<li>你不是采取明显的、简单的路线，而是在根本不需要的地方实现缓存或循环展开或任何花哨的技术之类的东西。</li>\n<li>通常情况下，您会发现代码有多快并不重要。 CPU 周期很便宜；工作时间不是主要问题。您也可以添加更多 CPU 处理能力或等待更长时间以避免复杂性和潜在错误。</li>\n</ul>\n<h2 id=\"3-不必太聪明\"><a href=\"#3-不必太聪明\" class=\"headerlink\" title=\"3. 不必太聪明\"></a>3. 不必太聪明</h2><p>我更喜欢清晰而不是聪明。一些超级酷的单行技巧可能很适合炫耀，但对于将来阅读您的代码的人来说却是一种痛苦。不要成为那个人，可以改为在您的博客中发布很酷的技巧。</p>\n<p>我在我的另一篇文章中给出了一个完美的例子。下面是从那篇文章中copy的代码。你能自己弄清楚它是做什么的吗？你花了多长时间？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">test = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">max</span>(<span class=\"built_in\">set</span>(test), key = test.count))</span><br></pre></td></tr></table></figure>\n<p>如果将这段代码分成多行，并用一两行注释来解释 max() 函数的参数，则该代码更易于理解。尽可能使您的代码易于理解。假设它需要被另一位急于在一年后修复您的错误的程序员理解。假设另一个程序员可能就是你，因为一年后，你也忘记了那个巧妙的技巧。你该怎么办？<strong>可维护的代码比聪明的代码更重要</strong>。</p>\n<h2 id=\"4-不要重复自己\"><a href=\"#4-不要重复自己\" class=\"headerlink\" title=\"4. 不要重复自己\"></a>4. 不要重复自己</h2><p>初学者经常重复代码，做相同或几乎相同的事情。假设您要打开一个文件并读取其内容。您可以写几行并轻松完成。</p>\n<p>但是，如果您需要读取另一个文件并获取该文件的内容，请不要编写相同的代码来打开这个不同的文件。或者更糟：复制粘贴它！</p>\n<p>相反，您应该意识到您可以创建一个函数。这里有两个显着的优势：</p>\n<ul>\n<li>更少的代码更容易维护和调试。</li>\n<li>小函数易于测试。</li>\n<li>命名良好的函数是一种文档形式。</li>\n</ul>\n<h2 id=\"5-创建单元测试\"><a href=\"#5-创建单元测试\" class=\"headerlink\" title=\"5. 创建单元测试\"></a>5. 创建单元测试</h2><p>许多人都忽略了单元测试。我也为此感到内疚。我经常发现自己在事后创建单元测试，如果有的话。但即使事后添加，也总比不添加好。</p>\n<p>在最极端的形式中，您应用一种称为测试驱动开发 (TDD) 的实践。使用 TDD，您首先创建一个单元测试，然后实现该功能它迫使您测试您创建的每个函数，并仔细考虑该函数需要做什么以及预期的输出是什么。一本涵盖该主题的好书是《测试驱动开发：示例》。</p>\n<p>创建单元测试的另一个优点是您或其他人可以更有信心地更改代码。更改后，您运行所有测试。如果没有任何问题，您刚刚创建重大更改的可能性很小。</p>\n<p>创建单元测试可帮助您：</p>\n<ul>\n<li>用更少的错误编写更好的代码。</li>\n<li>在以后的coding中更有信心地调整您的代码。</li>\n<li>强迫你创建做一件事的更小的函数。</li>\n<li>通过提供使用示例来记录您的代码。</li>\n</ul>\n<h2 id=\"6-保持简单，愚蠢\"><a href=\"#6-保持简单，愚蠢\" class=\"headerlink\" title=\"6.保持简单，愚蠢\"></a>6.保持简单，愚蠢</h2><p>这个强大的咒语不仅仅用于软件开发。本质上，它的意思是“不要把事情复杂化”或“尽量想出最简单的解决方案”。Dijkstra 是计算机科学的先驱之一，曾说过：“简单是可靠性的先决条件。”你的解决方案越简单，就越难引入错误。就如此容易。</p>\n<p><strong>简单是可靠性的先决条件</strong></p>\n<h2 id=\"7-坚持固定的代码风格\"><a href=\"#7-坚持固定的代码风格\" class=\"headerlink\" title=\"7.坚持固定的代码风格\"></a>7.坚持固定的代码风格</h2><p>坚持编码风格。特别是在团队合作时。例如，有些人更喜欢使用这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while (true)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // do cool stuff</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另一部分人喜欢：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while (true) &#123;</span><br><span class=\"line\">  // do cool stuff</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>两者都有优点和缺点。但无论如何，坚持一个。如果你在一个团队中，这可能意味着你需要坚持一种你不喜欢的编码风格。</p>\n<p>在这方面，每种语言都有其工具和事实上的标准。你需要在谷歌上搜索你选择的语言的最佳实践。此外，对于大多数语言，您可以在 IDE 中安装自动格式化程序。它可以为您节省大量时间，因此请务必找到您喜欢的那一款。以下是一些可帮助您入门的链接：</p>\n<ul>\n<li>谷歌 <a href=\"https://google.github.io/styleguide/\">styleguide</a></li>\n<li>For Python <a href=\"https://www.python.org/dev/peps/pep-0008/\">PEP8</a></li>\n<li>For Java <a href=\"https://checkstyle.sourceforge.io/\">Checkstyle</a></li>\n</ul>\n<h2 id=\"8-记录你的代码\"><a href=\"#8-记录你的代码\" class=\"headerlink\" title=\"8. 记录你的代码\"></a>8. 记录你的代码</h2><p>记录代码的三种方式：</p>\n<ul>\n<li>在代码中使用注释。</li>\n<li>在单独的文档中编写文档。</li>\n<li>编写自文档化代码。</li>\n</ul>\n<p>开始稀疏地使用它们。只在需要澄清的地方使用注释，不要陈述显而易见的事情。编写文档可能是有益的。想想所有这些 GitHub 存储库。在项目的根目录中包含 README.md 文件已成为事实上的标准。该文件描述了一些基本内容：</p>\n<ul>\n<li>这个代码是什么？它解决什么问题？</li>\n<li>你如何开始处理这段代码？包括创建开发环境的具体说明（如果有）</li>\n<li>最终用户如何使用该软件？</li>\n<li>提供相关链接，如更多文档、背景信息等。</li>\n<li>人们应该在哪里以及如何寻求帮助?</li>\n</ul>\n<p>最重要的是编写记录自身的代码。这也是最难的部分，因为它需要经验和最佳实践。为了更多地说明这一点，这里有一些帮助。</p>\n<ul>\n<li>使用良好的设计，使您的代码库易于导航和逻辑结构化。</li>\n<li>遵循最佳实践，例如 DRY（不要重复自己）、YAGNI（你不需要它）和 KISS（保持简单，愚蠢）。</li>\n<li>请使用全名。因此，将其命名为 windowManager 而不是 wm。而不是 rf，将其称为 readFileToString。当其他人——或者你自己，在几个月不看代码之后——试图理解发生了什么时，这个名字会非常有帮助。</li>\n</ul>\n<h2 id=\"9-寻求帮助：正确的方式\"><a href=\"#9-寻求帮助：正确的方式\" class=\"headerlink\" title=\"9. 寻求帮助：正确的方式\"></a>9. 寻求帮助：正确的方式</h2><p>专业人士只有在广泛尝试以其他方式寻找答案后才会寻求帮助，在你提问之前。</p>\n<ul>\n<li>阅读文档 — 也称为 RTFM，是“read the f***ing manual”的缩写。</li>\n<li>如果文档不够清楚或不能解决您的问题，请在 Google 上搜索答案。</li>\n</ul>\n<p>如果这没有帮助，请考虑首先向何处寻求帮助：</p>\n<ul>\n<li>错误跟踪器不是提出与（潜在）错误无关的问题的地方。</li>\n<li>开发人员邮件组面向从事产品工作的开发人员，而不是使用产品的开发人员。</li>\n<li>许多项目都有一个页面，指导您如何以及在何处提问。</li>\n<li>有专门针对特定编程语言和技术的大型 Facebook 群组可以询问更一般的问题。根据我的经验，它们可能很乱并且有很多噪音，但通常你会得到答案，所以值得检查一下。</li>\n</ul>\n<p>最后，在写下您的问题之前，一般来说，要尊重他人的时间。请记住以下几点：</p>\n<ul>\n<li>善良，感恩。回答您并尝试帮助您的人通常会在业余时间免费这样做。</li>\n<li>尽可能详细。提供上下文：您在做什么，为什么，到目前为止您尝试了什么？</li>\n<li>包括错误消息、（部分）日志文件和给出问题的代码。不要转储整个文件。只包括获得适当帮助所需的内容。</li>\n</ul>\n<h2 id=\"10-重构\"><a href=\"#10-重构\" class=\"headerlink\" title=\"10. 重构\"></a>10. 重构</h2><p>重构是在不改变其行为的情况下重构您的代码。你到底为什么要这样做？好吧，显然是为了改进您的代码！生活中有一些事实使重构变得必要：</p>\n<ul>\n<li>您的软件在第一次尝试时永远不会完美。它可能会起作用，当然，但它会很混乱，并且会有重复。</li>\n<li>计算机代码在不断发展。即使你从一个完美的代码库开始，它也会很快变得混乱。</li>\n</ul>\n<p>在处理新项目时，您最初需要进行重大更改，例如将初始草稿重新排序为类。一旦完成，重构就不会停止。您应该养成每次处理代码时逐步改进的习惯。每次都留下一段比你找到的更好的代码。随着时间的推移，您所做的小改进会形成一个易于阅读和维护的代码库。</p>\n<p>不断重构的一个重要影响是你的代码不太可能变成其他人的雷区。</p>\n<p>也许你以前见过这样的代码。如果你改变一行，整个事情就会莫名其妙地中断的类型。通过不断重构、重组和改进您的代码，您可以防止它变成雷区。</p>\n<h2 id=\"11-专业\"><a href=\"#11-专业\" class=\"headerlink\" title=\"11. 专业\"></a>11. 专业</h2><p>你是专业人士。我们是专业人士。我们在一个需求量很大的专业领域工作。不要让任何人，任何地方，击落你。 IT 人员仍然存在一些不应有的污名，所以让我清楚地说明一下：</p>\n<ul>\n<li>你不是极客。</li>\n<li>你不是书呆子。</li>\n<li>你不是“程序猿/程序媛”。</li>\n</ul>\n<p>你可能是一名软件工程师、一名数据工程师、一名数据科学家。不管你叫什么，你都是专业人士，就像律师和牙医都是专业人士一样。</p>\n<p>你已经学习并努力去做你所做的事情。您拥有几乎每个行业所需的专业知识。表现得像你的专业人士。不要害怕呼吁那些没有以应有的尊重对待我们的职业的人。</p>\n<h2 id=\"12-保持学习\"><a href=\"#12-保持学习\" class=\"headerlink\" title=\"12. 保持学习\"></a>12. 保持学习</h2><p>专业人士在其职业生涯中不断学习。 IT 世界中有一个常数，这个常数就是变化。</p>\n<p>每年都会引入新的语言。似乎每天都会引入新的 JavaScript 框架。您必须不断学习以保持知识的相关性和最新性。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckxph7qm000001op7ebbpepd7","tag_id":"ckxph7qm600021op7bni20dqo","_id":"ckxph7qma00071op70bp4dp4o"},{"post_id":"ckxph7qma00081op79h15g4kg","tag_id":"ckxph7qm600021op7bni20dqo","_id":"ckxph7qmd000b1op70yl4abkm"},{"post_id":"ckxph7qm400011op7e5vackdp","tag_id":"ckxph7qma00061op7cmpgb4e6","_id":"ckxph7qme000d1op7aeqr1a5b"},{"post_id":"ckxph7qmb00091op72hoig3vd","tag_id":"ckxph7qm600021op7bni20dqo","_id":"ckxph7qmf000g1op7bx2tedtt"},{"post_id":"ckxph7qm700031op756h37h9w","tag_id":"ckxph7qmd000a1op737xw50ky","_id":"ckxph7qmg000i1op70aji85yk"},{"post_id":"ckxph7qm800041op7h7v64ahg","tag_id":"ckxph7qmf000f1op7f3fa5az6","_id":"ckxph7qmj000m1op767fw0f9a"},{"post_id":"ckxph7qmh000l1op759j4dxor","tag_id":"ckxph7qm600021op7bni20dqo","_id":"ckxph7qmk000o1op75rpgak47"},{"post_id":"ckxph7qm900051op7fv2i5u6t","tag_id":"ckxph7qmf000f1op7f3fa5az6","_id":"ckxph7qml000r1op75nhm3kiv"},{"post_id":"ckxph7qmd000c1op7csmih13a","tag_id":"ckxph7qmk000p1op77e83csjs","_id":"ckxph7qmn000v1op7fpz52zq8"},{"post_id":"ckxph7qmn000w1op7afvm9ez3","tag_id":"ckxph7qmf000f1op7f3fa5az6","_id":"ckxph7qmp000z1op706fvcycc"},{"post_id":"ckxph7qme000e1op73sckatnx","tag_id":"ckxph7qmm000u1op77l4p2tdz","_id":"ckxph7qmp00111op78bbpcgvb"},{"post_id":"ckxph7qmo000x1op7cs0r94vp","tag_id":"ckxph7qmf000f1op7f3fa5az6","_id":"ckxph7qmq00131op75no2arsb"},{"post_id":"ckxph7qmp00101op7cu6e4pq1","tag_id":"ckxph7qma00061op7cmpgb4e6","_id":"ckxph7qmq00141op71i8m42kr"},{"post_id":"ckxph7qmg000j1op728rc0dfb","tag_id":"ckxph7qmm000u1op77l4p2tdz","_id":"ckxph7qmq00161op7dk1wclaj"},{"post_id":"ckxph7qmj000n1op76xhk361g","tag_id":"ckxph7qmq00121op772y3dq5l","_id":"ckxph7qmr00171op7f1xp0n8e"},{"post_id":"ckxph7qmk000q1op7fdx5b0j5","tag_id":"ckxph7qmq00151op73mp20gqc","_id":"ckxph7qmr00191op73m6cebo4"},{"post_id":"ckxph7qml000s1op715gzfr0i","tag_id":"ckxph7qmr00181op77lpocjpc","_id":"ckxph7qms001b1op721da1kpk"},{"post_id":"ckxph7qmm000t1op79sds2sz5","tag_id":"ckxph7qmr001a1op7bpwialdd","_id":"ckxph7qms001c1op7ebjvdcjq"},{"post_id":"ckxph7qmf000h1op71fwkbwh5","tag_id":"ckxph7qmr00181op77lpocjpc","_id":"ckxph8ihf001e1op7eje551uv"}],"Tag":[{"name":"vue","_id":"ckxph7qm600021op7bni20dqo"},{"name":"趣味杂谈","_id":"ckxph7qma00061op7cmpgb4e6"},{"name":"java","_id":"ckxph7qmd000a1op737xw50ky"},{"name":"node","_id":"ckxph7qmf000f1op7f3fa5az6"},{"name":"react","_id":"ckxph7qmk000p1op77e83csjs"},{"name":"js","_id":"ckxph7qmm000u1op77l4p2tdz"},{"name":"性能优化","_id":"ckxph7qmq00121op772y3dq5l"},{"name":"css","_id":"ckxph7qmq00151op73mp20gqc"},{"name":"浏览器","_id":"ckxph7qmr00181op77lpocjpc"},{"name":"运维","_id":"ckxph7qmr001a1op7bpwialdd"}]}}